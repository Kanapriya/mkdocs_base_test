{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Best_Practices_Guide/","text":"Best Practices Guide Given below are the best practices to follow for different file types when updating your products. Following these best practices ensures a seamless update process and a lower number of merge conflicts. File Type Best Practices .jar files Do not modify the original .jar files. When updating your product, the WSO2 in-place tool replaces the existing .jar files with updated ones. If you modify the original .jar files, your customization will be lost. To avoid this, use an extension point as explained in Using Extension Points in Carbon and https://github.com/wso2-extensions. See https://store.wso2.com/store/pages/top-assets for a list of released connectors and extensions. .war files Do not modify .war files. It is not recommended to modify .war files. In case you have modified .war files in your distribution, after updating your product distribution, reapply your modifications in the updated .war files. .car files Do not modify the original .car files. In case your original product distribution contains .car files, do not modify them as they can be changed by continuous updates. .jag/.js files Maintain the same code indentation of the original .js files in the updated .js files. .jks files The in-place update tool doesn't update .jks files. .json files Maintain the same code indentation of the original .json files in the updated .json files. Else, there will be merge conflicts. ??? note \"Click to see example\" Shown below is the difference between a .json file before and after a modification. As shown, the indentation has changed in the updated file and this might result in a merge conflict in the WSO2 in-place update tool. Maintain the order of the .json file as much as possible. For example, when you add a new key-value pair, add it to the end of the file. ??? note \"Click to see example\" Shown below is the difference between a .json file before and after a modification. As shown, the new key-value pair is not added to the end of the file. As a result, line number 2 in the original file is not the same as the updated file, which will cause a merge conflict in the WSO2 in-place update tool. There will not be merge conflicts when the new line is added to the end of the file, preserving the original order:","title":"Best Practices Guide"},{"location":"Best_Practices_Guide/#best-practices-guide","text":"Given below are the best practices to follow for different file types when updating your products. Following these best practices ensures a seamless update process and a lower number of merge conflicts. File Type Best Practices .jar files Do not modify the original .jar files. When updating your product, the WSO2 in-place tool replaces the existing .jar files with updated ones. If you modify the original .jar files, your customization will be lost. To avoid this, use an extension point as explained in Using Extension Points in Carbon and https://github.com/wso2-extensions. See https://store.wso2.com/store/pages/top-assets for a list of released connectors and extensions. .war files Do not modify .war files. It is not recommended to modify .war files. In case you have modified .war files in your distribution, after updating your product distribution, reapply your modifications in the updated .war files. .car files Do not modify the original .car files. In case your original product distribution contains .car files, do not modify them as they can be changed by continuous updates. .jag/.js files Maintain the same code indentation of the original .js files in the updated .js files. .jks files The in-place update tool doesn't update .jks files. .json files Maintain the same code indentation of the original .json files in the updated .json files. Else, there will be merge conflicts. ??? note \"Click to see example\" Shown below is the difference between a .json file before and after a modification. As shown, the indentation has changed in the updated file and this might result in a merge conflict in the WSO2 in-place update tool. Maintain the order of the .json file as much as possible. For example, when you add a new key-value pair, add it to the end of the file. ??? note \"Click to see example\" Shown below is the difference between a .json file before and after a modification. As shown, the new key-value pair is not added to the end of the file. As a result, line number 2 in the original file is not the same as the updated file, which will cause a merge conflict in the WSO2 in-place update tool. There will not be merge conflicts when the new line is added to the end of the file, preserving the original order:","title":"Best Practices Guide"},{"location":"Developer_Guide/","text":"Developer Guide The WSO2 Update TESTING Creator tool (wum-uc) is designed to help you create and validate updates that are compatible with WUM. It is written in GO language. As a result, you can compile the code directly to machine code without using the JVM. Cross compiling is also possible. This document describes how to use the Update Creator tool to create an update directly or convert a patch to an update. Before you begin, here are the descriptions of the files used in this guide. The wum-uc tool generates both these files. {.expand-control-image}update-descriptor3.yaml file This is a newly introduced file that contains details about the update that complies with WUM 3.0.0 . Every update has an update-descriptor3.yaml file. It has details about the products that this update is fully or partially compatible with, the file changes (added, removed, or modified), descriptions, and instructions. A sample file looks like the following: update_number: 2922 platform_version: 4.4.0 platform_name: wilkes md5sum: 8f6e83731d c1da6634c6d24c92606d06 description: | Details about the update for wso2am - 2.1.0 . standard Details about the update for wso2am - 2.0.0 . standard Details about the update for wso2esb - 5.0.0 . standard Details about the update for wso2is - km - 5.3.0 . standard instructions: | Instructions for wso2am - 2.1.0 . standard Instructions for wso2am - 2.0.0 . standard Instructions for wso2esb - 5.0.0 . standard Instructions for wso2is - km - 5.3.0 . standard bug_fixes: JIRA_ID : Summary compatible_products: - product_name : wso2am product_version : 2.1.0 . standard added_files : [] removed_files : - repository / components / plugins / org . wso2 . carbon . governance . lcm_4 .7.0 . jar modified_files : - repository / components / plugins / io . netty . handler_4 .0.30 . Final . jar - repository / components / plugins / oltu_1 .0.0 . wso2v3 . jar partially_applicable_products: - product_name : wso2am product_version : 2.0.0 . standard added_files : [] removed_files : [] modified_files : - repository / components / plugins / io . netty . handler_4 .0.30 . Final . jar - repository / components / plugins / oltu_1 .0.0 . wso2v3 . jar - product_name : wso2esb product_version : 5.0.0 . standard added_files : [] removed_files : [] modified_files : - repository / components / plugins / io . netty . handler_4 .0.30 . Final . jar - product_name : wso2is - km product_version : 5.3.0 . standard added_files : [] removed_files : [] modified_files : - repository / components / plugins / oltu_1 .0.0 . wso2v3 . jar In WUM 2.0.0, we used update-descriptor.yaml . The reason to introduce a new file in WUM 3.0.0 is because WUM 3.0.0 s upports partial updates. For example, in the above sample, the update numbered 2922 gets fully applied to wso2am-2.1.0.standard product while it gets partially applied to wso2am- 2.0.0.standard , wso2esb-5.0.0.standard, and wso2is-km-5.3.0.standard products. You should manually fill in the description, instructions, and the bug_fixes fields of the update-descriptor3.yaml file according to the products listed in it. W hen filling the description and instructions sections of an update that gets fully or partially applied to multiple products, use paragraphs to separate the description per product. Be careful not to break the initial indentation though as that results in a malformed YAML. Given below is an example of a description that has multiple paragraphs: description: | Details about the update for wso2am - 2.1.0 . standard , this paragraph only contains details regarding wso2am - 2.1.0 . standard Details about the update for wso2am - 2.0.0 . standard , this paragraph only contains details regarding wso2am - 2.0.0 . standard Details about the update for wso2esb - 5.0.0 . standard , this paragraph only contains details regarding wso2esb - 5.0.0 . standard Details about the update for wso2is - km - 5.3.0 . standard , this paragraph only contains details regarding wso2is - km - 5.3.0 . standard Here's an example of a malformed YAML. The malformation is caused by YAML treating the entire sentence 'Details about the update for wso2am-2.0.0.standard, this paragraph only contains details regarding wso2am-2.0.0.standard' as a key. The same applies to the instructions field as well. description: | Details about the update for wso2am - 2.1.0 . standard , this paragraph only contains details regarding wso2am - 2.1.0 . standard Details about the update for wso2am - 2.0.0 . standard , this paragraph only contains details regarding wso2am - 2.0.0 . standard If there are no bug fixes, enter N/A in the JIRA_ID and Summary fields. I f there are no instructions, leave a blank line as follows: {width=\"150\"} Note that you do not manually modify the added_files and modified_files sections like in the previous versions of the tool. They are added automatically by the tool. In cases where the version of a JAR file is updated, remove the old JAR file and provide path to the removed file when prompted by the wum-uc tool . {.expand-control-image}update-descriptor.yaml file This file will be discontinued when WUM 2.0.0 gets deprecated. The update-descriptor.yaml file is used to identify update details by WUM 2.0.0. It will get created by the wum-uc tool along with the previous YAML file until wum 2.0.0 gets deprecated. You will be prompted to provide inputs for applies_to, bug_fixes, and description fields. Given below is a sample update-descriptor.yaml file: update_number: 2922 platform_version: 4.4.0 platform_name: wilkes applies_to: wso2das - 3.1.0 bug_fixes: JIRA_ID : Summary description: Details about the update for wso2das - 3.1.0 file_changes: added_files : [] removed_files : - repository / components / plugins / org . wso2 . carbon . governance . lcm_4 .7.0 . jar modified_files : - repository / components / plugins / io . netty . handler_4 .0.30 . Final . jar - repository / components / plugins / oltu_1 .0.0 . wso2v3 . jar If there are no bug fixes, enter N/A in the JIRA_ID and Summary fields. Let's start using the Update Creator tool. Download the tool Set the environment variables Build the tool (optional) Initialize the tool Create an update directly Commit the created ZIP file to SVN Convert old patches to WUM-updates Download the tool Go to the release section of GitHub to download the tool. Set the environment variables If you want to run the tool from anywhere, add it to the system PATH variable. For example, this is the command for Ubuntu: export PATH = $PATH :[ ENTER_PATH_TO_BIN_HERE ] Set the LICENSE_MD5 environment variable: LICENSE_MD5 = 84 d7cad403ae420940cd0f62bec1b520 Build the tool (optional) Follow the steps below if you want to built the tool yourself. Download GO from its official website and install it. You need GO to compile and run this tool. Run the following command to download and install the packages along with their dependencies: go get - u github . com / wso2 / update - creator - tool Open the update-creator-tool/constant/constants.go file of the cloned repository and replace the value of the constant BASE64_ENCODED_CONSUMER_KEY_AND_SECRET with the following: BASE64_ENCODED_CONSUMER_KEY_AND_SECRET = N01ENDRMM21HcVhrOTlXTDM2N19na1lPNTgwYTpVaEQxSzlwbzVDUF9BaExLUFhUS3Bqc0FMbU1h Run build.sh to generate the executable files for various OS/architecture combinations. These files are located in the build/target/ directory. Extract the relevant ZIP file to your OS/architecture. Find the executable wum-uc file in the bin directory. Initialize the tool Run the following command to initialize wum-uc: wum - uc init When prompted, give your WSO2 username and password. Note that the .wum-uc directory is created. Let's call it in this guide. Create an update directly Follow below steps to create an update. Create a directory (let's call this ) and copy the following files that need to be in your update: All updated files (e.g., binary and resource files). The instructions.txt (required only till WUM 2.0 gets depreciated). Note : Do not copy LICENSE.txt and NOT_A_CONTRIBUTION.txt as they get automatically added bythe tool. Run the following command to create the update: wum - uc create update_dir dist_loc // update_dir : the path to UPDATE_LOCATION // dist_loc : path to the latest WUM-updated distribution that you obtained by pointing WUM to the live environment (i.e., url: https://api.updates.wso2.com ) Give the relevant update number when prompted. When prompted, select the relevant platform version that you are creating the update for. Select the platform name and version from following : 1. wilkes 4.4.0 2. hamming 5.0.0 Enter your preference [ 1 / 2 ]: When prompted for removed files: Press 'n' if no files are removed from this update. Press 'y' for adding removed files and enter the path of the removed files relative to . When you are done with adding removed files, press 'Enter' without any inputs. When prompted, confirm that you are done adding inputs by pressing 'y' for yes or 'n' for no. Enter the following when prompted. Note that these are required only until WUM 2.0 gets depreciated. The names of product/s for the 'applies to' field. The JIRA keys and summaries relevant to the update. (Press 'Enter' when you are done). The description for the created update. Note that the update ZIP is created in the location from where you execute wum-uc. The tool displays a summary of the update creation. {.expand-control-image}Click to see an example... Here's an example: update - descriptor . yaml has been successfully created in / home / kasun / Documents / wum - uc / demo . Optional resource file instructions . txt not copied . update - descriptor3 . yaml has been successfully created in / home / kasun / Documents / wum - uc / demo . WSO2 - CARBON - UPDATE - 4.4.0 - 2923. zip successfully created . Your update applies to the following products Compatible products : [ wso2am ] Partially applicable products : [ wso2esb wso2is - km wso2am ] Notify products : [ wso2ei wso2iot ] Manually fill the description , instructions and bug_fixes fields for above products in the update - descriptor3 . yaml located inside the created WSO2 - CARBON - UPDATE - 4.4.0 - 2923. zip As shown in the Notify products field of the above summary, the update can be applied to the products wso2ei and wso2iot as well. However, due to the differences in the directory structures of the above products, it is the responsibility of the developer to create seperate updates for them in the Notify products field. Commit the created ZIP file to SVN Before commiting the file, do a manual inspection of its directory structure and the entries in the update-descriptor3.yaml and update-descriptor.yaml files. For Wilkes, the update repository location is https://svn.wso2.com/wso2/custom/projects/projects/carbon/wilkes/updates . When changing the lifecycle state of the created update from Development to Staging, you see a newly added check as follows. Click it. {width=\"200\"} You get directed to a seperate page as follows: Click GET UPDATE YAML to see the YAML information as follows: {width=\"500\"} Verify the YAML information and click GET PRODUCT LIST to see the product details as follows: {width=\"550\"} Verify the product details and click CONTINUE. You get a page as follows. Update it with the products relevant for your update number. {width=\"600\"} Some samples for the UPDATE_LOCATION directory are shown below: {.expand-control-image}Sample 1 \u251c\u2500\u2500 axis2_1 .6.1 . wso2v16 . jar \u251c\u2500\u2500 instructions . txt \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 synapse - core_2 .1.5 . wso2v2 . jar \u251c\u2500\u2500 update - descriptor3 . yaml \u2514\u2500\u2500 update - descriptor . yaml {.expand-control-image}Sample 2 \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 oauth2 . war \u251c\u2500\u2500 update - descriptor3 . yaml \u2514\u2500\u2500 update - descriptor . yaml {.expand-control-image}Sample 3 \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 org . wso2 . carbon . apimgt . hostobjects_5 .0.3 . jar \u251c\u2500\u2500 store \u2502 \u251c\u2500\u2500 modules \u2502 \u2502 \u2514\u2500\u2500 subscription \u2502 \u2502 \u251c\u2500\u2500 list . jag \u2502 \u2502 \u2514\u2500\u2500 module . jag \u2502 \u2514\u2500\u2500 site \u2502 \u2514\u2500\u2500 blocks \u2502 \u2514\u2500\u2500 subscription \u2502 \u2514\u2500\u2500 subscription - list \u2502 \u251c\u2500\u2500 ajax \u2502 \u2502 \u2514\u2500\u2500 subscription - list . jag \u2502 \u2514\u2500\u2500 block . jag \u251c\u2500\u2500 update - descriptor3 . yaml \u2514\u2500\u2500 update - descriptor . yaml {.expand-control-image}Sample 4 \u251c\u2500\u2500 bin \u2502 \u2514\u2500\u2500 tomcat - juli - 7.0.69 . jar \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 endorsed \u2502 \u2514\u2500\u2500 tomcat - annotations - api - 7.0.69 . jar \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 org . wso2 . carbon . tomcat_4 .4.3 . jar \u251c\u2500\u2500 tomcat_7 .0.59 . wso2v3 . jar \u251c\u2500\u2500 tomcat - catalina - ha_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - el - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - jsp - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - servlet - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 update - descriptor3 . yaml \u2514\u2500\u2500 update - descriptor . yaml Convert old patches to WUM-updates Sample 1: Basic scenario Sample 2: Update with resource files Sample 3: When the patch has config changes Sample 1: Basic scenario Let's convert the WSO2-CARBON-PATCH-4.4.0\u20130001.zip to the WUM update format. Extract the WSO2-CARBON-PATCH-4.4.0\u20130001.zip . We call this location PatchDir . Note that the structure of the is as follows: PatchDir \u2514\u2500\u2500 WSO2 - CARBON - PATCH - 4.4.0 \u2013 0001 \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 patch0001 \u2502 \u2514\u2500\u2500 hazelcast_3 .5.0 . wso2v1 . jar \u251c\u2500\u2500 README . txt \u2514\u2500\u2500 wso2carbon - version . txt All the file changes are in PatchDir /WSO2-CARBON-PATCH-4.4.0\u20130001/patch0001 . Copy the content of the patch0001 directory to WSO2-CARBON-PATCH-4.4.0\u20130001 directory (parent directory of patch0001 directory) and delete patch0001 directory. Delete wso2carbon-version.txt, LICENSE.txt, and NOT_A_CONTRIBUTION.txt files from the above directory. Note that the new directory structure looks as follows: \u2500\u2500 WSO2 - CARBON - PATCH - 4.4.0 \u2013 0001 \u251c\u2500\u2500 hazelcast_3 .5.0 . wso2v1 . jar \u251c\u2500\u2500 README . txt Follow the update creation process mentioned above to create the update. Note that if successful, the c reated WSO2-CARBON-UPDATE-4.4.0\u20130001.zip should be located at the current working directory. You can validate this using the wum-uc validate command. Sample 2: Update with resource files Follow the steps below to convert WSO2-CARBON-PATCH-4.4.0\u20130237.zip to WUM update format. Extract the WSO2-CARBON-PATCH-4.4.0\u20130237.zip file. We call this location . Note that the structure of the is as follows. Read the README.txt for more information about the patch. WSO2 - CARBON - PATCH - 4.4.0 - 0237 \u251c\u2500\u2500 bin \u2502 \u2514\u2500\u2500 tomcat - juli - 7.0.69 . jar \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 endorsed \u2502 \u2514\u2500\u2500 tomcat - annotations - api - 7.0.69 . jar \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 patch0237 \u2502 \u251c\u2500\u2500 org . wso2 . carbon . tomcat_4 .4.1 . jar \u2502 \u251c\u2500\u2500 tomcat_7 .0.59 . wso2v3 . jar \u2502 \u251c\u2500\u2500 tomcat - catalina - ha_7 .0.59 . wso2v1 . jar \u2502 \u251c\u2500\u2500 tomcat - el - api_7 .0.59 . wso2v1 . jar \u2502 \u251c\u2500\u2500 tomcat - jsp - api_7 .0.59 . wso2v1 . jar \u2502 \u2514\u2500\u2500 tomcat - servlet - api_7 .0.59 . wso2v1 . jar \u2514\u2500\u2500 README . txt Move the content of the patch0237 directory to the WSO2-CARBON-PATCH-4.4.0\u20130237 directory and delete patch0237 . Delete the LICENSE.txt file from the WSO2-CARBON-PATCH-4.4.0\u20130237 directory. Note that the new directory structure should as follows: WSO2 - CARBON - PATCH - 4.4.0 - 0237 \u251c\u2500\u2500 bin \u2502 \u2514\u2500\u2500 tomcat - juli - 7.0.69 . jar \u251c\u2500\u2500 instructions . txt \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 endorsed \u2502 \u2514\u2500\u2500 tomcat - annotations - api - 7.0.69 . jar \u251c\u2500\u2500 org . wso2 . carbon . tomcat_4 .4.1 . jar \u251c\u2500\u2500 README . txt \u251c\u2500\u2500 tomcat_7 .0.59 . wso2v3 . jar \u251c\u2500\u2500 tomcat - catalina - ha_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - el - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - jsp - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - servlet - api_7 .0.59 . wso2v1 . jar Follow the update creation process mentioned above to create the update. Note that, if successful, the WSO2-CARBON-UPDATE-4.4.0\u20130237.zip file will be created in the current working directory. You can validate it using the wum-uc validate command. Sample 3: When the patch has config changes Follow the steps below to convert the WSO2-CARBON-PATCH-4.4.0\u20130478.zip file to new WUM update format when the patch has configuration changes. Extract the patch and move the content of the patch0478 directory to the parent directory. WSO2 - CARBON - PATCH - 4.4.0 - 047 8 \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 README . txt \u251c\u2500\u2500 synapse - core_2 .1.5 . wso2v2 . jar \u2514\u2500\u2500 update - descriptor . yaml Note in the README.txt that there are configuration changes added in this patch. You need to add these instructions in an instructions.txt file until WUM 2.0 gets officially deprecated. After it is deprecated, same content above should be added to the instructions field of the new update-descriptor3.yaml file after successfully creating the update. {.expand-control-image}Expand to see a sample instructions.txt file... When the org . wso2 . carbon . identity . mgt . IdentityMgtEventListener is enabled via EventListeners configuration in repository / conf / identity / identity . xml , it engages CacheClearingUserOperationListener which clears the policy cache . This should be configurable through EventListeners configuration . This step is optional , and is only required if you need to disable the immediate cache invalidation . Copy following xml content into identity . xml as the very first element under the EventListeners element . EventListener type = org.wso2.carbon.user.core.listener.UserOperationEventListener name = org.wso2.carbon.identity.entitlement.listener.CacheClearingUserOperationListener orderId = 6 enable = false / Note that the new directory structure looks as follows: WSO2 - CARBON - PATCH - 4.4.0 - 047 8 \u251c\u2500\u2500 instructions . txt \u251c\u2500\u2500 README . txt \u2514\u2500\u2500 synapse - core_2 .1.5 . wso2v2 . jar Follow the update creation process mentioned above to create the update. Note that, if successful, the WSO2-CARBON-UPDATE-4.4.0\u20130478.zip file will be created in the current working directory. You can validated it using the wum-uc validate command. Attachments: {width=\"8\" height=\"8\"} overview-products.png (image/png) {width=\"8\" height=\"8\"} Product-details.png (image/png) {width=\"8\" height=\"8\"} get-updated-YAML.png (image/png) {width=\"8\" height=\"8\"} YAML-description.png (image/png) {width=\"8\" height=\"8\"} blank-line.png (image/png) {width=\"8\" height=\"8\"} image2018-8-10_17-37-18.png (image/png)","title":"Develop"},{"location":"Developer_Guide/#developer-guide","text":"The WSO2 Update TESTING Creator tool (wum-uc) is designed to help you create and validate updates that are compatible with WUM. It is written in GO language. As a result, you can compile the code directly to machine code without using the JVM. Cross compiling is also possible. This document describes how to use the Update Creator tool to create an update directly or convert a patch to an update. Before you begin, here are the descriptions of the files used in this guide. The wum-uc tool generates both these files. {.expand-control-image}update-descriptor3.yaml file This is a newly introduced file that contains details about the update that complies with WUM 3.0.0 . Every update has an update-descriptor3.yaml file. It has details about the products that this update is fully or partially compatible with, the file changes (added, removed, or modified), descriptions, and instructions. A sample file looks like the following: update_number: 2922 platform_version: 4.4.0 platform_name: wilkes md5sum: 8f6e83731d c1da6634c6d24c92606d06 description: | Details about the update for wso2am - 2.1.0 . standard Details about the update for wso2am - 2.0.0 . standard Details about the update for wso2esb - 5.0.0 . standard Details about the update for wso2is - km - 5.3.0 . standard instructions: | Instructions for wso2am - 2.1.0 . standard Instructions for wso2am - 2.0.0 . standard Instructions for wso2esb - 5.0.0 . standard Instructions for wso2is - km - 5.3.0 . standard bug_fixes: JIRA_ID : Summary compatible_products: - product_name : wso2am product_version : 2.1.0 . standard added_files : [] removed_files : - repository / components / plugins / org . wso2 . carbon . governance . lcm_4 .7.0 . jar modified_files : - repository / components / plugins / io . netty . handler_4 .0.30 . Final . jar - repository / components / plugins / oltu_1 .0.0 . wso2v3 . jar partially_applicable_products: - product_name : wso2am product_version : 2.0.0 . standard added_files : [] removed_files : [] modified_files : - repository / components / plugins / io . netty . handler_4 .0.30 . Final . jar - repository / components / plugins / oltu_1 .0.0 . wso2v3 . jar - product_name : wso2esb product_version : 5.0.0 . standard added_files : [] removed_files : [] modified_files : - repository / components / plugins / io . netty . handler_4 .0.30 . Final . jar - product_name : wso2is - km product_version : 5.3.0 . standard added_files : [] removed_files : [] modified_files : - repository / components / plugins / oltu_1 .0.0 . wso2v3 . jar In WUM 2.0.0, we used update-descriptor.yaml . The reason to introduce a new file in WUM 3.0.0 is because WUM 3.0.0 s upports partial updates. For example, in the above sample, the update numbered 2922 gets fully applied to wso2am-2.1.0.standard product while it gets partially applied to wso2am- 2.0.0.standard , wso2esb-5.0.0.standard, and wso2is-km-5.3.0.standard products. You should manually fill in the description, instructions, and the bug_fixes fields of the update-descriptor3.yaml file according to the products listed in it. W hen filling the description and instructions sections of an update that gets fully or partially applied to multiple products, use paragraphs to separate the description per product. Be careful not to break the initial indentation though as that results in a malformed YAML. Given below is an example of a description that has multiple paragraphs: description: | Details about the update for wso2am - 2.1.0 . standard , this paragraph only contains details regarding wso2am - 2.1.0 . standard Details about the update for wso2am - 2.0.0 . standard , this paragraph only contains details regarding wso2am - 2.0.0 . standard Details about the update for wso2esb - 5.0.0 . standard , this paragraph only contains details regarding wso2esb - 5.0.0 . standard Details about the update for wso2is - km - 5.3.0 . standard , this paragraph only contains details regarding wso2is - km - 5.3.0 . standard Here's an example of a malformed YAML. The malformation is caused by YAML treating the entire sentence 'Details about the update for wso2am-2.0.0.standard, this paragraph only contains details regarding wso2am-2.0.0.standard' as a key. The same applies to the instructions field as well. description: | Details about the update for wso2am - 2.1.0 . standard , this paragraph only contains details regarding wso2am - 2.1.0 . standard Details about the update for wso2am - 2.0.0 . standard , this paragraph only contains details regarding wso2am - 2.0.0 . standard If there are no bug fixes, enter N/A in the JIRA_ID and Summary fields. I f there are no instructions, leave a blank line as follows: {width=\"150\"} Note that you do not manually modify the added_files and modified_files sections like in the previous versions of the tool. They are added automatically by the tool. In cases where the version of a JAR file is updated, remove the old JAR file and provide path to the removed file when prompted by the wum-uc tool . {.expand-control-image}update-descriptor.yaml file This file will be discontinued when WUM 2.0.0 gets deprecated. The update-descriptor.yaml file is used to identify update details by WUM 2.0.0. It will get created by the wum-uc tool along with the previous YAML file until wum 2.0.0 gets deprecated. You will be prompted to provide inputs for applies_to, bug_fixes, and description fields. Given below is a sample update-descriptor.yaml file: update_number: 2922 platform_version: 4.4.0 platform_name: wilkes applies_to: wso2das - 3.1.0 bug_fixes: JIRA_ID : Summary description: Details about the update for wso2das - 3.1.0 file_changes: added_files : [] removed_files : - repository / components / plugins / org . wso2 . carbon . governance . lcm_4 .7.0 . jar modified_files : - repository / components / plugins / io . netty . handler_4 .0.30 . Final . jar - repository / components / plugins / oltu_1 .0.0 . wso2v3 . jar If there are no bug fixes, enter N/A in the JIRA_ID and Summary fields. Let's start using the Update Creator tool. Download the tool Set the environment variables Build the tool (optional) Initialize the tool Create an update directly Commit the created ZIP file to SVN Convert old patches to WUM-updates","title":"Developer Guide"},{"location":"Developer_Guide/#download-the-tool","text":"Go to the release section of GitHub to download the tool.","title":"Download the tool"},{"location":"Developer_Guide/#set-the-environment-variables","text":"If you want to run the tool from anywhere, add it to the system PATH variable. For example, this is the command for Ubuntu: export PATH = $PATH :[ ENTER_PATH_TO_BIN_HERE ] Set the LICENSE_MD5 environment variable: LICENSE_MD5 = 84 d7cad403ae420940cd0f62bec1b520","title":"Set the environment variables"},{"location":"Developer_Guide/#build-the-tool-optional","text":"Follow the steps below if you want to built the tool yourself. Download GO from its official website and install it. You need GO to compile and run this tool. Run the following command to download and install the packages along with their dependencies: go get - u github . com / wso2 / update - creator - tool Open the update-creator-tool/constant/constants.go file of the cloned repository and replace the value of the constant BASE64_ENCODED_CONSUMER_KEY_AND_SECRET with the following: BASE64_ENCODED_CONSUMER_KEY_AND_SECRET = N01ENDRMM21HcVhrOTlXTDM2N19na1lPNTgwYTpVaEQxSzlwbzVDUF9BaExLUFhUS3Bqc0FMbU1h Run build.sh to generate the executable files for various OS/architecture combinations. These files are located in the build/target/ directory. Extract the relevant ZIP file to your OS/architecture. Find the executable wum-uc file in the bin directory.","title":"Build the tool (optional)"},{"location":"Developer_Guide/#initialize-the-tool","text":"Run the following command to initialize wum-uc: wum - uc init When prompted, give your WSO2 username and password. Note that the .wum-uc directory is created. Let's call it in this guide.","title":"Initialize the tool"},{"location":"Developer_Guide/#create-an-update-directly","text":"Follow below steps to create an update. Create a directory (let's call this ) and copy the following files that need to be in your update: All updated files (e.g., binary and resource files). The instructions.txt (required only till WUM 2.0 gets depreciated). Note : Do not copy LICENSE.txt and NOT_A_CONTRIBUTION.txt as they get automatically added bythe tool. Run the following command to create the update: wum - uc create update_dir dist_loc // update_dir : the path to UPDATE_LOCATION // dist_loc : path to the latest WUM-updated distribution that you obtained by pointing WUM to the live environment (i.e., url: https://api.updates.wso2.com ) Give the relevant update number when prompted. When prompted, select the relevant platform version that you are creating the update for. Select the platform name and version from following : 1. wilkes 4.4.0 2. hamming 5.0.0 Enter your preference [ 1 / 2 ]: When prompted for removed files: Press 'n' if no files are removed from this update. Press 'y' for adding removed files and enter the path of the removed files relative to . When you are done with adding removed files, press 'Enter' without any inputs. When prompted, confirm that you are done adding inputs by pressing 'y' for yes or 'n' for no. Enter the following when prompted. Note that these are required only until WUM 2.0 gets depreciated. The names of product/s for the 'applies to' field. The JIRA keys and summaries relevant to the update. (Press 'Enter' when you are done). The description for the created update. Note that the update ZIP is created in the location from where you execute wum-uc. The tool displays a summary of the update creation. {.expand-control-image}Click to see an example... Here's an example: update - descriptor . yaml has been successfully created in / home / kasun / Documents / wum - uc / demo . Optional resource file instructions . txt not copied . update - descriptor3 . yaml has been successfully created in / home / kasun / Documents / wum - uc / demo . WSO2 - CARBON - UPDATE - 4.4.0 - 2923. zip successfully created . Your update applies to the following products Compatible products : [ wso2am ] Partially applicable products : [ wso2esb wso2is - km wso2am ] Notify products : [ wso2ei wso2iot ] Manually fill the description , instructions and bug_fixes fields for above products in the update - descriptor3 . yaml located inside the created WSO2 - CARBON - UPDATE - 4.4.0 - 2923. zip As shown in the Notify products field of the above summary, the update can be applied to the products wso2ei and wso2iot as well. However, due to the differences in the directory structures of the above products, it is the responsibility of the developer to create seperate updates for them in the Notify products field.","title":"Create an update directly"},{"location":"Developer_Guide/#commit-the-created-zip-file-to-svn","text":"Before commiting the file, do a manual inspection of its directory structure and the entries in the update-descriptor3.yaml and update-descriptor.yaml files. For Wilkes, the update repository location is https://svn.wso2.com/wso2/custom/projects/projects/carbon/wilkes/updates . When changing the lifecycle state of the created update from Development to Staging, you see a newly added check as follows. Click it. {width=\"200\"} You get directed to a seperate page as follows: Click GET UPDATE YAML to see the YAML information as follows: {width=\"500\"} Verify the YAML information and click GET PRODUCT LIST to see the product details as follows: {width=\"550\"} Verify the product details and click CONTINUE. You get a page as follows. Update it with the products relevant for your update number. {width=\"600\"} Some samples for the UPDATE_LOCATION directory are shown below: {.expand-control-image}Sample 1 \u251c\u2500\u2500 axis2_1 .6.1 . wso2v16 . jar \u251c\u2500\u2500 instructions . txt \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 synapse - core_2 .1.5 . wso2v2 . jar \u251c\u2500\u2500 update - descriptor3 . yaml \u2514\u2500\u2500 update - descriptor . yaml {.expand-control-image}Sample 2 \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 oauth2 . war \u251c\u2500\u2500 update - descriptor3 . yaml \u2514\u2500\u2500 update - descriptor . yaml {.expand-control-image}Sample 3 \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 org . wso2 . carbon . apimgt . hostobjects_5 .0.3 . jar \u251c\u2500\u2500 store \u2502 \u251c\u2500\u2500 modules \u2502 \u2502 \u2514\u2500\u2500 subscription \u2502 \u2502 \u251c\u2500\u2500 list . jag \u2502 \u2502 \u2514\u2500\u2500 module . jag \u2502 \u2514\u2500\u2500 site \u2502 \u2514\u2500\u2500 blocks \u2502 \u2514\u2500\u2500 subscription \u2502 \u2514\u2500\u2500 subscription - list \u2502 \u251c\u2500\u2500 ajax \u2502 \u2502 \u2514\u2500\u2500 subscription - list . jag \u2502 \u2514\u2500\u2500 block . jag \u251c\u2500\u2500 update - descriptor3 . yaml \u2514\u2500\u2500 update - descriptor . yaml {.expand-control-image}Sample 4 \u251c\u2500\u2500 bin \u2502 \u2514\u2500\u2500 tomcat - juli - 7.0.69 . jar \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 endorsed \u2502 \u2514\u2500\u2500 tomcat - annotations - api - 7.0.69 . jar \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 org . wso2 . carbon . tomcat_4 .4.3 . jar \u251c\u2500\u2500 tomcat_7 .0.59 . wso2v3 . jar \u251c\u2500\u2500 tomcat - catalina - ha_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - el - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - jsp - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - servlet - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 update - descriptor3 . yaml \u2514\u2500\u2500 update - descriptor . yaml","title":"Commit the created ZIP file to SVN"},{"location":"Developer_Guide/#convert-old-patches-to-wum-updates","text":"Sample 1: Basic scenario Sample 2: Update with resource files Sample 3: When the patch has config changes","title":"Convert old patches to WUM-updates"},{"location":"Developer_Guide/#sample-1-basic-scenario","text":"Let's convert the WSO2-CARBON-PATCH-4.4.0\u20130001.zip to the WUM update format. Extract the WSO2-CARBON-PATCH-4.4.0\u20130001.zip . We call this location PatchDir . Note that the structure of the is as follows: PatchDir \u2514\u2500\u2500 WSO2 - CARBON - PATCH - 4.4.0 \u2013 0001 \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 patch0001 \u2502 \u2514\u2500\u2500 hazelcast_3 .5.0 . wso2v1 . jar \u251c\u2500\u2500 README . txt \u2514\u2500\u2500 wso2carbon - version . txt All the file changes are in PatchDir /WSO2-CARBON-PATCH-4.4.0\u20130001/patch0001 . Copy the content of the patch0001 directory to WSO2-CARBON-PATCH-4.4.0\u20130001 directory (parent directory of patch0001 directory) and delete patch0001 directory. Delete wso2carbon-version.txt, LICENSE.txt, and NOT_A_CONTRIBUTION.txt files from the above directory. Note that the new directory structure looks as follows: \u2500\u2500 WSO2 - CARBON - PATCH - 4.4.0 \u2013 0001 \u251c\u2500\u2500 hazelcast_3 .5.0 . wso2v1 . jar \u251c\u2500\u2500 README . txt Follow the update creation process mentioned above to create the update. Note that if successful, the c reated WSO2-CARBON-UPDATE-4.4.0\u20130001.zip should be located at the current working directory. You can validate this using the wum-uc validate command.","title":"Sample 1: Basic scenario"},{"location":"Developer_Guide/#sample-2-update-with-resource-files","text":"Follow the steps below to convert WSO2-CARBON-PATCH-4.4.0\u20130237.zip to WUM update format. Extract the WSO2-CARBON-PATCH-4.4.0\u20130237.zip file. We call this location . Note that the structure of the is as follows. Read the README.txt for more information about the patch. WSO2 - CARBON - PATCH - 4.4.0 - 0237 \u251c\u2500\u2500 bin \u2502 \u2514\u2500\u2500 tomcat - juli - 7.0.69 . jar \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 endorsed \u2502 \u2514\u2500\u2500 tomcat - annotations - api - 7.0.69 . jar \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 patch0237 \u2502 \u251c\u2500\u2500 org . wso2 . carbon . tomcat_4 .4.1 . jar \u2502 \u251c\u2500\u2500 tomcat_7 .0.59 . wso2v3 . jar \u2502 \u251c\u2500\u2500 tomcat - catalina - ha_7 .0.59 . wso2v1 . jar \u2502 \u251c\u2500\u2500 tomcat - el - api_7 .0.59 . wso2v1 . jar \u2502 \u251c\u2500\u2500 tomcat - jsp - api_7 .0.59 . wso2v1 . jar \u2502 \u2514\u2500\u2500 tomcat - servlet - api_7 .0.59 . wso2v1 . jar \u2514\u2500\u2500 README . txt Move the content of the patch0237 directory to the WSO2-CARBON-PATCH-4.4.0\u20130237 directory and delete patch0237 . Delete the LICENSE.txt file from the WSO2-CARBON-PATCH-4.4.0\u20130237 directory. Note that the new directory structure should as follows: WSO2 - CARBON - PATCH - 4.4.0 - 0237 \u251c\u2500\u2500 bin \u2502 \u2514\u2500\u2500 tomcat - juli - 7.0.69 . jar \u251c\u2500\u2500 instructions . txt \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 endorsed \u2502 \u2514\u2500\u2500 tomcat - annotations - api - 7.0.69 . jar \u251c\u2500\u2500 org . wso2 . carbon . tomcat_4 .4.1 . jar \u251c\u2500\u2500 README . txt \u251c\u2500\u2500 tomcat_7 .0.59 . wso2v3 . jar \u251c\u2500\u2500 tomcat - catalina - ha_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - el - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - jsp - api_7 .0.59 . wso2v1 . jar \u251c\u2500\u2500 tomcat - servlet - api_7 .0.59 . wso2v1 . jar Follow the update creation process mentioned above to create the update. Note that, if successful, the WSO2-CARBON-UPDATE-4.4.0\u20130237.zip file will be created in the current working directory. You can validate it using the wum-uc validate command.","title":"Sample 2: Update with resource files"},{"location":"Developer_Guide/#sample-3-when-the-patch-has-config-changes","text":"Follow the steps below to convert the WSO2-CARBON-PATCH-4.4.0\u20130478.zip file to new WUM update format when the patch has configuration changes. Extract the patch and move the content of the patch0478 directory to the parent directory. WSO2 - CARBON - PATCH - 4.4.0 - 047 8 \u251c\u2500\u2500 LICENSE . txt \u251c\u2500\u2500 NOT_A_CONTRIBUTION . txt \u251c\u2500\u2500 README . txt \u251c\u2500\u2500 synapse - core_2 .1.5 . wso2v2 . jar \u2514\u2500\u2500 update - descriptor . yaml Note in the README.txt that there are configuration changes added in this patch. You need to add these instructions in an instructions.txt file until WUM 2.0 gets officially deprecated. After it is deprecated, same content above should be added to the instructions field of the new update-descriptor3.yaml file after successfully creating the update. {.expand-control-image}Expand to see a sample instructions.txt file... When the org . wso2 . carbon . identity . mgt . IdentityMgtEventListener is enabled via EventListeners configuration in repository / conf / identity / identity . xml , it engages CacheClearingUserOperationListener which clears the policy cache . This should be configurable through EventListeners configuration . This step is optional , and is only required if you need to disable the immediate cache invalidation . Copy following xml content into identity . xml as the very first element under the EventListeners element . EventListener type = org.wso2.carbon.user.core.listener.UserOperationEventListener name = org.wso2.carbon.identity.entitlement.listener.CacheClearingUserOperationListener orderId = 6 enable = false / Note that the new directory structure looks as follows: WSO2 - CARBON - PATCH - 4.4.0 - 047 8 \u251c\u2500\u2500 instructions . txt \u251c\u2500\u2500 README . txt \u2514\u2500\u2500 synapse - core_2 .1.5 . wso2v2 . jar Follow the update creation process mentioned above to create the update. Note that, if successful, the WSO2-CARBON-UPDATE-4.4.0\u20130478.zip file will be created in the current working directory. You can validated it using the wum-uc validate command.","title":"Sample 3: When the patch has config changes"},{"location":"Developer_Guide/#attachments","text":"{width=\"8\" height=\"8\"} overview-products.png (image/png) {width=\"8\" height=\"8\"} Product-details.png (image/png) {width=\"8\" height=\"8\"} get-updated-YAML.png (image/png) {width=\"8\" height=\"8\"} YAML-description.png (image/png) {width=\"8\" height=\"8\"} blank-line.png (image/png) {width=\"8\" height=\"8\"} image2018-8-10_17-37-18.png (image/png)","title":"Attachments:"},{"location":"FAQ/","text":"FAQ Can I use updates without a paid subscription? What benefits do I get from a paid subscription? Do I need a key to unlock updates for production? Can I choose which updates to install? What license are WSO2 updates on? How frequently is it recommended to get updates? Should I test my updates? How do I know when updates are available? What can I do in case of an issue? How can I know what changes are included in an update? I get an error as 'You do not have an active subscription or the channel does not exist'. What should I do? I get the error as 'invalid credentials. Please enter valid WSO2 credentials'. What should I do? Can I use updates without a paid subscription? You can use the free trial subscription for 15 days. After that, you need a paid subscription . Find out more about the EULA license. What benefits do I get from a paid subscription? A paid subscription allows you to: Deploy updates into production immediately, without waiting for an open source release. Receive 24x7 support from WSO2 to resolve issues quickly. Help fund our ongoing R D and operations. Read more about WSO2 support and subscriptions . Do I need a key to unlock updates for production? No. We trust our customers to adhere to the license terms. We make the terms clear to avoid accidental violations and reserve the right to remove access to updates or take other means to enforce the license against intentional violators. Find out more about the EULA license. Can I choose which updates to install? Yes, but only via a custom channel. You cannot choose the updates you want to install via the default channels (i.e., full and security). You can choose when to push a (coherent) set of updates into production. WSO2 tests and certifies each update on systems where all previous updates are installed. It is not practical to test every arbitrary combination of updates. Therefore, we cannot recommend you to choose which updates to install unless you have a custom channel. What license are WSO2 updates on? We are releasing WSO2 updates with a commercial EULA license . How frequently is it recommended to get updates? WSO2 releases frequent WUM updates with bug fixes and security fixes. It is recommended to get these updates to your development environments weekly or bi-weekly . When it comes to production environments, if there are urgent security fixes, WSO2 will announce them to customers via support JIRAs. In addition, WSO2 announces all security updates, if any, to the customers monthly. It is recommended to update your production environments monthly . Should I test my updates? WSO2 tests all updates in systems where all previous updates are also installed. But, it is not recommended to install your updates directly to a production environment. First, install them to a development, staging, or testing environment that has the same product distribution that runs on your production environment and test the updates. How do I know when updates are available? Available updates, if any, will be shown when you run the in-place update tool. If you are using the WUM tool, run the wum check-update command. What can I do in case of an issue? If you encounter any issues when using WSO2 updates, log a support JIRA ticket . If you have a free-trial subscrition but do not have a support account at WSO2, you can report the issues by contacting WSO2 via https://wso2.com/contact . How can I know what changes are included in an update? You receive an email with information on all the changes included in the new distribution. You also find this information in PRODUCT_HOME /updates/summary as a PDF file. I get an error as 'You do not have an active subscription or the channel does not exist'. What should I do? First, check whether you typed the channel name correctly. If yes, then you should have got your WSO2 subscription via that given channel name. If you haven't, please contact WSO2. I get the error as 'invalid credentials. Please enter valid WSO2 credentials'. What should I do? First, check whether you have given the right credentials. If yes, check whether your password has the $ sign. If it does, escape it using '\\'. For example, if your password is 123 abc, you should enter 123\\\\ abc, you should enter 123\\\\ abc. This is because the $ sign is used for variables in BASH.","title":"FAQ"},{"location":"FAQ/#faq","text":"Can I use updates without a paid subscription? What benefits do I get from a paid subscription? Do I need a key to unlock updates for production? Can I choose which updates to install? What license are WSO2 updates on? How frequently is it recommended to get updates? Should I test my updates? How do I know when updates are available? What can I do in case of an issue? How can I know what changes are included in an update? I get an error as 'You do not have an active subscription or the channel does not exist'. What should I do? I get the error as 'invalid credentials. Please enter valid WSO2 credentials'. What should I do?","title":"FAQ"},{"location":"FAQ/#can-i-use-updates-without-a-paid-subscription","text":"You can use the free trial subscription for 15 days. After that, you need a paid subscription . Find out more about the EULA license.","title":"Can I use updates without a paid subscription?"},{"location":"FAQ/#what-benefits-do-i-get-from-a-paid-subscription","text":"A paid subscription allows you to: Deploy updates into production immediately, without waiting for an open source release. Receive 24x7 support from WSO2 to resolve issues quickly. Help fund our ongoing R D and operations. Read more about WSO2 support and subscriptions .","title":"What benefits do I get from a paid subscription?"},{"location":"FAQ/#do-i-need-a-key-to-unlock-updates-for-production","text":"No. We trust our customers to adhere to the license terms. We make the terms clear to avoid accidental violations and reserve the right to remove access to updates or take other means to enforce the license against intentional violators. Find out more about the EULA license.","title":"Do I need a key to unlock updates for production?"},{"location":"FAQ/#can-i-choose-which-updates-to-install","text":"Yes, but only via a custom channel. You cannot choose the updates you want to install via the default channels (i.e., full and security). You can choose when to push a (coherent) set of updates into production. WSO2 tests and certifies each update on systems where all previous updates are installed. It is not practical to test every arbitrary combination of updates. Therefore, we cannot recommend you to choose which updates to install unless you have a custom channel.","title":"Can I choose which updates to install?"},{"location":"FAQ/#what-license-are-wso2-updates-on","text":"We are releasing WSO2 updates with a commercial EULA license .","title":"What license are WSO2 updates on?"},{"location":"FAQ/#how-frequently-is-it-recommended-to-get-updates","text":"WSO2 releases frequent WUM updates with bug fixes and security fixes. It is recommended to get these updates to your development environments weekly or bi-weekly . When it comes to production environments, if there are urgent security fixes, WSO2 will announce them to customers via support JIRAs. In addition, WSO2 announces all security updates, if any, to the customers monthly. It is recommended to update your production environments monthly .","title":"How frequently is it recommended to get updates?"},{"location":"FAQ/#should-i-test-my-updates","text":"WSO2 tests all updates in systems where all previous updates are also installed. But, it is not recommended to install your updates directly to a production environment. First, install them to a development, staging, or testing environment that has the same product distribution that runs on your production environment and test the updates.","title":"Should I test my updates?"},{"location":"FAQ/#how-do-i-know-when-updates-are-available","text":"Available updates, if any, will be shown when you run the in-place update tool. If you are using the WUM tool, run the wum check-update command.","title":"How do I know when updates are available?"},{"location":"FAQ/#what-can-i-do-in-case-of-an-issue","text":"If you encounter any issues when using WSO2 updates, log a support JIRA ticket . If you have a free-trial subscrition but do not have a support account at WSO2, you can report the issues by contacting WSO2 via https://wso2.com/contact .","title":"What can I do in case of an issue?"},{"location":"FAQ/#how-can-i-know-what-changes-are-included-in-an-update","text":"You receive an email with information on all the changes included in the new distribution. You also find this information in PRODUCT_HOME /updates/summary as a PDF file.","title":"How can I know what changes are included in an update?"},{"location":"FAQ/#i-get-an-error-as-you-do-not-have-an-active-subscription-or-the-channel-does-not-exist-what-should-i-do","text":"First, check whether you typed the channel name correctly. If yes, then you should have got your WSO2 subscription via that given channel name. If you haven't, please contact WSO2.","title":"I get an error as 'You\u00a0do not have an active subscription or the channel does not exist'. What should I do?"},{"location":"FAQ/#i-get-the-error-as-invalid-credentials-please-enter-valid-wso2-credentials-what-should-i-do","text":"First, check whether you have given the right credentials. If yes, check whether your password has the $ sign. If it does, escape it using '\\'. For example, if your password is 123 abc, you should enter 123\\\\ abc, you should enter 123\\\\ abc. This is because the $ sign is used for variables in BASH.","title":"I get the error as 'invalid credentials. Please enter valid WSO2 credentials'. What should I do?"},{"location":"Getting_Continuous_Updates/","text":"Getting Continuous Updates If you are an existing WUM user , do the following to update your products. If not, see Getting Started with WUM . In these steps, you move updates to production by extracting the updates into a ZIP file, testing the updates, and then manually merging them to the existing product distribution. You do not replace the existing production setup with the WUM-updated setup. Before you begin, do you have a proxy server/firewall? Then, grant access to the endpoints mentioned below. Click for more information WUM gets updates by connecting to the https://api.updates.wso2.com and https://cdn.updates.wso2.com endpoints in the WSO2 Update service. If your system connects to the Update service through a proxy server/firewall, grant access to these endpoints. Since WUM is a command-line tool, the proxy should be configured from your command-line as follows: export http_proxy = http : //username:password@proxyhost:port/ If you are behind an NTLM proxy, you can use a third party tool like CNTLM to do the NTLM proxy authentication. See the CNTLM documentation for instructions. Run the following commands to check whether there are updates available: wum check - update product E . g ., wum check - update wso2am - 2.5.0 If an update is available, run the following command to start updating your product: wum update product E . g ., wum update wso2am - 2.5.0 Your local product repository should now contain the latest and the previous WUM-updated distributions. Let's extract the updates in the latest WUM-updated distribution to a ZIP file. Execute the following command to identify the previous WUM-updated pack for this product. wum list [ product - name ] E . g ., wum list wso2am Execute the following command: wum diff Latest - WUM - updated - distribution . zip Previous - WUM - updated - distribution . zip Note Note that the diff ZIP is created in the location from where you executed the diff command. Next, let's apply the WUM updates that you extracted to the ZIP file to the distribution pack that is currently running in your environment. Open the summary PDF that you get inside this ZIP file (also via email). It contains information about the: New configurations introduced with the update. Existing files/artifacts that are affected due to the update. If you do not have any customizations in the existing distribution, simply copy the changed configuration files mentioned in the ZIP to the corresponding directories in your product distribution. If you **have **customizations in the existing distribution, there might be conflicts between that and the WUM-updated distribution. {.expand-control-image}Click to read how to resolve conflicts... A conflict happens when a customized configuration file or artifact has changed in the WUM updates. As the file/artifact has your customizations in it, it is not recommended to completely replace this file with the file that comes with the update. Given below is how to resolve conflicts manually in different types of files/artifacts: File Type How to Merge the Conflicts Binary files Copy all the binary files (.jar, .jks, .car, .war) to the relevant directories in your existing product distribution. If you have made any customizations to .car and .war files, manually merge those changes. Note: If there are .war files in the WUM update, be sure to delete all extracted .war files in your existing product distribution. This is because all deployed .war files get extracted at the server startup and if there are already extracted .war files by that same name, the server will not extract the .war files in the WUM update. Jaggery files You cannot replace the Jaggery artifacts in your existing product distribution with the WUM-updated Jaggery artifacts because your existing Jaggery artifacts may contain customizations. Here's how to merge the files: Check the summary PDF to identify how the Jaggery files have changed because of the WUM updates. Apply the changes to the same files in your existing product distribution. Apply the updated configuration files Identify the configuration updates in the summary PDF and apply them (by merging) to the relevant configuration files in the /repository/conf folder of your existing product distribution. Note: Be sure to merge the configuration files in your environment with the new files. It is not recommended to replace them. Redundant files If there are artifacts/files that are removed by the WUM updates, remove them from your existing product distribution. Newly added files If there are newly added files listed in the PDF, create the same folder structure (if it doesn't exist) in your existing product distribution and add the file. Do you have additional WSO2 features installed in your product distribution? If so, {.expand-control-image}Click to read on... Please note that WSO2 does not recommend installing new features to standard products. If you already have features installed, you need to install the same features in the new product distribution and apply the patches. Please contact team WSO2 as this needs to be handled on a case-by-case basis. Test the updated product distribution and deploy it in your production environment.","title":"Getting Continuous Updates"},{"location":"Getting_Continuous_Updates/#getting-continuous-updates","text":"If you are an existing WUM user , do the following to update your products. If not, see Getting Started with WUM . In these steps, you move updates to production by extracting the updates into a ZIP file, testing the updates, and then manually merging them to the existing product distribution. You do not replace the existing production setup with the WUM-updated setup. Before you begin, do you have a proxy server/firewall? Then, grant access to the endpoints mentioned below. Click for more information WUM gets updates by connecting to the https://api.updates.wso2.com and https://cdn.updates.wso2.com endpoints in the WSO2 Update service. If your system connects to the Update service through a proxy server/firewall, grant access to these endpoints. Since WUM is a command-line tool, the proxy should be configured from your command-line as follows: export http_proxy = http : //username:password@proxyhost:port/ If you are behind an NTLM proxy, you can use a third party tool like CNTLM to do the NTLM proxy authentication. See the CNTLM documentation for instructions. Run the following commands to check whether there are updates available: wum check - update product E . g ., wum check - update wso2am - 2.5.0 If an update is available, run the following command to start updating your product: wum update product E . g ., wum update wso2am - 2.5.0 Your local product repository should now contain the latest and the previous WUM-updated distributions. Let's extract the updates in the latest WUM-updated distribution to a ZIP file. Execute the following command to identify the previous WUM-updated pack for this product. wum list [ product - name ] E . g ., wum list wso2am Execute the following command: wum diff Latest - WUM - updated - distribution . zip Previous - WUM - updated - distribution . zip Note Note that the diff ZIP is created in the location from where you executed the diff command. Next, let's apply the WUM updates that you extracted to the ZIP file to the distribution pack that is currently running in your environment. Open the summary PDF that you get inside this ZIP file (also via email). It contains information about the: New configurations introduced with the update. Existing files/artifacts that are affected due to the update. If you do not have any customizations in the existing distribution, simply copy the changed configuration files mentioned in the ZIP to the corresponding directories in your product distribution. If you **have **customizations in the existing distribution, there might be conflicts between that and the WUM-updated distribution. {.expand-control-image}Click to read how to resolve conflicts... A conflict happens when a customized configuration file or artifact has changed in the WUM updates. As the file/artifact has your customizations in it, it is not recommended to completely replace this file with the file that comes with the update. Given below is how to resolve conflicts manually in different types of files/artifacts: File Type How to Merge the Conflicts Binary files Copy all the binary files (.jar, .jks, .car, .war) to the relevant directories in your existing product distribution. If you have made any customizations to .car and .war files, manually merge those changes. Note: If there are .war files in the WUM update, be sure to delete all extracted .war files in your existing product distribution. This is because all deployed .war files get extracted at the server startup and if there are already extracted .war files by that same name, the server will not extract the .war files in the WUM update. Jaggery files You cannot replace the Jaggery artifacts in your existing product distribution with the WUM-updated Jaggery artifacts because your existing Jaggery artifacts may contain customizations. Here's how to merge the files: Check the summary PDF to identify how the Jaggery files have changed because of the WUM updates. Apply the changes to the same files in your existing product distribution. Apply the updated configuration files Identify the configuration updates in the summary PDF and apply them (by merging) to the relevant configuration files in the /repository/conf folder of your existing product distribution. Note: Be sure to merge the configuration files in your environment with the new files. It is not recommended to replace them. Redundant files If there are artifacts/files that are removed by the WUM updates, remove them from your existing product distribution. Newly added files If there are newly added files listed in the PDF, create the same folder structure (if it doesn't exist) in your existing product distribution and add the file. Do you have additional WSO2 features installed in your product distribution? If so, {.expand-control-image}Click to read on... Please note that WSO2 does not recommend installing new features to standard products. If you already have features installed, you need to install the same features in the new product distribution and apply the patches. Please contact team WSO2 as this needs to be handled on a case-by-case basis. Test the updated product distribution and deploy it in your production environment.","title":"Getting Continuous Updates"},{"location":"Getting_Started/","text":"Getting Started If you are new to WSO2 updates, here is how to install WUM and update your product for the first time: Get a valid WSO2 support subscription or subscribe to our free trial . If you have a proxy server/firewall, grant access to the endpoints mentioned below. Info WUM gets updates by connecting to the https://api.updates.wso2.com and https://cdn.updates.wso2.com endpoints in the WSO2 Update service. If your system connects to the Update service through a proxy server/firewall, grant access to these endpoints. Since WUM is a command-line tool, the proxy should be configured from your command-line as follows: export http_proxy=http://username:password@proxyhost:port/ If you are behind an NTLM proxy, you can use a third party tool like CNTLM to do the NTLM proxy authentication. See the CNTLM documentation for instructions. Download and install WUM from https://wso2.com/wum/download/ . The UI guides you through the process. Execute the following command on the command-line to initialize WUM. wum init When prompted, give the WSO2 support subscription's user credentials. Note that the following directory is created in your computer: On Unix : ~/.wum3 On Windows : C:\\users\\ username \\.wum3 WUM updates are available only for the WSO2 product versions listed in https://wso2.com/updates/wum . Let's start by downloading a vanilla product distribution. //Search for an available product wum search keyword E . g ., wum search am //Download the product wum add product E . g ., wum add wso2am - 2.5.0 Check whether the product has any recent updates using the following command: wum check - update product E . g ., wum check - update wso2am - 2.5.0 Execute the following command to start updating your product: wum update product E . g ., wum update wso2am - 2.5.0 Note that the directory path of the new distribution appears on your terminal. You also get an email with details. What's next? Get continuous updates .","title":"Introduction"},{"location":"Getting_Started/#getting-started","text":"If you are new to WSO2 updates, here is how to install WUM and update your product for the first time: Get a valid WSO2 support subscription or subscribe to our free trial . If you have a proxy server/firewall, grant access to the endpoints mentioned below. Info WUM gets updates by connecting to the https://api.updates.wso2.com and https://cdn.updates.wso2.com endpoints in the WSO2 Update service. If your system connects to the Update service through a proxy server/firewall, grant access to these endpoints. Since WUM is a command-line tool, the proxy should be configured from your command-line as follows: export http_proxy=http://username:password@proxyhost:port/ If you are behind an NTLM proxy, you can use a third party tool like CNTLM to do the NTLM proxy authentication. See the CNTLM documentation for instructions. Download and install WUM from https://wso2.com/wum/download/ . The UI guides you through the process. Execute the following command on the command-line to initialize WUM. wum init When prompted, give the WSO2 support subscription's user credentials. Note that the following directory is created in your computer: On Unix : ~/.wum3 On Windows : C:\\users\\ username \\.wum3 WUM updates are available only for the WSO2 product versions listed in https://wso2.com/updates/wum . Let's start by downloading a vanilla product distribution. //Search for an available product wum search keyword E . g ., wum search am //Download the product wum add product E . g ., wum add wso2am - 2.5.0 Check whether the product has any recent updates using the following command: wum check - update product E . g ., wum check - update wso2am - 2.5.0 Execute the following command to start updating your product: wum update product E . g ., wum update wso2am - 2.5.0 Note that the directory path of the new distribution appears on your terminal. You also get an email with details.","title":"Getting Started"},{"location":"Getting_Started/#whats-next-get-continuous-updates","text":"","title":"What's next?\u00a0Get continuous updates."},{"location":"Introduction/","text":"Introduction WSO2 Updates include any improvements (e.g., bug fixes, security fixes) that are released by WSO2 on top of a released WSO2 product version. With updates, you do not have to wait until the next product version is released to get the fixes you want. Find out more about WSO2 updates at https://wso2.com/updates . You can get updates using WSO2 in-place updates or WSO2 update manager. The following table shows the key differences of the two: WSO2 in-place updates WSO2 update manager (WUM) You can install the in-place updates tool via a WUM update for all the WUM-supported products. You can download and install the WUM tool from https://wso2.com/wum/download/ . The tool merges the updated configuration files unless there are conflicts. You should manually merge the updated configuration files or use a tool like Puppet. The tool handles backup and restore. You should store backups with the custom configurations in your system, in case you have to restore later. Supported on only Unix-based (e.g., Linux, OS X) operating systems. Supported on all operating systems. A subscription is mandatory to get WSO2 updates. A subscription can be one of the following types: Free Trial Subscription: Provides all the functionality of a paid subscription for 14 days. The validity period can be extended. Paid Subscription: Can discuss your specific requirements with a WSO2 accounts manager and set up a subscription via a channel.Here are the available channels: Full : This is the default channel. It gives all updates including bug fixes, security fixes, and improvements. Security : Gives security bug fixes only. Premium : A custom channel that is only accessible to a particular customer (i.e., company). This channel gives access to specific updates as requested by the customer.","title":"Introduction"},{"location":"Introduction/#introduction","text":"WSO2 Updates include any improvements (e.g., bug fixes, security fixes) that are released by WSO2 on top of a released WSO2 product version. With updates, you do not have to wait until the next product version is released to get the fixes you want. Find out more about WSO2 updates at https://wso2.com/updates . You can get updates using WSO2 in-place updates or WSO2 update manager. The following table shows the key differences of the two: WSO2 in-place updates WSO2 update manager (WUM) You can install the in-place updates tool via a WUM update for all the WUM-supported products. You can download and install the WUM tool from https://wso2.com/wum/download/ . The tool merges the updated configuration files unless there are conflicts. You should manually merge the updated configuration files or use a tool like Puppet. The tool handles backup and restore. You should store backups with the custom configurations in your system, in case you have to restore later. Supported on only Unix-based (e.g., Linux, OS X) operating systems. Supported on all operating systems. A subscription is mandatory to get WSO2 updates. A subscription can be one of the following types: Free Trial Subscription: Provides all the functionality of a paid subscription for 14 days. The validity period can be extended. Paid Subscription: Can discuss your specific requirements with a WSO2 accounts manager and set up a subscription via a channel.Here are the available channels: Full : This is the default channel. It gives all updates including bug fixes, security fixes, and improvements. Security : Gives security bug fixes only. Premium : A custom channel that is only accessible to a particular customer (i.e., company). This channel gives access to specific updates as requested by the customer.","title":"Introduction"},{"location":"Restoring_the_Previous_Setup/","text":"Restoring the Previous Setup When there is an error in the current environment, you might want to roll back the updates and restore the previous stable distribution. To roll back your updates, you need to know which product distribution is currently running in your environment and the previous distribution that was stable. Therefore, it is recommended to keep records of your distributions as a best practice. The previous stable distribution should be stored in your local product repository and should be a fresh ZIP file without any customizations. You can roll back in two ways: Roll back updates using automation If you are using an automation tool such as Puppet, Ansible, or Chef, follow the steps given below: Apply the previous stable product distribution to your configuration management tool. This should be a fresh ZIP without customizations. Revert the configurations specific to the updates from the configuration management tool. See the update summary PDF inside the user_home /.wum-wso2/updates/summary- time stamp folder to check the configurations that were applied to the environment. Apply all your customizations to the product distribution. If you are using a deployment synchronization tool, make sure that these customizations are merged in the tool. Push the product distribution to your environment using the configuration management tool. Roll back updates manually Apply the configurations to the previous stable product distribution. Apply all your customizations to the product distribution. If you are using a deployment synchronization tool, make sure these customizations are merged in the tool. Push the product distribution to your environment.","title":"Restoring the Previous Setup"},{"location":"Restoring_the_Previous_Setup/#restoring-the-previous-setup","text":"When there is an error in the current environment, you might want to roll back the updates and restore the previous stable distribution. To roll back your updates, you need to know which product distribution is currently running in your environment and the previous distribution that was stable. Therefore, it is recommended to keep records of your distributions as a best practice. The previous stable distribution should be stored in your local product repository and should be a fresh ZIP file without any customizations. You can roll back in two ways:","title":"Restoring the Previous Setup"},{"location":"Restoring_the_Previous_Setup/#roll-back-updates-using-automation","text":"If you are using an automation tool such as Puppet, Ansible, or Chef, follow the steps given below: Apply the previous stable product distribution to your configuration management tool. This should be a fresh ZIP without customizations. Revert the configurations specific to the updates from the configuration management tool. See the update summary PDF inside the user_home /.wum-wso2/updates/summary- time stamp folder to check the configurations that were applied to the environment. Apply all your customizations to the product distribution. If you are using a deployment synchronization tool, make sure that these customizations are merged in the tool. Push the product distribution to your environment using the configuration management tool.","title":"Roll back updates using automation"},{"location":"Restoring_the_Previous_Setup/#roll-back-updates-manually","text":"Apply the configurations to the previous stable product distribution. Apply all your customizations to the product distribution. If you are using a deployment synchronization tool, make sure these customizations are merged in the tool. Push the product distribution to your environment.","title":"Roll back updates manually"},{"location":"Troubleshooting/","text":"Troubleshooting WUM is a simple command-line tool that you can download and use to get the latest updates for a WSO2 product. To get started from the command line, execute the 'wum --help' command, and the list of available commands and its usage will be explained. If you want detailed, step-by-step instructions on how to use WUM to get a WSO2 product updated, see Getting Started with WUM . We will now explain how to troubleshoot errors that you may encounter while working with WUM. WUM Message Explanation Possible Solution wum: unable to connect to WSO2 Update The WUM client cannot connect to the WSO2 Update server due to a network failure or the server response is not successful. Check your network connection. If the connection is still failing, please report to WSO2 at https://wso2.com/contact . Please be sure to attach the details of the error when you report. You can get the details by running the same command again using the '-v' flag. wum: update is not available in WSO2 Update: UpdateFileName WUM is unable to get updates from the WSO2 Update service due to a server error. Try running the wum command again. If the command continues to fail, please report to WSO2 at https://wso2.com/contact . Please be sure to attach the details of the error when you report. You can get the details by running the same command again using the '-v' flag. wum: servers are busy at the moment. Please try again later. The WSO2 Update server has reached the maximum capacity for handling requests at the current moment. wum: generating wum file twice. The file ' FileName ' has been added by a previous update. Current update is' UpdateNumber ' WSO2 updates are cumulative, which means that once the update files relevant to one particular update are downloaded once to your local update repository, the same update file will not be downloaded again in consequent updates. This error can sometimes (rarely) occur in situations where a cumulative file is erroneously downloaded twice. wum: invalid update file. Cannot find the update-descriptor.yaml file' FilePath ' Some updates dispatched from the WSO2 Update server does not contain the update-descriptor. yaml file. This file is stored inside the update file that is downloaded to your local update repository. wum: unknown form at in the update-descriptor.yamlfile' FilePath ' reason: Error Message Some updates dispatched from the WSO2 Update server contains an erroneous update-descriptor. yaml file. This file is stored inside the update file that is downloaded to your local update repository. wum: unable to zip directory ' DirectoryPath ' reason: Error Message When you run the 'wum update' or 'wum diff' commands, ZIP files should be created with the relevant distribution/files inside your local product repository. However, prior to creating the ZIP inside the product repository, the original product distribution is copied to a temporary directory location in order to apply the updates. This error occurs if the product distribution (in the temporary location) is deleted prior to generating the new ZIP file. wum: unable to download updates reason: Error Message WUM is unable to download the updates from the WSO2 Update server. wum: invalid JWT string to process reason: Error Message The JWT string is not in a valid format. wum: cannot find the MD5 file of the specified product in WSO2 Update WUM is unable to find the md5 sum of a file. wum: unable to generate the update summary. reason: Error Message WUM is not able to generate the update summary PDF for various reasons. When WUM generates a new product distribution ZIP file or a WUM diff ZIP file, a summary PDF file should be generated and stored inside the ZIP file (stored in the local product repository). The updated distribution/ZIP will not be created without the summary ZIP. wum: invalid update file. Update number of the update file name ' FilePath ' is not equal to update number specified in update-descriptor.yamlfile( UpdateNumber ) When WUM generates a new product distribution (ZIP file) or a ZIP file with updates (WUM Diff), your local update repository is checked for updates that have already been downloaded during previous updates. This error occurs when at least one of the update files in the local update repository is invalid, or if it has been manipulated by a user. wum: invalid credentials The credentials you provided are not valid. If your WSO2 account was created a short while back, the reason for the login failure may be that your credentials are not synced in the WSO2 Update server. Try again by providing the correct credentials. If your account was created a short while back, you might have to wait. If authentication is still failing, please report to WSO2 at https://wso2.com/contact . Please be sure to attach the details of the error when you report. You can get the details by running the same command again using the '-v' flag . wum: you haven't initialized WUM with your WSO2 credentials You have not initialized WUM. In order to update products, WUM should first be initialized. You can run the 'wum init' command to initialize WUM using your credentials. See the instructions on initializing WUM for more information. wum: your session has timed out The user session has timed out. wum: unable to read your input reason: Error Message The input value you provided with the wum command is invalid. Enter a valid input for the wum command and try again. See Getting Started with WUM for instructions on using the wum commands. wum: file not found You are attempting to add a product from a specific directory path to the local product repository using the following command: wum add -- file Path_to_product_download / product . zip However, the product file is not available in the directory you specified. Verify the directory path of the product distribution that you want to add to the repository, and then run the command again. See the instructions on adding products to the product repository . wum: invalid product filename: ProductFileName The name of the product distribution that you provided with the wum command is wrong or it does not exist in the local product repository. Verify the product distribution's name and run the command again. wum: product productName-productVersion is already added The product version that you are trying to add to your local product repository already exists in the repository. Try the following: First, delete the distribution from the local product repository using the ' wum delete ' command. Then, try adding the product again. wum: your product distribution ' ProductFileName ' contains local modifications. MD5 check failed. Please use the original product distribution. The product distribution that you are trying to update contains local modifications. WUM updates can only be applied to original product distributions (ZIP files) or to original product distributions that have been updated by WUM previously. Try the following: First, delete the distribution with local modifications from the product repository using the ' wum delete ' command. Add a new product . Update the new product you added. wum: cannot find a matching product for ' Pattern ' When executing the wum command, the pattern you used to specify the product is wrong. When you run the wum command, specify the product using a pattern that matches the product name. For example, wso2esb-4.9.0, wso2esb, wso2e etc. wum: unable to parse the given product pattern ' ProductPattern '. reason: Error Message wum: product ' ProductName-ProductVersion ' is not supported by WSO2 Update. wum: invalid product ' ProductName-ProductVersion ' wum: you are not supposed to set a value for 'repositories. RepoName .refreshtoken' You are using the 'wum config' command to change the refresh token of the product repository (specified in the config.yaml file), which is not allowed. You are not allowed to change the refresh token, access token or any other element related to the local product repository (except the directory location). The 'wum config' command should only be used to change the location of the local product repository as explained here. wum: you are not supposed to set a value for 'repositories. RepoName .accesstoken' You are using the 'wum config' command to change the access token of the product repository (specified in the config.yaml file), which is not allowed. wum: invalid repository config element ' ConfigElement ' You are using the 'wum config' command to change an element in the product repository (specified in the config.yaml file), which is not allowed. wum: invalid wumconfig element ' Arguement ' Try 'wum config --help' for more information. You are using the 'wum config' command to change an element in the product repository (specified in the config.yaml file), which is not allowed. wum: invalid number of arguments Try 'wum config --help' for more information. The 'wum config' command can only have two valid arguments. You are running the 'wum config' command using more than two arguments. When you are running the 'wum config' command to change the local product repository location, you should provide both the key and value corresponding to the product repository (specified in the config.yaml file) as shown below. wum config local . product . repo ~/ new_directory_path Key: local.product.repo Value: ~/ new_directory_path wum:wumconfiguration is not available. The WUM configuration file ( config.yaml ) stored in your local WUM_HOME directory ( ~/.wum-wso2/ ) is not available. Try executing the ' wum init ' command, which will create the configuration file. wum: unable to get the absolute path of ' Argument ' The path to the product distribution, which you provided with the following command is not the absolute path: wum add -- file Path_to_product_download / product . zip The relative path is not allowed with this command. Run the command again using the absolute path to the product distribution, instead of the relative path. wum: you haven't added any products yet You are attempting to execute a wum command without adding a product to your local product repository. Add the needed products to the local product repository by running the ' wum add ' command. wum: cannot validate the target distribution ' ProductName - ProductVersion . Timestamp '. Some updates required are missing from the local repository, which are found in the target distribution. You have executed the 'wum diff' command to get the updates between two product distributions. However, some updates, which are included in the newer product distribution (stored in the local product repository) are not available in the local update repository. When a WUM-updated product distribution is created inside the local product repository, the corresponding updates should be stored in the local update repository as well. This error may be because you have modified the contents of the local update repository. Try the following: First, delete the latest distribution from the product repository using the ' wum delete ' command. Generate a new updated distribution using the ' wum update ' command. Then, try the ' wum diff ' command again. wum: unable to unzip file ' FilePath ' reason: Error Message You are attempting to update a product using the 'wum add' command, or you are attempting to run the 'wum diff' command. However, the required product ZIP files (in the local product repository) are unable to unzip due to some corruption. Try downloading the ZIP file again and run the 'wum update' or 'wum diff' command. wum: local repository path is not available. When WUM is initialized, your local WUM_HOME directory ( ~/.wum-wso2/ ) is created, which contains the local update repository and the local product repository as explained here. This error occurs if the local product repository's path is missing in the config.yaml file. Update the product repository path in the config. yaml file using the ' wum config ' command. wum: unable to delete file ' FilePath '. Please delete the file manually. reason: Error Message You have executed the 'wum delete' command, but WUM is unable to delete the specified product file. You can try manually deleting the product file from the local product repository. wum: unable to download. cannot find a matching product for ' ProductName-ProductVersion ' You have executed the 'wum add' command to download a product distribution and to add it to the local product repository. However, the product name you specified is not available for downloading. Verify that the product name and version you provide is valid, and try again. See the instructions on adding products for more information. wum: invalid timestamp value '%!d(string= Timestamp )' The timestamp of the update file (stored in the local update repository) or the product distribution file (stored in the local product repository) has been manually changed. Try providing a valid timestamp and running the wum command again. wum: invalid product ' ProductName-ProductVersion '. Product version is missing The pattern used to specify the product does not include the valid product version. When the 'wum update' or 'wum diff' commands are executed, the product name should include the version name. Try providing a valid product pattern, which includes the correct product version. Follow the instructions in Getting Started with WUM. wum: username or password cannot be empty You have executed the 'wuminit' command to initialize WUM without providing values for the username and password. Give your credentials for the username and password, and try again. See the instructions on initializing WUM. wum: requires a product Try 'wum add --help' for more information. You have not specified a product with the 'wum add' command. Note that only one product can be specified at a time. Make sure that the product name is specified when running the 'wum add' command. See the instructions on adding products for more information. wum: requires only 1 product Try 'wum add --help' for more information. You cannot specify more than one product with the 'wum add' command. Make sure that only one product is specified with the 'wum add' command. See the instructions on adding products for more information. wum: requires only 1 product pattern Try 'wum check-update --help' for more information. You cannot specify more than one product with the 'check-update' command. Make sure that only one product is specified with 'check-update' command. See the instructions on checking updates for more information. wum: requires two updated product distributions Try 'wum diff --help' for more information. You have executed the 'wum diff' command to get the updates between two product distributions. However, you have only provided a single product distribution. Provide the two product distributions (with different timestamps) that you want to compare, and try the 'wum diff' command again. Be sure to use the product distribution names (including timestamps) accurately. wum: invalid update distribution names ' Distibution1 ' - ' Distibution2 ' Try 'wum diff --help' for more information. You have executed the 'wum diff' command to get the updates between two product distributions. However, the provided product distribution names are wrong. wum: update levels cannot be the same Try 'wum diff --help' for more information. You have executed the 'wum diff' command to get the updates between two product distributions. However, you have provided the same product distribution twice. wum: requires only 1 product pattern Try 'wum list --help' for more information. You have executed the 'wum list' command to get the list of product distributions management by WUM. However, you have specified multiple products. Try the 'wum list product_name ' command with a single product or try the 'wum list' command to get the list of all products. See the instructions on checking the list of products managed by WUM. You may encounter the following error messages due to permission restrictions at OS-level. WUM Message Explanation Possible Solution wum: unable to create directory ' Dir ' reason: Error Message WUM is unable to create the specified directory in the relevant location. Check the permissions (OS-level) for creating folders in the relevant locations. For example, you can enable permission to create folders in the following locations: WUM Home directory. OS-specific temporary directory. Also, check the available disc space and free some space if the available space is insufficient. If the error occurs even after enabling the above permissions, please report to WSO2 at https://wso2.com/contact . Please be sure to attach the details of the error when you report. You can get the details by running the same command again using the '-v' flag. wum: unable to copy file ' File ' to ' Path ' reason: Error Message WUM is unable to copy the specified file to the relevant path. wum: Failed to create directory: DirectoryPath . reason: Error Message WUM is unable to create the directory in the relevant location. wum: unable to update LICENSE.txt of the product reason: Error Message WUM is unable to update the LICENSE.txt file of the product. wum: unable to generate update log file. reason: Error Message WUM is unable to generate the update log file (metadata file) inside the local update repository. wum: unable to store update summary. reason: Error Message WUM is unable to store the update summary PDF in the local product repository. When you execute the 'wum update' or 'wum diff' commands, an update summary PDF file should be generated and stored inside the ZIP file (which is the updated product ZIP, or the ZIP file created with the WUM Diff). wum: unable to delete the file as adviced in the update ' FilePath ' reason: Error Message When applying updates to the existing product distribution, WUM is unable to delete files in the existing product distribution (as required for the update). wum: unable to load wum configuration from ' FilePath '. reason: Error Message WUM is unable to read the config.yaml file in order to execute the command. wum: unable to create wum configuration. reason: WUM is unable to create the config.yaml file in order to execute WUM. wum: unable to calculate the MD5 of the specified file ' FilePath ' reason: Error Message WUM is unable to calculate the MD5 sum of the specified file. wum: unable to read directory ' ProductDir ' reason: Error Message WUM is unable to read the specified directory when running the command. wum: unable to delete the product: FilePath reason: Error Message WUM is unable to delete the specified file when running the command. wum: Cannot create the temp directory wum-temp. reason: Error Message WUM is unable to create the temporary directory when running the command. wum: unable to create file ' FilePath ' reason: Error Message WUM is unable to create the file when running the command","title":"Troubleshooting Guide"},{"location":"Troubleshooting/#troubleshooting","text":"WUM is a simple command-line tool that you can download and use to get the latest updates for a WSO2 product. To get started from the command line, execute the 'wum --help' command, and the list of available commands and its usage will be explained. If you want detailed, step-by-step instructions on how to use WUM to get a WSO2 product updated, see Getting Started with WUM . We will now explain how to troubleshoot errors that you may encounter while working with WUM. WUM Message Explanation Possible Solution wum: unable to connect to WSO2 Update The WUM client cannot connect to the WSO2 Update server due to a network failure or the server response is not successful. Check your network connection. If the connection is still failing, please report to WSO2 at https://wso2.com/contact . Please be sure to attach the details of the error when you report. You can get the details by running the same command again using the '-v' flag. wum: update is not available in WSO2 Update: UpdateFileName WUM is unable to get updates from the WSO2 Update service due to a server error. Try running the wum command again. If the command continues to fail, please report to WSO2 at https://wso2.com/contact . Please be sure to attach the details of the error when you report. You can get the details by running the same command again using the '-v' flag. wum: servers are busy at the moment. Please try again later. The WSO2 Update server has reached the maximum capacity for handling requests at the current moment. wum: generating wum file twice. The file ' FileName ' has been added by a previous update. Current update is' UpdateNumber ' WSO2 updates are cumulative, which means that once the update files relevant to one particular update are downloaded once to your local update repository, the same update file will not be downloaded again in consequent updates. This error can sometimes (rarely) occur in situations where a cumulative file is erroneously downloaded twice. wum: invalid update file. Cannot find the update-descriptor.yaml file' FilePath ' Some updates dispatched from the WSO2 Update server does not contain the update-descriptor. yaml file. This file is stored inside the update file that is downloaded to your local update repository. wum: unknown form at in the update-descriptor.yamlfile' FilePath ' reason: Error Message Some updates dispatched from the WSO2 Update server contains an erroneous update-descriptor. yaml file. This file is stored inside the update file that is downloaded to your local update repository. wum: unable to zip directory ' DirectoryPath ' reason: Error Message When you run the 'wum update' or 'wum diff' commands, ZIP files should be created with the relevant distribution/files inside your local product repository. However, prior to creating the ZIP inside the product repository, the original product distribution is copied to a temporary directory location in order to apply the updates. This error occurs if the product distribution (in the temporary location) is deleted prior to generating the new ZIP file. wum: unable to download updates reason: Error Message WUM is unable to download the updates from the WSO2 Update server. wum: invalid JWT string to process reason: Error Message The JWT string is not in a valid format. wum: cannot find the MD5 file of the specified product in WSO2 Update WUM is unable to find the md5 sum of a file. wum: unable to generate the update summary. reason: Error Message WUM is not able to generate the update summary PDF for various reasons. When WUM generates a new product distribution ZIP file or a WUM diff ZIP file, a summary PDF file should be generated and stored inside the ZIP file (stored in the local product repository). The updated distribution/ZIP will not be created without the summary ZIP. wum: invalid update file. Update number of the update file name ' FilePath ' is not equal to update number specified in update-descriptor.yamlfile( UpdateNumber ) When WUM generates a new product distribution (ZIP file) or a ZIP file with updates (WUM Diff), your local update repository is checked for updates that have already been downloaded during previous updates. This error occurs when at least one of the update files in the local update repository is invalid, or if it has been manipulated by a user. wum: invalid credentials The credentials you provided are not valid. If your WSO2 account was created a short while back, the reason for the login failure may be that your credentials are not synced in the WSO2 Update server. Try again by providing the correct credentials. If your account was created a short while back, you might have to wait. If authentication is still failing, please report to WSO2 at https://wso2.com/contact . Please be sure to attach the details of the error when you report. You can get the details by running the same command again using the '-v' flag . wum: you haven't initialized WUM with your WSO2 credentials You have not initialized WUM. In order to update products, WUM should first be initialized. You can run the 'wum init' command to initialize WUM using your credentials. See the instructions on initializing WUM for more information. wum: your session has timed out The user session has timed out. wum: unable to read your input reason: Error Message The input value you provided with the wum command is invalid. Enter a valid input for the wum command and try again. See Getting Started with WUM for instructions on using the wum commands. wum: file not found You are attempting to add a product from a specific directory path to the local product repository using the following command: wum add -- file Path_to_product_download / product . zip However, the product file is not available in the directory you specified. Verify the directory path of the product distribution that you want to add to the repository, and then run the command again. See the instructions on adding products to the product repository . wum: invalid product filename: ProductFileName The name of the product distribution that you provided with the wum command is wrong or it does not exist in the local product repository. Verify the product distribution's name and run the command again. wum: product productName-productVersion is already added The product version that you are trying to add to your local product repository already exists in the repository. Try the following: First, delete the distribution from the local product repository using the ' wum delete ' command. Then, try adding the product again. wum: your product distribution ' ProductFileName ' contains local modifications. MD5 check failed. Please use the original product distribution. The product distribution that you are trying to update contains local modifications. WUM updates can only be applied to original product distributions (ZIP files) or to original product distributions that have been updated by WUM previously. Try the following: First, delete the distribution with local modifications from the product repository using the ' wum delete ' command. Add a new product . Update the new product you added. wum: cannot find a matching product for ' Pattern ' When executing the wum command, the pattern you used to specify the product is wrong. When you run the wum command, specify the product using a pattern that matches the product name. For example, wso2esb-4.9.0, wso2esb, wso2e etc. wum: unable to parse the given product pattern ' ProductPattern '. reason: Error Message wum: product ' ProductName-ProductVersion ' is not supported by WSO2 Update. wum: invalid product ' ProductName-ProductVersion ' wum: you are not supposed to set a value for 'repositories. RepoName .refreshtoken' You are using the 'wum config' command to change the refresh token of the product repository (specified in the config.yaml file), which is not allowed. You are not allowed to change the refresh token, access token or any other element related to the local product repository (except the directory location). The 'wum config' command should only be used to change the location of the local product repository as explained here. wum: you are not supposed to set a value for 'repositories. RepoName .accesstoken' You are using the 'wum config' command to change the access token of the product repository (specified in the config.yaml file), which is not allowed. wum: invalid repository config element ' ConfigElement ' You are using the 'wum config' command to change an element in the product repository (specified in the config.yaml file), which is not allowed. wum: invalid wumconfig element ' Arguement ' Try 'wum config --help' for more information. You are using the 'wum config' command to change an element in the product repository (specified in the config.yaml file), which is not allowed. wum: invalid number of arguments Try 'wum config --help' for more information. The 'wum config' command can only have two valid arguments. You are running the 'wum config' command using more than two arguments. When you are running the 'wum config' command to change the local product repository location, you should provide both the key and value corresponding to the product repository (specified in the config.yaml file) as shown below. wum config local . product . repo ~/ new_directory_path Key: local.product.repo Value: ~/ new_directory_path wum:wumconfiguration is not available. The WUM configuration file ( config.yaml ) stored in your local WUM_HOME directory ( ~/.wum-wso2/ ) is not available. Try executing the ' wum init ' command, which will create the configuration file. wum: unable to get the absolute path of ' Argument ' The path to the product distribution, which you provided with the following command is not the absolute path: wum add -- file Path_to_product_download / product . zip The relative path is not allowed with this command. Run the command again using the absolute path to the product distribution, instead of the relative path. wum: you haven't added any products yet You are attempting to execute a wum command without adding a product to your local product repository. Add the needed products to the local product repository by running the ' wum add ' command. wum: cannot validate the target distribution ' ProductName - ProductVersion . Timestamp '. Some updates required are missing from the local repository, which are found in the target distribution. You have executed the 'wum diff' command to get the updates between two product distributions. However, some updates, which are included in the newer product distribution (stored in the local product repository) are not available in the local update repository. When a WUM-updated product distribution is created inside the local product repository, the corresponding updates should be stored in the local update repository as well. This error may be because you have modified the contents of the local update repository. Try the following: First, delete the latest distribution from the product repository using the ' wum delete ' command. Generate a new updated distribution using the ' wum update ' command. Then, try the ' wum diff ' command again. wum: unable to unzip file ' FilePath ' reason: Error Message You are attempting to update a product using the 'wum add' command, or you are attempting to run the 'wum diff' command. However, the required product ZIP files (in the local product repository) are unable to unzip due to some corruption. Try downloading the ZIP file again and run the 'wum update' or 'wum diff' command. wum: local repository path is not available. When WUM is initialized, your local WUM_HOME directory ( ~/.wum-wso2/ ) is created, which contains the local update repository and the local product repository as explained here. This error occurs if the local product repository's path is missing in the config.yaml file. Update the product repository path in the config. yaml file using the ' wum config ' command. wum: unable to delete file ' FilePath '. Please delete the file manually. reason: Error Message You have executed the 'wum delete' command, but WUM is unable to delete the specified product file. You can try manually deleting the product file from the local product repository. wum: unable to download. cannot find a matching product for ' ProductName-ProductVersion ' You have executed the 'wum add' command to download a product distribution and to add it to the local product repository. However, the product name you specified is not available for downloading. Verify that the product name and version you provide is valid, and try again. See the instructions on adding products for more information. wum: invalid timestamp value '%!d(string= Timestamp )' The timestamp of the update file (stored in the local update repository) or the product distribution file (stored in the local product repository) has been manually changed. Try providing a valid timestamp and running the wum command again. wum: invalid product ' ProductName-ProductVersion '. Product version is missing The pattern used to specify the product does not include the valid product version. When the 'wum update' or 'wum diff' commands are executed, the product name should include the version name. Try providing a valid product pattern, which includes the correct product version. Follow the instructions in Getting Started with WUM. wum: username or password cannot be empty You have executed the 'wuminit' command to initialize WUM without providing values for the username and password. Give your credentials for the username and password, and try again. See the instructions on initializing WUM. wum: requires a product Try 'wum add --help' for more information. You have not specified a product with the 'wum add' command. Note that only one product can be specified at a time. Make sure that the product name is specified when running the 'wum add' command. See the instructions on adding products for more information. wum: requires only 1 product Try 'wum add --help' for more information. You cannot specify more than one product with the 'wum add' command. Make sure that only one product is specified with the 'wum add' command. See the instructions on adding products for more information. wum: requires only 1 product pattern Try 'wum check-update --help' for more information. You cannot specify more than one product with the 'check-update' command. Make sure that only one product is specified with 'check-update' command. See the instructions on checking updates for more information. wum: requires two updated product distributions Try 'wum diff --help' for more information. You have executed the 'wum diff' command to get the updates between two product distributions. However, you have only provided a single product distribution. Provide the two product distributions (with different timestamps) that you want to compare, and try the 'wum diff' command again. Be sure to use the product distribution names (including timestamps) accurately. wum: invalid update distribution names ' Distibution1 ' - ' Distibution2 ' Try 'wum diff --help' for more information. You have executed the 'wum diff' command to get the updates between two product distributions. However, the provided product distribution names are wrong. wum: update levels cannot be the same Try 'wum diff --help' for more information. You have executed the 'wum diff' command to get the updates between two product distributions. However, you have provided the same product distribution twice. wum: requires only 1 product pattern Try 'wum list --help' for more information. You have executed the 'wum list' command to get the list of product distributions management by WUM. However, you have specified multiple products. Try the 'wum list product_name ' command with a single product or try the 'wum list' command to get the list of all products. See the instructions on checking the list of products managed by WUM. You may encounter the following error messages due to permission restrictions at OS-level. WUM Message Explanation Possible Solution wum: unable to create directory ' Dir ' reason: Error Message WUM is unable to create the specified directory in the relevant location. Check the permissions (OS-level) for creating folders in the relevant locations. For example, you can enable permission to create folders in the following locations: WUM Home directory. OS-specific temporary directory. Also, check the available disc space and free some space if the available space is insufficient. If the error occurs even after enabling the above permissions, please report to WSO2 at https://wso2.com/contact . Please be sure to attach the details of the error when you report. You can get the details by running the same command again using the '-v' flag. wum: unable to copy file ' File ' to ' Path ' reason: Error Message WUM is unable to copy the specified file to the relevant path. wum: Failed to create directory: DirectoryPath . reason: Error Message WUM is unable to create the directory in the relevant location. wum: unable to update LICENSE.txt of the product reason: Error Message WUM is unable to update the LICENSE.txt file of the product. wum: unable to generate update log file. reason: Error Message WUM is unable to generate the update log file (metadata file) inside the local update repository. wum: unable to store update summary. reason: Error Message WUM is unable to store the update summary PDF in the local product repository. When you execute the 'wum update' or 'wum diff' commands, an update summary PDF file should be generated and stored inside the ZIP file (which is the updated product ZIP, or the ZIP file created with the WUM Diff). wum: unable to delete the file as adviced in the update ' FilePath ' reason: Error Message When applying updates to the existing product distribution, WUM is unable to delete files in the existing product distribution (as required for the update). wum: unable to load wum configuration from ' FilePath '. reason: Error Message WUM is unable to read the config.yaml file in order to execute the command. wum: unable to create wum configuration. reason: WUM is unable to create the config.yaml file in order to execute WUM. wum: unable to calculate the MD5 of the specified file ' FilePath ' reason: Error Message WUM is unable to calculate the MD5 sum of the specified file. wum: unable to read directory ' ProductDir ' reason: Error Message WUM is unable to read the specified directory when running the command. wum: unable to delete the product: FilePath reason: Error Message WUM is unable to delete the specified file when running the command. wum: Cannot create the temp directory wum-temp. reason: Error Message WUM is unable to create the temporary directory when running the command. wum: unable to create file ' FilePath ' reason: Error Message WUM is unable to create the file when running the command","title":"Troubleshooting"},{"location":"Using_WSO2_In-Place_Updates/","text":"Using WSO2 In-Place Updates The WSO2 in-place updates tool allows you to update your currently used product by fetching updates from the server and merging all configurations and files. The tool also gives backup and restore capability. Before you begin Make sure you are already using a WSO2 product . (Let's call this PRODUCT_HOME ). Make sure you have an active Internet connection. Get a valid WSO2 subscription . Do you have a proxy server/firewall? If so, grant access to the endpoints mentioned below. Click to expand WUM gets updates by connecting to the https://api.updates.wso2.com and https://cdn.updates.wso2.com endpoints in the WSO2 Update service. If your system connects to the Update service through a proxy server/firewall, grant access to these endpoints. Since WUM is a command-line tool, the proxy should be configured from your command-line as follows: export http_proxy=http://username:password@proxyhost:port/$$ If you are behind an NTLM proxy, you can use a third party tool like CNTLM to do the NTLM proxy authentication. See the CNTLM documentation for instructions. Let's begin. Stop the WSO2 product server if it is running. Go to the PRODUCT_HOME /bin directory and run the in-place updates tool that is appropriate to your OS: ./ update_linux ( On Linux ) ./ update_darwin ( On OS X ) The tool is currecntly not supported on Windows . When prompted, give the following: WSO2 subscription's user credentials. The channel that you subscribed to (e.g., full or security) when getting a WSO2 subscription. Note that the tool starts to update your product. {.expand-control-image}If the tool lists any conflicts, click to see how to resolve them... A conflict is likely to happen when a configuration file or artifact that you have customized has changed in the updates. If the file/artifact has conflicts, the tool does not attempt to merge it. In case you have customized .war or .car files, you need to apply the customizations on top of the updated .war and .car files. Go to the locations of the files that have conflicts and note the following files that are created by the tool: The file that has your customizations (e.g., test.jag ). The file that was there in the previous update level, before updating (e.g., test.jag.old ). The file that is in the new update level, after updating (e.g., test.jag.updated ). The difference of the two files in ii and **iii **(e.g., test.jag.diff ). By looking at the three files ( .old , .updated , and .diff ), resolve the conflicts and save the resolved file with the ** .final **extension (e.g., test.jag.final ). Run the tool again with the '--continue' flag for the tool to merge the changes in .final file with the file which created the conflict. ./ update_linux -- continue ( On Linux ) ./ update_darwin -- continue ( On OS X ) Go back to the location of the conflicting file and note that the tool has merged the .final file with the file that had your custom configurations and deleted all the other temporary files (i.e., .old , .updated , .diff , and .final ) Restart the server. If you want to revert the updates and restore the previous state, run the following command: ./ update_linux -- revert ( On Linux ) ./ update_darwin -- revert ( On OS X ) Tip : To see a list of commands the tool provides, run the tool with the --help option. You have now updated your product using the WSO2 in-place update tool.","title":"Using WSO2 In-Place Updates"},{"location":"Using_WSO2_In-Place_Updates/#using-wso2-in-place-updates","text":"The WSO2 in-place updates tool allows you to update your currently used product by fetching updates from the server and merging all configurations and files. The tool also gives backup and restore capability. Before you begin Make sure you are already using a WSO2 product . (Let's call this PRODUCT_HOME ). Make sure you have an active Internet connection. Get a valid WSO2 subscription . Do you have a proxy server/firewall? If so, grant access to the endpoints mentioned below. Click to expand WUM gets updates by connecting to the https://api.updates.wso2.com and https://cdn.updates.wso2.com endpoints in the WSO2 Update service. If your system connects to the Update service through a proxy server/firewall, grant access to these endpoints. Since WUM is a command-line tool, the proxy should be configured from your command-line as follows: export http_proxy=http://username:password@proxyhost:port/$$ If you are behind an NTLM proxy, you can use a third party tool like CNTLM to do the NTLM proxy authentication. See the CNTLM documentation for instructions. Let's begin. Stop the WSO2 product server if it is running. Go to the PRODUCT_HOME /bin directory and run the in-place updates tool that is appropriate to your OS: ./ update_linux ( On Linux ) ./ update_darwin ( On OS X ) The tool is currecntly not supported on Windows . When prompted, give the following: WSO2 subscription's user credentials. The channel that you subscribed to (e.g., full or security) when getting a WSO2 subscription. Note that the tool starts to update your product. {.expand-control-image}If the tool lists any conflicts, click to see how to resolve them... A conflict is likely to happen when a configuration file or artifact that you have customized has changed in the updates. If the file/artifact has conflicts, the tool does not attempt to merge it. In case you have customized .war or .car files, you need to apply the customizations on top of the updated .war and .car files. Go to the locations of the files that have conflicts and note the following files that are created by the tool: The file that has your customizations (e.g., test.jag ). The file that was there in the previous update level, before updating (e.g., test.jag.old ). The file that is in the new update level, after updating (e.g., test.jag.updated ). The difference of the two files in ii and **iii **(e.g., test.jag.diff ). By looking at the three files ( .old , .updated , and .diff ), resolve the conflicts and save the resolved file with the ** .final **extension (e.g., test.jag.final ). Run the tool again with the '--continue' flag for the tool to merge the changes in .final file with the file which created the conflict. ./ update_linux -- continue ( On Linux ) ./ update_darwin -- continue ( On OS X ) Go back to the location of the conflicting file and note that the tool has merged the .final file with the file that had your custom configurations and deleted all the other temporary files (i.e., .old , .updated , .diff , and .final ) Restart the server. If you want to revert the updates and restore the previous state, run the following command: ./ update_linux -- revert ( On Linux ) ./ update_darwin -- revert ( On OS X ) Tip : To see a list of commands the tool provides, run the tool with the --help option. You have now updated your product using the WSO2 in-place update tool.","title":"Using WSO2 In-Place Updates"},{"location":"Using_WSO2_Update_Manager/","text":"Using WSO2 Update Manager WSO2 Update Manager (WUM) is a command-line utility that allows you to get the latest updates of a product. See the topics below: {{% children %}}","title":"Using WSO2 Update Manager"},{"location":"Using_WSO2_Update_Manager/#using-wso2-update-manager","text":"WSO2 Update Manager (WUM) is a command-line utility that allows you to get the latest updates of a product. See the topics below: {{% children %}}","title":"Using WSO2 Update Manager"},{"location":"WSO2_Updates/","text":"WSO2 Updates Welcome to the WSO2 Updates documentation! Get started with WSO2 Updates Introduction What are WSO2 Updates. WSO2 In-Place Updates Get updates using the WSO2 in-place updates tool. WSO2 Update Manager Get updates using WSO2 Update Manager (WUM). FAQs Have a question? Check here.","title":"WSO2 Update Manager"},{"location":"WSO2_Updates/#wso2-updates","text":"Welcome to the WSO2 Updates documentation!","title":"WSO2 Updates"},{"location":"WUM_Commands_Guide/","text":"WUM Commands Guide wum init wum search wum add wum check update wum update wum diff wum version wum describe wum list wum delete wum config wum init Before you install updates to your products, you download and initialize WUM. This creates the user_home /.wum3 directory in the following location: On Linux/OS X: ~/.wum3 On Windows: C:\\users\\ username \\.wum3 This directory contains the following: LocalUpdate Repository ( user_home /.wum3/update ): Stores all updates (for all products) that are done using WUM. LocalProduct Repository ( user_home /.wum3/product ): Stores all WUM-updated product distributions and the ZIP files generated by the wum diff command . config.yaml file: Contains information about your WUM installation. It is not recommendedto edit this file. wum init // The tool prompts for the email address and password. wum init - u email - address - p password // If your password has the $ sign, escape it using \\ . For example, if your password is 123$abc, you should enter 123\\$abc. This is because the $ sign is used for variables in BASH. wum init -- username email - address -- password password wum search // To search for latest products. wum search wum search -- all // To search for products with am in the name. wum search am wum add // To download the latest product. wum add wso2mb // To download a given product name and version. wum add wso2mb - 3.2.0 // To add from the local machine. wum add -- file file - path wum check update // To check for updates for the default channel. wum check - update wso2mb - 3.2.0 // To check for updates for a given channel (e.g., full channel). wum check - update wso2mb - 3.2.0 full wum update // To update the product via the default channel. wum update wso2mb - 3.2.0 // To update the product via the full channel. wum update wso2mb - 3.2.0 full wum diff // To get the updates between two packs. wum diff distribution - 1. zip distribution - 2. zip wum version // To get the version of the wum-client wum version wum describe // To describe all the products in wum-home. wum describe // To describe wso2mb products in wum-home. wum describe wso2mb // To describe wso2mb-3.2.0 products in wum-home. wum describe wso2mb - 3.2.0 // To describe wso2mb products that are subscribed via the full channel. wum describe wso2mb full // To describe wso2mb-3.2.0 products that are subscribed via the full channel. wum describe wso2mb - 3.2.0 full // To describe a specified product in the repo. wum describe distribution - 1. zip wum list // To list the all products in wum-home. wum list // To list wso2mb products in wum-home. wum list wso2mb // To list wso2mb-3.2.0 products in wum-home. wum list wso2mb - 3.2.0 // To list wso2mb products that are subscribed via the full channel. wum list wso2mb full // To list wso2mb-3.2.0 products that are subscribed via the full channel. wum list wso2mb - 3.2.0 full wum delete // Prompt to delete all the products in wum-home. wum delete // Prompt to delete wso2mb products in wum-home. wum delete wso2mb // Prompt to delete wso2mb-3.2.0 products in wum-home. wum delete wso2mb - 3.2.0 // Prompt to delete wso2mb products that are subscribed via the full channel. wum delete wso2mb full // Prompt to delete wso2mb-3.2.0 products that are subscribed via the full channel. wum delete wso2mb - 3.2.0 full // Prompt to delete a specified product in the repo. wum delete distribution - 1. zip wum config // To change the location of the local product repository. wum config local . product . repo ~/ work / wso2 / products // To change the default channel. wum config defaultchannel security Attachments: {width=\"8\" height=\"8\"} Screen Shot 2017-10-17 at 10.07.37 AM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-17 at 10.11.10 AM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-27 at 5.02.37 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-27 at 8.46.30 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-27 at 5.02.37 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-27 at 8.46.30 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 5.13.57 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 5.16.53 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 7.25.37 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 7.25.11 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 7.27.54 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 8.14.09 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 10.18.57 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 11.19.18 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 11.23.18 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 11.35.23 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 11.49.52 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-17 at 9.49.20 AM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-17 at 10.06.30 AM.png (image/png)","title":"WUM Commands Guide"},{"location":"WUM_Commands_Guide/#wum-commands-guide","text":"wum init wum search wum add wum check update wum update wum diff wum version wum describe wum list wum delete wum config","title":"WUM Commands Guide"},{"location":"WUM_Commands_Guide/#wum-init","text":"Before you install updates to your products, you download and initialize WUM. This creates the user_home /.wum3 directory in the following location: On Linux/OS X: ~/.wum3 On Windows: C:\\users\\ username \\.wum3 This directory contains the following: LocalUpdate Repository ( user_home /.wum3/update ): Stores all updates (for all products) that are done using WUM. LocalProduct Repository ( user_home /.wum3/product ): Stores all WUM-updated product distributions and the ZIP files generated by the wum diff command . config.yaml file: Contains information about your WUM installation. It is not recommendedto edit this file. wum init // The tool prompts for the email address and password. wum init - u email - address - p password // If your password has the $ sign, escape it using \\ . For example, if your password is 123$abc, you should enter 123\\$abc. This is because the $ sign is used for variables in BASH. wum init -- username email - address -- password password","title":"wum init"},{"location":"WUM_Commands_Guide/#wum-search","text":"// To search for latest products. wum search wum search -- all // To search for products with am in the name. wum search am","title":"wum search"},{"location":"WUM_Commands_Guide/#wum-add","text":"// To download the latest product. wum add wso2mb // To download a given product name and version. wum add wso2mb - 3.2.0 // To add from the local machine. wum add -- file file - path","title":"wum add"},{"location":"WUM_Commands_Guide/#wum-check-update","text":"// To check for updates for the default channel. wum check - update wso2mb - 3.2.0 // To check for updates for a given channel (e.g., full channel). wum check - update wso2mb - 3.2.0 full","title":"wum check update"},{"location":"WUM_Commands_Guide/#wum-update","text":"// To update the product via the default channel. wum update wso2mb - 3.2.0 // To update the product via the full channel. wum update wso2mb - 3.2.0 full","title":"wum update"},{"location":"WUM_Commands_Guide/#wum-diff","text":"// To get the updates between two packs. wum diff distribution - 1. zip distribution - 2. zip","title":"wum diff"},{"location":"WUM_Commands_Guide/#wum-version","text":"// To get the version of the wum-client wum version","title":"wum version"},{"location":"WUM_Commands_Guide/#wum-describe","text":"// To describe all the products in wum-home. wum describe // To describe wso2mb products in wum-home. wum describe wso2mb // To describe wso2mb-3.2.0 products in wum-home. wum describe wso2mb - 3.2.0 // To describe wso2mb products that are subscribed via the full channel. wum describe wso2mb full // To describe wso2mb-3.2.0 products that are subscribed via the full channel. wum describe wso2mb - 3.2.0 full // To describe a specified product in the repo. wum describe distribution - 1. zip","title":"wum describe"},{"location":"WUM_Commands_Guide/#wum-list","text":"// To list the all products in wum-home. wum list // To list wso2mb products in wum-home. wum list wso2mb // To list wso2mb-3.2.0 products in wum-home. wum list wso2mb - 3.2.0 // To list wso2mb products that are subscribed via the full channel. wum list wso2mb full // To list wso2mb-3.2.0 products that are subscribed via the full channel. wum list wso2mb - 3.2.0 full","title":"wum list"},{"location":"WUM_Commands_Guide/#wum-delete","text":"// Prompt to delete all the products in wum-home. wum delete // Prompt to delete wso2mb products in wum-home. wum delete wso2mb // Prompt to delete wso2mb-3.2.0 products in wum-home. wum delete wso2mb - 3.2.0 // Prompt to delete wso2mb products that are subscribed via the full channel. wum delete wso2mb full // Prompt to delete wso2mb-3.2.0 products that are subscribed via the full channel. wum delete wso2mb - 3.2.0 full // Prompt to delete a specified product in the repo. wum delete distribution - 1. zip","title":"wum delete"},{"location":"WUM_Commands_Guide/#wum-config","text":"// To change the location of the local product repository. wum config local . product . repo ~/ work / wso2 / products // To change the default channel. wum config defaultchannel security","title":"wum config"},{"location":"WUM_Commands_Guide/#attachments","text":"{width=\"8\" height=\"8\"} Screen Shot 2017-10-17 at 10.07.37 AM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-17 at 10.11.10 AM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-27 at 5.02.37 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-27 at 8.46.30 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-27 at 5.02.37 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-27 at 8.46.30 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 5.13.57 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 5.16.53 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 7.25.37 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 7.25.11 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 7.27.54 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-31 at 8.14.09 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 10.18.57 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 11.19.18 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 11.23.18 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 11.35.23 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-09-17 at 11.49.52 PM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-17 at 9.49.20 AM.png (image/png) {width=\"8\" height=\"8\"} Screen Shot 2017-10-17 at 10.06.30 AM.png (image/png)","title":"Attachments:"},{"location":"_index/","text":"WSO2 Updates Welcome to the WSO2 Updates documentation! Get started with WSO2 Updates Introduction What are WSO2 Updates. WSO2 In-Place Updates Get updates using the WSO2 in-place updates tool. WSO2 Update Manager Get updates using WSO2 Update Manager (WUM). FAQs Have a question? Check here.","title":"WSO2 Update Manager"},{"location":"_index/#wso2-updates","text":"Welcome to the WSO2 Updates documentation!","title":"WSO2 Updates"},{"location":"BestPracticesGuide/","text":"This is parent page","title":"Best Practices Guide"},{"location":"BestPracticesGuide/#this-is-parent-page","text":"","title":"This is parent page"},{"location":"BestPracticesGuide/Best_Practices_Guide/","text":"Best Practices Guide Given below are the best practices to follow for different file types when updating your products. Following these best practices ensures a seamless update process and a lower number of merge conflicts. File Type Best Practices .jar files Do not modify the original .jar files. When updating your product, the WSO2 in-place tool replaces the existing .jar files with updated ones. If you modify the original .jar files, your customization will be lost. To avoid this, use an extension point as explained in Using Extension Points in Carbon and https://github.com/wso2-extensions. See https://store.wso2.com/store/pages/top-assets for a list of released connectors and extensions. .war files Do not modify .war files. It is not recommended to modify .war files. In case you have modified .war files in your distribution, after updating your product distribution, reapply your modifications in the updated .war files. .car files Do not modify the original .car files. In case your original product distribution contains .car files, do not modify them as they can be changed by continuous updates. .jag/.js files Maintain the same code indentation of the original .js files in the updated .js files. .jks files The in-place update tool doesn't update .jks files. .json files Maintain the same code indentation of the original .json files in the updated .json files. Else, there will be merge conflicts. ??? note \"Click to see example\" Shown below is the difference between a .json file before and after a modification. As shown, the indentation has changed in the updated file and this might result in a merge conflict in the WSO2 in-place update tool. Maintain the order of the .json file as much as possible. For example, when you add a new key-value pair, add it to the end of the file. ??? note \"Click to see example\" Shown below is the difference between a .json file before and after a modification. As shown, the new key-value pair is not added to the end of the file. As a result, line number 2 in the original file is not the same as the updated file, which will cause a merge conflict in the WSO2 in-place update tool. There will not be merge conflicts when the new line is added to the end of the file, preserving the original order:","title":"Best Practices Guide"},{"location":"BestPracticesGuide/Best_Practices_Guide/#best-practices-guide","text":"Given below are the best practices to follow for different file types when updating your products. Following these best practices ensures a seamless update process and a lower number of merge conflicts. File Type Best Practices .jar files Do not modify the original .jar files. When updating your product, the WSO2 in-place tool replaces the existing .jar files with updated ones. If you modify the original .jar files, your customization will be lost. To avoid this, use an extension point as explained in Using Extension Points in Carbon and https://github.com/wso2-extensions. See https://store.wso2.com/store/pages/top-assets for a list of released connectors and extensions. .war files Do not modify .war files. It is not recommended to modify .war files. In case you have modified .war files in your distribution, after updating your product distribution, reapply your modifications in the updated .war files. .car files Do not modify the original .car files. In case your original product distribution contains .car files, do not modify them as they can be changed by continuous updates. .jag/.js files Maintain the same code indentation of the original .js files in the updated .js files. .jks files The in-place update tool doesn't update .jks files. .json files Maintain the same code indentation of the original .json files in the updated .json files. Else, there will be merge conflicts. ??? note \"Click to see example\" Shown below is the difference between a .json file before and after a modification. As shown, the indentation has changed in the updated file and this might result in a merge conflict in the WSO2 in-place update tool. Maintain the order of the .json file as much as possible. For example, when you add a new key-value pair, add it to the end of the file. ??? note \"Click to see example\" Shown below is the difference between a .json file before and after a modification. As shown, the new key-value pair is not added to the end of the file. As a result, line number 2 in the original file is not the same as the updated file, which will cause a merge conflict in the WSO2 in-place update tool. There will not be merge conflicts when the new line is added to the end of the file, preserving the original order:","title":"Best Practices Guide"},{"location":"Concepts/Access_Control_and_Entitlement_Management/","text":"Access Control and Entitlement Management Today, enterprise applications seek ways of enforcing security that allows the right people to access the right resources with restrictions enforced by enterprise policies. Identity and entitlement management systems, as a whole, attempt to address these security considerations. These systems help enterprise architects and developers in their application requirement implementations and try to significantly ease the burden of security-related implementations. These identity and entitlement management systems are governed by industry standard specifications, hence supporting security requirements for heterogeneous applications becomes easy. Click here for more information on Access control. This topic consists of the following sections: Types of access control | Introducing XACML | Why XACML | XACML system architecture | XACML terminology | XACML engine architecture | XACML policy language structure and syntax | Improvements in XACML 3.0 | XACML 2.0 and XACML 3.0 samples Types of access control {width=\"320\"} The following table describes the various types of access control. Access Control Type Description Access Control Lists Access control lists are the oldest and most basic form of access control. This type was primarily adopted for use in operating systems. This maintains a set of users and operations that can be performed on a resource as a mapping. This is easy to implement due to the use of maps. However, this is not scalable for larger user bases and can become difficult to manage. Role-based Access Control Role-based Access Control (RBAC) is an approach used to restrict access to authorized users based on their role. This is a static permission model which provides access control. It is used by the majority of enterprises with more than 500 users. This access control type is used when all users are categorized into different roles. The roles define the resources that can be accessed by users assigned to that role. This type of access control reduces management overhead. These users and roles can also be externalized using user stores. These roles need to be managed carefully. There can be instances where a user is assigned to multiple roles. This is a subset of ABAC. Static permissions for roles can be given by updating permission tree in WSO2 Identity Server. Click here for information on Configuring roles and permissions. Attribute-based Access Control Attribute-based access control (ABAC) defines a new access control paradigm whereby access rights are granted to users through the use of policies that combine attributes together. Here, authorization happens based on attributes. This access control type addresses the limitations of role-based access control to provide a more fine-grained approach. This can be based on the attributes of the user, the environment, or even the resource itself. This is more flexible when compared with the role-based approach. There is no need to know the user prior to granting access. Policy-based Access Control This type of access control addresses the requirement to have a more uniform access control mechanism. This helps larger enterprises to have uniform access control for the large amount of organizational units. This is helpful when carrying out security audits. This is the most complex form of access control. This involves specifying policies unambiguously using XACML and using authorized attribute sources in the enterprise. Here Policy Based Access Control(PBAC) (also called Rule-based access control) is an extension of ABAC where attributes are used in writing policies. Introducing XACML XACML (eXtensible Access Control Markup Language) is an XML-based language for access control that has been standardized by the Technical Committee of the OASIS consortium. XACML is popular as a fine grain authorization method among the community. However, there are aspects of XACML that surpasses other policy standards by being a fine-grained authorization mechanism. Although XACML was introduced as a standard by OASIS in 2003, not many organizations that have adopted it yet. This is because most organization's lack of interest in moving towards a XACML based solution for authorization. The following can be some of the reasons for this: Many software designer and developers lack a clear understanding of features, importance, and advantages of XACML. It is comparatively difficult to implement a XACML solution when compared with a typical JDBC or hard-coded authorization system. Performance of XACML-based authorization system may be less than adequate. The complexity of defining and managing XACML policies. However, current market trends indicate that there is some motivation for XACML-based authorization systems. This section includes some architectural and implementation details on XACML with an existing XACML engine. To summarize, XACML describes both an access control policy language, request/response language, and reference architecture. The policy language is used to express access control policies (who can do what, when). The request/response language expresses queries about whether a particular access should be allowed (requests) and describes answers to those queries(responses). The reference architecture proposes a standard for deployment of necessary software modules within an infrastructure to allow efficient enforcement of policies. WSO2 Identity Server uses XACML as a tool for controlling access to applications. Recommended reading For more information on XACML specifications and other related information, see the OASIS website . Why XACML Most of the organizations still use legacy systems with inbuilt authorization logic. Sometimes, one organization contains a large number of information systems and applications that each system or application uses for their own process for authorization. Today, authorization has become more complex because users within organizations and outside need access to shared data and have the need to collaborate efficiently. Therefore, this has been challenging task to manage these legacy systems, custom authorization systems. However, XACML offers a solution to this problem. Most traditional authorization systems mostly have the following features: Authorization logic is hard-coded into the source code. Authorization logic is stored in databases that could only be readable and understandable by the underlying application The following are the some goals that current organizations are looking at from an authorization system. Can business managers (who should determine how access controls would be implemented) define and modify different authorization logic? Can we find new IT technicians to manage these legacy systems? Especially when those who developed the system have left the organization? Can different authorization logic be modified without any source code changes in a dynamic way? Is authorization system capable of evaluating following rule? \u201cX resource can be accessed by the Users who are from example.com domain and whose age is greater than 21 years old\u201d If we are going to implement a new information system with the organization, can we re-use the authorization logic of a legacy system? Can we achieve a fine-grained authorization level without defining a large number of static combinations? Are the authorization systems capable of answering the questions such as: \u201cCan a user, Bob, transfer X amount from Y current account at 1.00pm?\u201c Clearly, the above goals cannot be achieved from a traditional authorization system. However, a XACML-based authorization solution can help to achieve all of these goals, because XACML: is a standard which is ratified by OASIS standards organization. is a policy language implemented using XML which is an industry standard. supports Attribute-based Access Control (ABAC) and evaluation can be done with the additional data retrieved from Policy Information Point (PIP) which is defined by the XACML reference architecture. Note Attribute-based Access Control(ABAC) ABAC is an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together. The policies can use any type of attributes (user attributes, resource attributes, object, environment attributes etc.). This model supports boolean logic, in which rules contain \"IF, THEN\" statements about who is making the request, the resource, and the action. For example: IF the requestor is a manager, THEN allow read/write access to sensitive data. contains reference architecture which is provided to externalize the authorization system. The Policy Decision Point (PDP) offers authorization as a service in your infrastructure. Authorization algorithms can be removed from the application logic and applications can query the PDP via their own Policy Enforcement Points (PEP). provides fine-grained authorization with higher level of abstraction by means of policies and rules. supports dynamic evaluation of policies by using the Policy Information Point (PIP). can publish multiple policies into external PDPs. XACML system architecture Policy Decision Point (PDP) evaluates policies against access requests provided by Policy Enforcement Points (PEP). To provide the decisions, PDP may also need to query a Policy Information Point (PIP) to gather descriptive attributes about the user or any other missing attribute in the request. Policy Administration Point (PAP) is used to manage the PDP and PIP functionality. {width=\"800\"} XACML terminology The XACML reference architecture illustrated above is comprised of the following four 'building blocks'. Policy Enforcement Point (PEP) : The system entity that performs access control by making decision requests and enforcing authorization decisions. This is the entity that sends the XACML request to the Policy Decision Point (PDP) and receives an authorization decision. Policy Decision Point (PDP) : The system entity that evaluates an applicable policy and returns an authorization decision. Policy Information Point (PIP) : The system entity that acts as a source of attribute values. If there are missing attributes in the XACML request that is sent by PEP, PIP would find them for the PDP to evaluate the policy. Policy Administration Point (PAP) : The system entity that creates a policy or policy set and manages them. XACML engine architecture The WSO2 Identity Server is a major player in the XACML and open source world. The Identity Server supports XACML 3.0, which is based on Balana XACML implementation . As the source code, distribution and documentation are available for free, it is possible to analyze and understand the architecture behind it. You can find source code from here . This section provides some information regarding the architecture of the XACML engine (or the entitlement engine) of the WSO2 Identity Server. The XACML engine of the WSO2 Identity Server has two major components, i.e., PAP and PDP. The section below focuses on Policy Decision Point (PDP). The following diagram represents the component architecture of the PDP. {width=\"750\"} The following provides a more detailed information on the various components available in the PDP architecture. Entitlement Admin Service All PDP configurations are exposed via this API as a Web service which you need to have certain privileges to access. The following functions can be done by calling this API. Invalidating caches Refreshing policy, attribute, resource finder modules Retrieving PDP configurations Includes the function for testing the Test PDP with a given sample request or a sample request with given policies Entitlement Service Actual XACML authorization API is exposed via this API as a Web service. This service supports the following three communication methods with PEP. SOAP-based Web service Thrift binary protocol (this is much faster than SOAP) WS-XACML (This is the standard way but not popular) Balana PDP This is the core of the engine. Balana PDP has been initialized with all the attribute finders, resource finders and policy finder modules that are plugged with WSO2 Identity Server. Balana Test PDP This is same as Balana PDP. However, this instance has been initialized with the PAP policy store. It means, policies that are defined by PAP can be evaluated by using this PDP instance. There is no policy caching or decision caching with this. Therefore, this can only be used for testing your policies in the PAP store. Web service API for Balana Test PDP is exposed via the Entitlement Admin Service with method name \u201cdoTestRequest()\u201d. Carbon Policy Finder This module finds policies from different policy stores to evaluate a XACML request. The following is a high-level diagram of how this works. {width=\"750\"} Any number of policy finder modules can be plugged with the Carbon policy finder. You need to implement the CarbonPolicyFinderModule interface to write a new module and register it using the configuration file called entitlement.properties.xml in IS_HOME /repository/components/features/org.wso2.carbon.identity.xacml.server_5.8.145 directory . By default, WSO2 Identity Server is shipped with a Carbon registry-based policy finder module that can retrieve policies from a registry collection, where the collection path is configurable using a property value in the entitlement.properties.xml file. All modules are initialized and policies are loaded into memory when the Carbon policy finder is used. Loaded policies are kept as a policy collection where you can use your own implementation to access them. A written policy collection implementation can be registered using the entitlement.properties.xml file. The default implementation uses an in-memory cache and creates an effective policy for a given XACML request. Therefore, the Carbon policy finder always finds effective policies from the policy collection where it is recommended to be kept in-memory. However, if any update in the policy store happens, the Carbon policy finder can be re-initialized automatically by the module that you have written, or you can re-initialize it by using the Web service API (Entitlement Admin Service). Alternatively, you can do it manually using the Identity Server Management Console. When you are writing a new module, you need to consider the following in addition to policy retrieving and re-initializing. Policy ordering - The order which policies are evaluated. Policy combining algorithm Note There are Policy Combining Algorithms which are used by Policy Sets and Rule Combining Algorithms which are used by Policies. Each of the algorithms mentioned below has its Policy Combining algorithm and its Rule Combining algorithms as follows: Standard combining algorithms defined in XACML 3.0: urn:oasis:names xacml:3.0:rule-combining-algorithm:deny-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:deny-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:permit-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:permit-overrides urn:oasis:names xacml:1.0:rule-combining-algorithm:first-applicable urn:oasis:names xacml:1.0:policy-combining-algorithm:first-applicable urn:oasis:names xacml:1.0:policy-combining-algorithm:only-one-applicable urn:oasis:names xacml:3.0:rule-combining-algorithm:ordered-deny-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:ordered-deny-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:ordered-permit-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:ordered-permit-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names xacml:3.0:policy-combining-algorithm:permit-unless-deny These algorithms are explained in detail as follows, Deny Overrides: This combining algorithm combines decisions in such a way that if any decision is a Deny, then that decision wins. Deny overrides is one of the safest combining algorithms since it favors a Deny decision. However, if none of the children return a Deny decision, then the combining algorithm will never produce a Deny. Permit Overrides: This combining algorithm combines decisions in such a way that if any decision is a Permit, then that decision wins. The permit overrides combining algorithm can be interesting when: At least one child must return a Permit for access to be granted overall regardless of restrictions. One wants to return all the reasons why access is being denied. This is what one could call a \u201cgreedy deny overrides\u201d.Forinstanceifthe reason for not being able to view a resource is that(a) you are not the owner and (b) you are in the wrong department, then we could rework the previous example as follows. When any of the deny reason triggers, the response would be denied with all the applicable reasons for access being denied: Policy Set (deny overrides): role==manager AND action==view AND resourceType==resource - Policy 1 (permit overrides) - Rule 1: deny if resourceOwner != userId + Advice(\u201cyou are not the owner of the resource\u201d) - Rule 2: deny if rsourceDepartment != userDepartment+ Advice(\u201cyou are not in the same department as the resource) - Policy 2 - Rule 1: permit First Applicable: This combining algorithm combines decisions in such a way that the final decision returned is the first one produced either of Permit or Deny.** ** First applicable is useful to shortcut policy evaluation. For instance, if a policy set contains a long series of not applicable policies and one applicable policy which returns either of Permit or Deny, then if that policy comes first and does produce Permit or Deny, the PDP will stop there and not process the other siblings. Deny Unless Permit | Permit Unless Deny: In XACML there are 4 possible decisions: Permit, Deny, NotApplicable, and Indeterminate. Sometimes, it is desirable to hide the NotApplicable and Indeterminate decisions to only allow for Permit or Deny. It makes the PEP logic potentially simpler. Only One Applicable: This combining algorithm exists only for policy sets to combine policy sets and policies. It cannot be used to combine rules. With this combining algorithm, in order for either of a Permit or Deny to be returned, then only one of the children must produce a valid decision \u2013 whether Deny or Permit. Ordered Deny Overrides | Ordered Permit Overrides: The ordered combining algorithms combine decisions in the same way as their (unordered) cousins. In, addition they bring the guarantee that policies, policy sets, and rules are considered in the order in which they are defined. The need to define an ordered combining algorithm stems from the fact the XACML specification does not specify whether order matters in the deny-overrides and permit-overrides combining algorithms. How to retrieve referenced policies Carbon Attribute Finder This module helps to find the missing attribute for a given XACML request. The following is the high-level diagram for both the Carbon attribute and resource finders. {width=\"750\"} Any number of PIP attribute finder modules can be plugged with the Carbon attribute finder. You need to implement the PIPAttributeFinder interface to write a new module and register it using the entitlement.properties configuration file. By default, WSO2 Identity Server is shipped with a DefaultAttributeFinder that communicates with the underlying user store of the Identity Server. The default user store of the Identity Server is ApacheDS where it can be changed using user-mgt.xml file. See Configuring the Realm for more information. All modules would be initialized and supported attribute Ids are retrieved for each module. During runtime, the Carbon attribute finder checks for the support attribute Id and hands it over to the proper module to handle. A caching machine is used by the Carbon attribute finder for caching the findings or the attribute finder module itself can handle it. Carbon Resource Finder This is used to retrieve children or descendant resources of a given root level resource value. Basically, it is used to fulfill the requirement of a multiple decision profile. The implementation is same as the PIP attribute finder module. By default, WSO2 Identity Server is shipped with DefaultResourceFinder (which is the implementation of PIPResourceFinder) that communicates with Carbon registry resources. XACML policy language structure and syntax In order to render an authorization decision, it is possible to combine the two separate policies to form the single policy applicable to the request. XACML defines three top-level policy elements: - Element that contains a boolean expression that can be evaluated in isolation, but that is not intended to be accessed in isolation by a PDP. So, it is not intended to form the basis of an authorization decision by itself. It is intended to exist in isolation only within an XACML PAP, where it may form the basic unit of management. - Element that contains a set of elements and a specified procedure for combining the results of their evaluation. It is the basic unit of policy used by the PDP, and so it is intended to form the basis of an authorization decision. - Element that contains a set of or other elements and a specified procedure for combining the results of their evaluation. It is the standard means for combining separate policies into a single combined policy. As XACML is used in Attribute-based Access Controlling, in XACML all the attributes are categorized into the following four main categories: But from XACML 3.0, custom categories are also supported. Subject Resource Action Environment A Rule is the most elementary unit of policy. It may exist in isolation only within one of the major actors of the XACML domain. The main components of a Rule are as follows: - This defines the set of requests to which the rule is intended to apply in the form of a logical expression on attributes in the request. - The effect of the rule indicates the rule-writer's intended consequence of a \"True\" evaluation of the rule. Two values are allowed: \"Permit\" and \"Deny\". - A Boolean expression that refines the applicability of the rule beyond the predicates implied by its target. Therefore, it may be absent. - Obligation expressions may be added by the writer of the policy. When a PDP evaluates a policy containing obligation expressions, it evaluates the obligation expressions into obligations and returns certain of those obligations to the PEP in the response context. AttributeSelector - This allows the policy to specify an attribute with given identifier, category and data type. The AttributeSelector on the other hand, provides a mean to lookup the value of attributes using a XPath query by specifying the data type and XPath expression. Attribute selectors are then executed against the XML content that may have been sent along in the initial XACML request. A sample XACML 3.0 policy is as follows: Policy xmlns= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 PolicyId= samplePolicy RuleCombiningAlgId= urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-overrides Version= 1.0 Target AnyOf AllOf Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string read /AttributeValue AttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action DataType= http://www.w3.org/2001/XMLSchema#string MustBePresent= true / /Match /AllOf /AnyOf /Target Rule Effect= Permit RuleId= permit / /Policy Improvements in XACML 3.0 The XACML 3.0 core specification highlights the following main changes in comparison with XACML 2.0. Custom attribute categories Custom attribute categories can be defined with XACML 3.0. However, in XACML 2.0, attributes have been organized into subject, resource, environment or action. For instance, lets's say that you want to create an attribute category called \u201cfoo\u201d in your policy and request. You can do it with XACML 3.0 easily. According to the XACML 3.0 policy schema, the category of XACML element is identified by a XML attribute called \u201c Category \u201d. In XACML 2.0 Policy, you can define the attribute designator element as follows, However, it must be a pre-defined category such as subject, resource, environment or action. ResourceAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType = http://www.w3.org/2001/XMLSchema#string / In a XACML 3.0 Policy, you can define it as follows. Category can be anything as it is defined as an attribute of the AttributeDesignator element. AttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id Category = resource DataType = http://www.w3.org/2001/XMLSchema#string / Improvements in Obligation In general, obligations can have the following: An Obligation has an identifier, which is used to distinguish different types of obligations An Obligation can have arguments Obligations apply to Permit (or Deny) decisions only A PDP will return, as part of a Permit or Deny response, a (possibly empty) subset of the obligations that appear in the policy. There are several improvements with Obligations in XACML 3.0 when compared to 2.0. One of the main improvements is the introduction of Obligation Expressions . This adds dynamic expressions into the obligation statements. For a more in-depth understanding, see the following example: Let's assume that you want to do following with the Obligation: \u201cOn deny, inform the PEP to send an email to the user\u201d. In XACML 2.0, you need to define the obligation element with the user email statically. Obligation ObligationId = send-email FulfillOn = Deny AttributeAssignment AttributeId = email DataType = http://www.w3.org/2001/XMLSchema#string user @foo.com / AttributeAssignment / Obligation However, the user may not be same for each XACML request that is evaluated. Therefore it is not possible to configure the email statically in the Obligation element. Obligation can only inform PEP to send an email to user (it lets the PEP figure out the value of user\u2019s email). Obligation ObligationId = send-email FulfillOn = Deny AttributeAssignment AttributeId = text DataType = http://www.w3.org/2001/XMLSchema#string please send email to user / AttributeAssignment / Obligation However, in XACML 3.0, the email of each user can be retrieved using PIP in dynamically as we can define an expression element inside the ObligationExpression . Therefore, obligation can inform PEP to send an email to address. ObligationExpression ObligationId = send-email FulfillOn = Deny AttributeAssignmentExpression AttributeId = email DataType = http://www.w3.org/2001/XMLSchema#string AttributeDesignator AttributeId = email Category = urn:oasis:names:tc:xacml:1.0:subject-category:access-subject DataType = http://www.w3.org/2001/XMLSchema#string MustBePresent = false / / AttributeAssignmentExpression / ObligationExpression In XACML 2.0, obligations can only be added to policies and policy sets. However, with XACML 3.0, rules can also contain obligations. At the root of all XACML policies, is a policy or a policy set. A policy represents a single access control policy, expressed through a set of rules. A policy set is a container that can hold other policies or policy sets, as well as references to policies found in remote locations. Introducing Advice Advice is a newly introduced feature with XACML 3.0. Advice is similar to obligations and it shares much of its syntax. The difference is contractual: the PEP can disregard any advice it receives. PEPs do not have to comply with advice statements; PEPs can consider or discard the statement. A common scenario is to explain why something was denied: \u201cUser bob is denied because he does not have a valid email\u201d. The XACML specification says that any advice returned with a decision can be safely ignored by compliant PEPs. This means that PEPs should work as described in the previous section, regardless of what the PEP does with the advice it may receive. For example, a PEP must allow access if it receives a Permit decision with no obligations, regardless of any advice in the decision. Improvements in Target Since it is possible to define custom attribute categories, there are improvements in some related elements in the XACML 3.0 policy, when compared to 2.0. With XACML 3.0, the Target element can be used to define more complex authorization logic within itself when compared with 2.0. In XACML 2.0, the Target element contains the OR and AND relationship between the same category. However, in XACML 3.0, AllOf and AnyOf elements have been introduced to Target element. That clearly helps to define the OR and AND relationship between different categories. As an example, let's look at a Target element. In XACML 2.0, we have an AND relationship between foo1 and foo2 resources and an OR relationship between bar1 and bar2 actions. However, we cannot create an OR relationship between a foo1 resource and bar1 action. so we cannot define something such as \u201cTarget would be matched when Bob can access the foo resource or do a bar action\u201d by using the Target element. Target Resources Resource ResourceMatch MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string foo1 / AttributeValue ResourceAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType = http://www.w3.org/2001/XMLSchema#string / / ResourceMatch ResourceMatch MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string foo2 / AttributeValue ResourceAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType = http://www.w3.org/2001/XMLSchema#string / / ResourceMatch / Resource / Resources Actions Action ActionMatch MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string bar1 / AttributeValue ActionAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:action:action-id DataType = http://www.w3.org/2001/XMLSchema#string / / ActionMatch / Action Action ActionMatch MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string bar2 / AttributeValue ActionAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:action:action-id DataType = http://www.w3.org/2001/XMLSchema#string / / ActionMatch / Action / Actions / Target XACML 3.0 has an AND relationship between \u201c foo \u201d resource and \u201c bar1 \u2033 role and an OR relationship between \u201c bar2 \u2033 action. So we cannot define something as \u201cTarget would be matched, when Bob can access foo resource and do bar1 action or do bar2 action\u201d. Target AnyOf AllOf Match MatchId = urn:oasis:names:tc:xacml:1.0:function:string-regexp-match AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string foo / AttributeValue AttributeDesignator MustBePresent = false Category = urn:oasis:names:tc:xacml:3.0:attribute-category:resource AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType = http://www.w3.org/2001/XMLSchema#string / / Match Match MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string bar1 / AttributeValue AttributeDesignator MustBePresent = false Category = urn:oasis:names:tc:xacml:3.0:attribute-category:action AttributeId = urn:oasis:names:tc:xacml:1.0:action:action-id DataType = http://www.w3.org/2001/XMLSchema#string / / Match / AllOf AllOf Match MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string bar2 / AttributeValue AttributeDesignator MustBePresent = false Category = urn:oasis:names:tc:xacml:3.0:attribute-category:action AttributeId = urn:oasis:names:tc:xacml:1.0:action:action-id DataType = http://www.w3.org/2001/XMLSchema#string / / Match / AllOf / AnyOf / Target More Functions and Algorithms XACML3 has introduced new String functions such as: urn : oasis : names : tc : xacml : 3.0 : function : string - starts - with urn : oasis : names : tc : xacml : 3.0 : function : string - ends - with urn : oasis : names : tc : xacml : 3.0 : function : string - contains urn : oasis : names : tc : xacml : 3.0 : function : string - substring Some improvements to other functions such as: urn : oasis : names : tc : xacml : 3.0 : function : dayTimeDuration - equal urn : oasis : names : tc : xacml : 3.0 : function : yearMonthDuration - equal urn : oasis : names : tc : xacml : 3.0 : function : dateTime - add - dayTimeDuration Also improvements to existing combine algorithms (deny-overrides, permit-overrides, ordered-deny-overrides and ordered-permit-overrides) and new two combine algorithms for policy and rule combining. urn : oasis : names : tc : xacml : 3.0 : rule - combining - algorithm : deny - unless - permit urn : oasis : names : tc : xacml : 3.0 : policy - combining - algorithm : deny - unless - permit urn : oasis : names : tc : xacml : 3.0 : rule - combining - algorithm : permit - unless - deny urn : oasis : names : tc : xacml : 3.0 : policy - combining - algorithm : permit - unless - deny Improvements in XPath New XPath data type is introduced with XACML 3.0. In XACML 2.0, XPath is defined as a String and cannot define the context that the namespace prefix is going to resolve. Also XPath based multiple decisions scheme is introduced with XACML 3.0. Improvement in XACML Request and Response As it is possible to define custom attribute categories, many types of attribute categories can be in the XACML 3.0 request. XACML 2.0 request can contain only subject, resource, environment or action categories. The XACML Response can contain additional data such as: Request attributes that are defined in the XACML response. Applicable policy ids for a given XACML request are defined in the XACML response. XACML 3.0 Multiple Decision Profile This is a useful profile that allows you to request more than one access control decision in a single XACML request context, and also allows you to request a single combined decision based on multiple individual decisions. The XACML 3.0 Multiple Decision Profile (MDP) is particularly useful in scenarios where the PEP needs to request decisions for multiple requests in one XACML request, and provides a considerable improvement in performance between the PEP and the PDP in such scenarios. For a set of tutorials that demonstrate how to work with XACML MDP requests in WSO2 Identity Server, see Working with XACML Multiple Decision Profile Requests. XACML 3.0 JSON Profile This is a new profile that provides a standardized interface between the PEP and the PDP using JSON. The decision request and response structure is specified in the core XACML specification. With the introduction of the XACML 3.0 JSON profile , WSO2 Identity Server supports the JSON format in addition to the default XML format with regard to XACML 3.0 requests and responses. WSO2 Identity Server also supports working with XACML MDP requests and responses in JSON format. Following are some of the key points to keep in mind when you work with XACML 3.0 JSON requests and responses via WSO2 Identity Server: Certain parts of JSON requests and responses have default values to avoid bloating. For example, the default value of the data-type of an attribute should be string . The name of the XACML XML attribute element has changed to the category object in JSON so that it is possible to call the parent element. The AttributeValue element in the XML representation no longer exists. Instead a value property is introduced to the attribute object. The AdviceId and the ObligationId attributes of Advice/ and Obligation/ XML elements are renamed to Id in JSON. The order of objects and values in the serialized form (JSON) does not matter in XACML. You can use the short name of identifiers instead of the URI. Following are the supported identifier URIs and the short name for each: Identifier URI Short name urn:oasis:names xacml:3.0:attribute-category:resource Resource urn:oasis:names xacml:3.0:attribute-category:action Action urn:oasis:names xacml:3.0:attribute-category:environment Environment urn:oasis:names xacml:3.0:attribute-category:access-subject AccessSubject urn:oasis:names xacml:3.0:attribute-category:recipient-subject RecipientSubject urn:oasis:names xacml:3.0:attribute-category:intermediary-subject IntermediarySubject urn:oasis:names xacml:3.0:attribute-category:codebase Codebase urn:oasis:names xacml:3.0:attribute-category:requesting-machine RequestingMachine The JSON format supports the fully qualified XACML data-type URI, and also supports the short name of the data-type. XACML data type identifier JSON shorthand type code Mapping/inference rule http://www.w3.org/2001/XMLSchema#string string JSON \"String\" http://www.w3.org/2001/XMLSchema#boolean boolean JSON \"Boolean\" http://www.w3.org/2001/XMLSchema#integer integer JSON \"Number\" without a fractional portion, and within the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#double double JSON \"Number\" with a fractional portion, or out of the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#time time None. Inference must fail. http://www.w3.org/2001/XMLSchema#date date None. Inference must fail. http://www.w3.org/2001/XMLSchema#dateTime dateTime None. Inference must fail. http://www.w3.org/2001/XMLSchema #dayTimeDuration dayTimeDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema #yearMonthDuration yearMonthDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema #anyURI anyURI None. Inference must fail. http://www.w3.org/2001/XMLSchema #hexBinary hexBinary None. Inference must fail. http://www.w3.org/2001/XMLSchema #base64Binary base64Binary None. Inference must fail. urn:oasis:names xacml:1.0:data-type:rfc822Name rfc822Name None. Inference must fail. urn:oasis:names xacml:1.0:data-type:x500Name x500Name None. Inference must fail. urn:oasis:names xacml:1.0:data-type:ipAddress ipAddress None. Inference must fail. urn:oasis:names xacml:1.0:data-type:dnsName dnsName None. Inference must fail. urn:oasis:names xacml:1.0:data-type:xpathExpression xpathExpression None. Inference must fail. xpathExpression data-type values are represented as JSON objects, and each object contains the following properties: Attribute Type Required Default value XPathCategory URI Yes. You can use the short names defined for identifier URIs as values here. None Namespaces Array of namespace declarations No None XPath String Yes None The namespaces property should contain the following properties: Attribute Type Required Default value Prefix String No None Namespace URI Yes None Following is a sample JSON attribute format that contains the fully qualified XACML data-type URI: { Attribute : { AttributeId : urn:oasis:names:tc:xacml:3.0:content-selector , DataType : xpathExpression , Value : { XPathCategory : urn:oasis:names:tc:xacml:3.0:attribute-category:resource , Namespaces : [{ Namespace : urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 }, { Prefix : md , Namespace : urn:example:med:schemas:record }], XPath : md:record/md:patient/md:patientDoB } } } The MultiRequests object is optional in the JSON representation of XACML. The purpose of the MultiRequests object is to support the XACML multiple decision profile. The JSON attribute object contains an array of attribute objects. The attribute object contains the following properties: Property name Type Required Default value AttributeId URI Yes None. The identifier used in the XML representation of a XACML attribute will be used in its JSON representation Value Either string, boolean, number (this maps to either a XACML integer or double as defined in supported data types), object, array of strings, array of boolean, Array of number, array of object, or a mixed array of string and number where the string values represents a numerical value. Yes None. Issuer String No Null Data Type URI No The data type value can be omitted in the JSON representation. The default value is http://www.w3.org/2001/XMLSchema#string . IncludeInResult Boolean No False The results of the JSON request is represented by the decision object in the form of a JSON Object. This can have following properties: Property name Type Required Default value Decision String Yes. Possible values are: Permit, Deny, NotApplicable, Indeterminate None. The results can have the status , obligations , associatedAdvice , category , and policyIdentifierList , which are optional. Following is a sample JSON request that you can try out with WSO2 Identity Server: { Request : { AccessSubject : { Attribute : [ { AttributeId : subject-id , Value : sam , DataType : string , IncludeInResult : true } ] }, Resource : { Attribute : [ { AttributeId : resource-id , Value : index.jsp , DataType : string , IncludeInResult : true } ] }, Action : { Attribute : [{ AttributeId : action-id , Value : modify-welcome , DataType : string , IncludeInResult : true } ] } } } Following is a sample XACML JSON response that you will get for the above request: { Response : [ { Decision : Deny , Status : { StatusCode : { Value : urn:oasis:names:tc:xacml:1.0:status:ok } }, AccessSubject : { Attribute : [ { AttributeId : subject-id , Value : dinali , IncludeInResult : true , DataType : string } ] }, Resource : { Attribute : [ { AttributeId : resource-id , Value : index.jsp , IncludeInResult : true , DataType : string } ] }, Action : { Attribute : [ { AttributeId : action-id , Value : modify-welcome , IncludeInResult : true , DataType : string } ] } } ] } For a tutorial that demonstrate how WSO2 IS supports fine-grained authorization using XACML requests in JSON format, see Fine-grained Authorization using XACML Requests in JSON Format . Administrative Delegation Profile This is also a new profile that comes with XACML 3.0. This allows you to define policies about who can write policies about what. For example, \u201cBob may issue a policy but only about resources in department X\u201d. XACML 2.0 and XACML 3.0 samples The biggest difference between XACML 2.0 and XACML 3.0 for your client app is that the structure of the attributes in the authentication request has changed significantly in XACML 3.0. In XACML 2.0, attributes were organized into subject, resource, environment, or action categories using XML element tags: Request xmlns= urn:oasis:names:tc:xacml:2.0:context:schema:os xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= urn:oasis:names:tc:xacml:2.0:context:schema:os access_control-xacml-2.0-context-schema-os.xsd Subject Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:subject:subject-id DataType= http://www.w3.org/2001/XMLSchema#string AttributeValue Julius Hibbert /AttributeValue /Attribute /Subject Resource Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#anyURI AttributeValue http://medico.com/record/patient/BartSimpson /AttributeValue /Attribute /Resource Action Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string AttributeValue read /AttributeValue /Attribute /Action Environment/ /Request In XACML 3.0, these categories are indicated using XML attributes instead of XML element tags: ?xml version= 1.0 encoding= utf-8 ? Request xsi:schemaLocation= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 http://docs.oasis-open.org/xacml/3.0/xacml-core-v3-schema-wd-17.xsd ReturnPolicyIdList= false CombinedDecision= false xmlns= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance Attributes Category= urn:oasis:names:tc:xacml:1.0:subject-category:access-subject Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:subject:subject-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string Julius Hibbert /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:resource Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#anyURI http://medico.com/record/patient/BartSimpson /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string read /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:environment / /Request The element in XACML 2.0 becomes in XACML 3.0, for example. This is the same for the resource, environment, and action categories. Attachments: {width=\"8\" height=\"8\"} Untitled Diagram.png (image/png) {width=\"8\" height=\"8\"} 10.png (image/png) {width=\"8\" height=\"8\"} image2015-6-16 14:35:7.png (image/png) {width=\"8\" height=\"8\"} image2015-6-16 14:43:33.png (image/png) {width=\"8\" height=\"8\"} image2015-6-16 14:51:40.png (image/png) {width=\"8\" height=\"8\"} image2015-6-16 14:59:29.png (image/png)","title":"Access_Control and Entitlement Management"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#access-control-and-entitlement-management","text":"Today, enterprise applications seek ways of enforcing security that allows the right people to access the right resources with restrictions enforced by enterprise policies. Identity and entitlement management systems, as a whole, attempt to address these security considerations. These systems help enterprise architects and developers in their application requirement implementations and try to significantly ease the burden of security-related implementations. These identity and entitlement management systems are governed by industry standard specifications, hence supporting security requirements for heterogeneous applications becomes easy. Click here for more information on Access control. This topic consists of the following sections: Types of access control | Introducing XACML | Why XACML | XACML system architecture | XACML terminology | XACML engine architecture | XACML policy language structure and syntax | Improvements in XACML 3.0 | XACML 2.0 and XACML 3.0 samples","title":"Access Control and Entitlement Management"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#types-of-access-control","text":"{width=\"320\"} The following table describes the various types of access control. Access Control Type Description Access Control Lists Access control lists are the oldest and most basic form of access control. This type was primarily adopted for use in operating systems. This maintains a set of users and operations that can be performed on a resource as a mapping. This is easy to implement due to the use of maps. However, this is not scalable for larger user bases and can become difficult to manage. Role-based Access Control Role-based Access Control (RBAC) is an approach used to restrict access to authorized users based on their role. This is a static permission model which provides access control. It is used by the majority of enterprises with more than 500 users. This access control type is used when all users are categorized into different roles. The roles define the resources that can be accessed by users assigned to that role. This type of access control reduces management overhead. These users and roles can also be externalized using user stores. These roles need to be managed carefully. There can be instances where a user is assigned to multiple roles. This is a subset of ABAC. Static permissions for roles can be given by updating permission tree in WSO2 Identity Server. Click here for information on Configuring roles and permissions. Attribute-based Access Control Attribute-based access control (ABAC) defines a new access control paradigm whereby access rights are granted to users through the use of policies that combine attributes together. Here, authorization happens based on attributes. This access control type addresses the limitations of role-based access control to provide a more fine-grained approach. This can be based on the attributes of the user, the environment, or even the resource itself. This is more flexible when compared with the role-based approach. There is no need to know the user prior to granting access. Policy-based Access Control This type of access control addresses the requirement to have a more uniform access control mechanism. This helps larger enterprises to have uniform access control for the large amount of organizational units. This is helpful when carrying out security audits. This is the most complex form of access control. This involves specifying policies unambiguously using XACML and using authorized attribute sources in the enterprise. Here Policy Based Access Control(PBAC) (also called Rule-based access control) is an extension of ABAC where attributes are used in writing policies.","title":"Types of access control"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#introducing-xacml","text":"XACML (eXtensible Access Control Markup Language) is an XML-based language for access control that has been standardized by the Technical Committee of the OASIS consortium. XACML is popular as a fine grain authorization method among the community. However, there are aspects of XACML that surpasses other policy standards by being a fine-grained authorization mechanism. Although XACML was introduced as a standard by OASIS in 2003, not many organizations that have adopted it yet. This is because most organization's lack of interest in moving towards a XACML based solution for authorization. The following can be some of the reasons for this: Many software designer and developers lack a clear understanding of features, importance, and advantages of XACML. It is comparatively difficult to implement a XACML solution when compared with a typical JDBC or hard-coded authorization system. Performance of XACML-based authorization system may be less than adequate. The complexity of defining and managing XACML policies. However, current market trends indicate that there is some motivation for XACML-based authorization systems. This section includes some architectural and implementation details on XACML with an existing XACML engine. To summarize, XACML describes both an access control policy language, request/response language, and reference architecture. The policy language is used to express access control policies (who can do what, when). The request/response language expresses queries about whether a particular access should be allowed (requests) and describes answers to those queries(responses). The reference architecture proposes a standard for deployment of necessary software modules within an infrastructure to allow efficient enforcement of policies. WSO2 Identity Server uses XACML as a tool for controlling access to applications. Recommended reading For more information on XACML specifications and other related information, see the OASIS website .","title":"Introducing XACML"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#why-xacml","text":"Most of the organizations still use legacy systems with inbuilt authorization logic. Sometimes, one organization contains a large number of information systems and applications that each system or application uses for their own process for authorization. Today, authorization has become more complex because users within organizations and outside need access to shared data and have the need to collaborate efficiently. Therefore, this has been challenging task to manage these legacy systems, custom authorization systems. However, XACML offers a solution to this problem. Most traditional authorization systems mostly have the following features: Authorization logic is hard-coded into the source code. Authorization logic is stored in databases that could only be readable and understandable by the underlying application The following are the some goals that current organizations are looking at from an authorization system. Can business managers (who should determine how access controls would be implemented) define and modify different authorization logic? Can we find new IT technicians to manage these legacy systems? Especially when those who developed the system have left the organization? Can different authorization logic be modified without any source code changes in a dynamic way? Is authorization system capable of evaluating following rule? \u201cX resource can be accessed by the Users who are from example.com domain and whose age is greater than 21 years old\u201d If we are going to implement a new information system with the organization, can we re-use the authorization logic of a legacy system? Can we achieve a fine-grained authorization level without defining a large number of static combinations? Are the authorization systems capable of answering the questions such as: \u201cCan a user, Bob, transfer X amount from Y current account at 1.00pm?\u201c Clearly, the above goals cannot be achieved from a traditional authorization system. However, a XACML-based authorization solution can help to achieve all of these goals, because XACML: is a standard which is ratified by OASIS standards organization. is a policy language implemented using XML which is an industry standard. supports Attribute-based Access Control (ABAC) and evaluation can be done with the additional data retrieved from Policy Information Point (PIP) which is defined by the XACML reference architecture. Note","title":"Why XACML"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#attribute-based-access-controlabac","text":"ABAC is an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together. The policies can use any type of attributes (user attributes, resource attributes, object, environment attributes etc.). This model supports boolean logic, in which rules contain \"IF, THEN\" statements about who is making the request, the resource, and the action. For example: IF the requestor is a manager, THEN allow read/write access to sensitive data. contains reference architecture which is provided to externalize the authorization system. The Policy Decision Point (PDP) offers authorization as a service in your infrastructure. Authorization algorithms can be removed from the application logic and applications can query the PDP via their own Policy Enforcement Points (PEP). provides fine-grained authorization with higher level of abstraction by means of policies and rules. supports dynamic evaluation of policies by using the Policy Information Point (PIP). can publish multiple policies into external PDPs.","title":"Attribute-based Access Control(ABAC)"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#xacml-system-architecture","text":"Policy Decision Point (PDP) evaluates policies against access requests provided by Policy Enforcement Points (PEP). To provide the decisions, PDP may also need to query a Policy Information Point (PIP) to gather descriptive attributes about the user or any other missing attribute in the request. Policy Administration Point (PAP) is used to manage the PDP and PIP functionality. {width=\"800\"}","title":"XACML system architecture"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#xacml-terminology","text":"The XACML reference architecture illustrated above is comprised of the following four 'building blocks'. Policy Enforcement Point (PEP) : The system entity that performs access control by making decision requests and enforcing authorization decisions. This is the entity that sends the XACML request to the Policy Decision Point (PDP) and receives an authorization decision. Policy Decision Point (PDP) : The system entity that evaluates an applicable policy and returns an authorization decision. Policy Information Point (PIP) : The system entity that acts as a source of attribute values. If there are missing attributes in the XACML request that is sent by PEP, PIP would find them for the PDP to evaluate the policy. Policy Administration Point (PAP) : The system entity that creates a policy or policy set and manages them.","title":"XACML terminology"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#xacml-engine-architecture","text":"The WSO2 Identity Server is a major player in the XACML and open source world. The Identity Server supports XACML 3.0, which is based on Balana XACML implementation . As the source code, distribution and documentation are available for free, it is possible to analyze and understand the architecture behind it. You can find source code from here . This section provides some information regarding the architecture of the XACML engine (or the entitlement engine) of the WSO2 Identity Server. The XACML engine of the WSO2 Identity Server has two major components, i.e., PAP and PDP. The section below focuses on Policy Decision Point (PDP). The following diagram represents the component architecture of the PDP. {width=\"750\"} The following provides a more detailed information on the various components available in the PDP architecture. Entitlement Admin Service All PDP configurations are exposed via this API as a Web service which you need to have certain privileges to access. The following functions can be done by calling this API. Invalidating caches Refreshing policy, attribute, resource finder modules Retrieving PDP configurations Includes the function for testing the Test PDP with a given sample request or a sample request with given policies Entitlement Service Actual XACML authorization API is exposed via this API as a Web service. This service supports the following three communication methods with PEP. SOAP-based Web service Thrift binary protocol (this is much faster than SOAP) WS-XACML (This is the standard way but not popular) Balana PDP This is the core of the engine. Balana PDP has been initialized with all the attribute finders, resource finders and policy finder modules that are plugged with WSO2 Identity Server. Balana Test PDP This is same as Balana PDP. However, this instance has been initialized with the PAP policy store. It means, policies that are defined by PAP can be evaluated by using this PDP instance. There is no policy caching or decision caching with this. Therefore, this can only be used for testing your policies in the PAP store. Web service API for Balana Test PDP is exposed via the Entitlement Admin Service with method name \u201cdoTestRequest()\u201d. Carbon Policy Finder This module finds policies from different policy stores to evaluate a XACML request. The following is a high-level diagram of how this works. {width=\"750\"} Any number of policy finder modules can be plugged with the Carbon policy finder. You need to implement the CarbonPolicyFinderModule interface to write a new module and register it using the configuration file called entitlement.properties.xml in IS_HOME /repository/components/features/org.wso2.carbon.identity.xacml.server_5.8.145 directory . By default, WSO2 Identity Server is shipped with a Carbon registry-based policy finder module that can retrieve policies from a registry collection, where the collection path is configurable using a property value in the entitlement.properties.xml file. All modules are initialized and policies are loaded into memory when the Carbon policy finder is used. Loaded policies are kept as a policy collection where you can use your own implementation to access them. A written policy collection implementation can be registered using the entitlement.properties.xml file. The default implementation uses an in-memory cache and creates an effective policy for a given XACML request. Therefore, the Carbon policy finder always finds effective policies from the policy collection where it is recommended to be kept in-memory. However, if any update in the policy store happens, the Carbon policy finder can be re-initialized automatically by the module that you have written, or you can re-initialize it by using the Web service API (Entitlement Admin Service). Alternatively, you can do it manually using the Identity Server Management Console. When you are writing a new module, you need to consider the following in addition to policy retrieving and re-initializing. Policy ordering - The order which policies are evaluated. Policy combining algorithm Note There are Policy Combining Algorithms which are used by Policy Sets and Rule Combining Algorithms which are used by Policies. Each of the algorithms mentioned below has its Policy Combining algorithm and its Rule Combining algorithms as follows: Standard combining algorithms defined in XACML 3.0: urn:oasis:names xacml:3.0:rule-combining-algorithm:deny-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:deny-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:permit-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:permit-overrides urn:oasis:names xacml:1.0:rule-combining-algorithm:first-applicable urn:oasis:names xacml:1.0:policy-combining-algorithm:first-applicable urn:oasis:names xacml:1.0:policy-combining-algorithm:only-one-applicable urn:oasis:names xacml:3.0:rule-combining-algorithm:ordered-deny-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:ordered-deny-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:ordered-permit-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:ordered-permit-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names xacml:3.0:policy-combining-algorithm:permit-unless-deny These algorithms are explained in detail as follows, Deny Overrides: This combining algorithm combines decisions in such a way that if any decision is a Deny, then that decision wins. Deny overrides is one of the safest combining algorithms since it favors a Deny decision. However, if none of the children return a Deny decision, then the combining algorithm will never produce a Deny. Permit Overrides: This combining algorithm combines decisions in such a way that if any decision is a Permit, then that decision wins. The permit overrides combining algorithm can be interesting when: At least one child must return a Permit for access to be granted overall regardless of restrictions. One wants to return all the reasons why access is being denied. This is what one could call a \u201cgreedy deny overrides\u201d.Forinstanceifthe reason for not being able to view a resource is that(a) you are not the owner and (b) you are in the wrong department, then we could rework the previous example as follows. When any of the deny reason triggers, the response would be denied with all the applicable reasons for access being denied: Policy Set (deny overrides): role==manager AND action==view AND resourceType==resource - Policy 1 (permit overrides) - Rule 1: deny if resourceOwner != userId + Advice(\u201cyou are not the owner of the resource\u201d) - Rule 2: deny if rsourceDepartment != userDepartment+ Advice(\u201cyou are not in the same department as the resource) - Policy 2 - Rule 1: permit First Applicable: This combining algorithm combines decisions in such a way that the final decision returned is the first one produced either of Permit or Deny.** ** First applicable is useful to shortcut policy evaluation. For instance, if a policy set contains a long series of not applicable policies and one applicable policy which returns either of Permit or Deny, then if that policy comes first and does produce Permit or Deny, the PDP will stop there and not process the other siblings. Deny Unless Permit | Permit Unless Deny: In XACML there are 4 possible decisions: Permit, Deny, NotApplicable, and Indeterminate. Sometimes, it is desirable to hide the NotApplicable and Indeterminate decisions to only allow for Permit or Deny. It makes the PEP logic potentially simpler. Only One Applicable: This combining algorithm exists only for policy sets to combine policy sets and policies. It cannot be used to combine rules. With this combining algorithm, in order for either of a Permit or Deny to be returned, then only one of the children must produce a valid decision \u2013 whether Deny or Permit. Ordered Deny Overrides | Ordered Permit Overrides: The ordered combining algorithms combine decisions in the same way as their (unordered) cousins. In, addition they bring the guarantee that policies, policy sets, and rules are considered in the order in which they are defined. The need to define an ordered combining algorithm stems from the fact the XACML specification does not specify whether order matters in the deny-overrides and permit-overrides combining algorithms. How to retrieve referenced policies Carbon Attribute Finder This module helps to find the missing attribute for a given XACML request. The following is the high-level diagram for both the Carbon attribute and resource finders. {width=\"750\"} Any number of PIP attribute finder modules can be plugged with the Carbon attribute finder. You need to implement the PIPAttributeFinder interface to write a new module and register it using the entitlement.properties configuration file. By default, WSO2 Identity Server is shipped with a DefaultAttributeFinder that communicates with the underlying user store of the Identity Server. The default user store of the Identity Server is ApacheDS where it can be changed using user-mgt.xml file. See Configuring the Realm for more information. All modules would be initialized and supported attribute Ids are retrieved for each module. During runtime, the Carbon attribute finder checks for the support attribute Id and hands it over to the proper module to handle. A caching machine is used by the Carbon attribute finder for caching the findings or the attribute finder module itself can handle it. Carbon Resource Finder This is used to retrieve children or descendant resources of a given root level resource value. Basically, it is used to fulfill the requirement of a multiple decision profile. The implementation is same as the PIP attribute finder module. By default, WSO2 Identity Server is shipped with DefaultResourceFinder (which is the implementation of PIPResourceFinder) that communicates with Carbon registry resources.","title":"XACML engine architecture"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#xacml-policy-language-structure-and-syntax","text":"In order to render an authorization decision, it is possible to combine the two separate policies to form the single policy applicable to the request. XACML defines three top-level policy elements: - Element that contains a boolean expression that can be evaluated in isolation, but that is not intended to be accessed in isolation by a PDP. So, it is not intended to form the basis of an authorization decision by itself. It is intended to exist in isolation only within an XACML PAP, where it may form the basic unit of management. - Element that contains a set of elements and a specified procedure for combining the results of their evaluation. It is the basic unit of policy used by the PDP, and so it is intended to form the basis of an authorization decision. - Element that contains a set of or other elements and a specified procedure for combining the results of their evaluation. It is the standard means for combining separate policies into a single combined policy. As XACML is used in Attribute-based Access Controlling, in XACML all the attributes are categorized into the following four main categories: But from XACML 3.0, custom categories are also supported. Subject Resource Action Environment A Rule is the most elementary unit of policy. It may exist in isolation only within one of the major actors of the XACML domain. The main components of a Rule are as follows: - This defines the set of requests to which the rule is intended to apply in the form of a logical expression on attributes in the request. - The effect of the rule indicates the rule-writer's intended consequence of a \"True\" evaluation of the rule. Two values are allowed: \"Permit\" and \"Deny\". - A Boolean expression that refines the applicability of the rule beyond the predicates implied by its target. Therefore, it may be absent. - Obligation expressions may be added by the writer of the policy. When a PDP evaluates a policy containing obligation expressions, it evaluates the obligation expressions into obligations and returns certain of those obligations to the PEP in the response context. AttributeSelector - This allows the policy to specify an attribute with given identifier, category and data type. The AttributeSelector on the other hand, provides a mean to lookup the value of attributes using a XPath query by specifying the data type and XPath expression. Attribute selectors are then executed against the XML content that may have been sent along in the initial XACML request. A sample XACML 3.0 policy is as follows: Policy xmlns= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 PolicyId= samplePolicy RuleCombiningAlgId= urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-overrides Version= 1.0 Target AnyOf AllOf Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string read /AttributeValue AttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action DataType= http://www.w3.org/2001/XMLSchema#string MustBePresent= true / /Match /AllOf /AnyOf /Target Rule Effect= Permit RuleId= permit / /Policy","title":"XACML policy language structure and syntax"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#improvements-in-xacml-30","text":"The XACML 3.0 core specification highlights the following main changes in comparison with XACML 2.0.","title":"Improvements in XACML 3.0"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#custom-attribute-categories","text":"Custom attribute categories can be defined with XACML 3.0. However, in XACML 2.0, attributes have been organized into subject, resource, environment or action. For instance, lets's say that you want to create an attribute category called \u201cfoo\u201d in your policy and request. You can do it with XACML 3.0 easily. According to the XACML 3.0 policy schema, the category of XACML element is identified by a XML attribute called \u201c Category \u201d. In XACML 2.0 Policy, you can define the attribute designator element as follows, However, it must be a pre-defined category such as subject, resource, environment or action. ResourceAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType = http://www.w3.org/2001/XMLSchema#string / In a XACML 3.0 Policy, you can define it as follows. Category can be anything as it is defined as an attribute of the AttributeDesignator element. AttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id Category = resource DataType = http://www.w3.org/2001/XMLSchema#string /","title":"Custom attribute categories"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#improvements-in-obligation","text":"In general, obligations can have the following: An Obligation has an identifier, which is used to distinguish different types of obligations An Obligation can have arguments Obligations apply to Permit (or Deny) decisions only A PDP will return, as part of a Permit or Deny response, a (possibly empty) subset of the obligations that appear in the policy. There are several improvements with Obligations in XACML 3.0 when compared to 2.0. One of the main improvements is the introduction of Obligation Expressions . This adds dynamic expressions into the obligation statements. For a more in-depth understanding, see the following example: Let's assume that you want to do following with the Obligation: \u201cOn deny, inform the PEP to send an email to the user\u201d. In XACML 2.0, you need to define the obligation element with the user email statically. Obligation ObligationId = send-email FulfillOn = Deny AttributeAssignment AttributeId = email DataType = http://www.w3.org/2001/XMLSchema#string user @foo.com / AttributeAssignment / Obligation However, the user may not be same for each XACML request that is evaluated. Therefore it is not possible to configure the email statically in the Obligation element. Obligation can only inform PEP to send an email to user (it lets the PEP figure out the value of user\u2019s email). Obligation ObligationId = send-email FulfillOn = Deny AttributeAssignment AttributeId = text DataType = http://www.w3.org/2001/XMLSchema#string please send email to user / AttributeAssignment / Obligation However, in XACML 3.0, the email of each user can be retrieved using PIP in dynamically as we can define an expression element inside the ObligationExpression . Therefore, obligation can inform PEP to send an email to address. ObligationExpression ObligationId = send-email FulfillOn = Deny AttributeAssignmentExpression AttributeId = email DataType = http://www.w3.org/2001/XMLSchema#string AttributeDesignator AttributeId = email Category = urn:oasis:names:tc:xacml:1.0:subject-category:access-subject DataType = http://www.w3.org/2001/XMLSchema#string MustBePresent = false / / AttributeAssignmentExpression / ObligationExpression In XACML 2.0, obligations can only be added to policies and policy sets. However, with XACML 3.0, rules can also contain obligations. At the root of all XACML policies, is a policy or a policy set. A policy represents a single access control policy, expressed through a set of rules. A policy set is a container that can hold other policies or policy sets, as well as references to policies found in remote locations.","title":"Improvements in\u00a0Obligation"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#introducing-advice","text":"Advice is a newly introduced feature with XACML 3.0. Advice is similar to obligations and it shares much of its syntax. The difference is contractual: the PEP can disregard any advice it receives. PEPs do not have to comply with advice statements; PEPs can consider or discard the statement. A common scenario is to explain why something was denied: \u201cUser bob is denied because he does not have a valid email\u201d. The XACML specification says that any advice returned with a decision can be safely ignored by compliant PEPs. This means that PEPs should work as described in the previous section, regardless of what the PEP does with the advice it may receive. For example, a PEP must allow access if it receives a Permit decision with no obligations, regardless of any advice in the decision.","title":"Introducing\u00a0Advice"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#improvements-in-target","text":"Since it is possible to define custom attribute categories, there are improvements in some related elements in the XACML 3.0 policy, when compared to 2.0. With XACML 3.0, the Target element can be used to define more complex authorization logic within itself when compared with 2.0. In XACML 2.0, the Target element contains the OR and AND relationship between the same category. However, in XACML 3.0, AllOf and AnyOf elements have been introduced to Target element. That clearly helps to define the OR and AND relationship between different categories. As an example, let's look at a Target element. In XACML 2.0, we have an AND relationship between foo1 and foo2 resources and an OR relationship between bar1 and bar2 actions. However, we cannot create an OR relationship between a foo1 resource and bar1 action. so we cannot define something such as \u201cTarget would be matched when Bob can access the foo resource or do a bar action\u201d by using the Target element. Target Resources Resource ResourceMatch MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string foo1 / AttributeValue ResourceAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType = http://www.w3.org/2001/XMLSchema#string / / ResourceMatch ResourceMatch MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string foo2 / AttributeValue ResourceAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType = http://www.w3.org/2001/XMLSchema#string / / ResourceMatch / Resource / Resources Actions Action ActionMatch MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string bar1 / AttributeValue ActionAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:action:action-id DataType = http://www.w3.org/2001/XMLSchema#string / / ActionMatch / Action Action ActionMatch MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string bar2 / AttributeValue ActionAttributeDesignator AttributeId = urn:oasis:names:tc:xacml:1.0:action:action-id DataType = http://www.w3.org/2001/XMLSchema#string / / ActionMatch / Action / Actions / Target XACML 3.0 has an AND relationship between \u201c foo \u201d resource and \u201c bar1 \u2033 role and an OR relationship between \u201c bar2 \u2033 action. So we cannot define something as \u201cTarget would be matched, when Bob can access foo resource and do bar1 action or do bar2 action\u201d. Target AnyOf AllOf Match MatchId = urn:oasis:names:tc:xacml:1.0:function:string-regexp-match AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string foo / AttributeValue AttributeDesignator MustBePresent = false Category = urn:oasis:names:tc:xacml:3.0:attribute-category:resource AttributeId = urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType = http://www.w3.org/2001/XMLSchema#string / / Match Match MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string bar1 / AttributeValue AttributeDesignator MustBePresent = false Category = urn:oasis:names:tc:xacml:3.0:attribute-category:action AttributeId = urn:oasis:names:tc:xacml:1.0:action:action-id DataType = http://www.w3.org/2001/XMLSchema#string / / Match / AllOf AllOf Match MatchId = urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType = http://www.w3.org/2001/XMLSchema#string bar2 / AttributeValue AttributeDesignator MustBePresent = false Category = urn:oasis:names:tc:xacml:3.0:attribute-category:action AttributeId = urn:oasis:names:tc:xacml:1.0:action:action-id DataType = http://www.w3.org/2001/XMLSchema#string / / Match / AllOf / AnyOf / Target","title":"Improvements in\u00a0Target"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#more-functions-and-algorithms","text":"XACML3 has introduced new String functions such as: urn : oasis : names : tc : xacml : 3.0 : function : string - starts - with urn : oasis : names : tc : xacml : 3.0 : function : string - ends - with urn : oasis : names : tc : xacml : 3.0 : function : string - contains urn : oasis : names : tc : xacml : 3.0 : function : string - substring Some improvements to other functions such as: urn : oasis : names : tc : xacml : 3.0 : function : dayTimeDuration - equal urn : oasis : names : tc : xacml : 3.0 : function : yearMonthDuration - equal urn : oasis : names : tc : xacml : 3.0 : function : dateTime - add - dayTimeDuration Also improvements to existing combine algorithms (deny-overrides, permit-overrides, ordered-deny-overrides and ordered-permit-overrides) and new two combine algorithms for policy and rule combining. urn : oasis : names : tc : xacml : 3.0 : rule - combining - algorithm : deny - unless - permit urn : oasis : names : tc : xacml : 3.0 : policy - combining - algorithm : deny - unless - permit urn : oasis : names : tc : xacml : 3.0 : rule - combining - algorithm : permit - unless - deny urn : oasis : names : tc : xacml : 3.0 : policy - combining - algorithm : permit - unless - deny","title":"More Functions and Algorithms"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#improvements-in-xpath","text":"New XPath data type is introduced with XACML 3.0. In XACML 2.0, XPath is defined as a String and cannot define the context that the namespace prefix is going to resolve. Also XPath based multiple decisions scheme is introduced with XACML 3.0.","title":"Improvements in XPath"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#improvement-in-xacml-request-and-response","text":"As it is possible to define custom attribute categories, many types of attribute categories can be in the XACML 3.0 request. XACML 2.0 request can contain only subject, resource, environment or action categories. The XACML Response can contain additional data such as: Request attributes that are defined in the XACML response. Applicable policy ids for a given XACML request are defined in the XACML response.","title":"Improvement in XACML Request and Response"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#xacml-30-multiple-decision-profile","text":"This is a useful profile that allows you to request more than one access control decision in a single XACML request context, and also allows you to request a single combined decision based on multiple individual decisions. The XACML 3.0 Multiple Decision Profile (MDP) is particularly useful in scenarios where the PEP needs to request decisions for multiple requests in one XACML request, and provides a considerable improvement in performance between the PEP and the PDP in such scenarios. For a set of tutorials that demonstrate how to work with XACML MDP requests in WSO2 Identity Server, see Working with XACML Multiple Decision Profile Requests.","title":"XACML 3.0 Multiple Decision Profile"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#xacml-30-json-profile","text":"This is a new profile that provides a standardized interface between the PEP and the PDP using JSON. The decision request and response structure is specified in the core XACML specification. With the introduction of the XACML 3.0 JSON profile , WSO2 Identity Server supports the JSON format in addition to the default XML format with regard to XACML 3.0 requests and responses. WSO2 Identity Server also supports working with XACML MDP requests and responses in JSON format. Following are some of the key points to keep in mind when you work with XACML 3.0 JSON requests and responses via WSO2 Identity Server: Certain parts of JSON requests and responses have default values to avoid bloating. For example, the default value of the data-type of an attribute should be string . The name of the XACML XML attribute element has changed to the category object in JSON so that it is possible to call the parent element. The AttributeValue element in the XML representation no longer exists. Instead a value property is introduced to the attribute object. The AdviceId and the ObligationId attributes of Advice/ and Obligation/ XML elements are renamed to Id in JSON. The order of objects and values in the serialized form (JSON) does not matter in XACML. You can use the short name of identifiers instead of the URI. Following are the supported identifier URIs and the short name for each: Identifier URI Short name urn:oasis:names xacml:3.0:attribute-category:resource Resource urn:oasis:names xacml:3.0:attribute-category:action Action urn:oasis:names xacml:3.0:attribute-category:environment Environment urn:oasis:names xacml:3.0:attribute-category:access-subject AccessSubject urn:oasis:names xacml:3.0:attribute-category:recipient-subject RecipientSubject urn:oasis:names xacml:3.0:attribute-category:intermediary-subject IntermediarySubject urn:oasis:names xacml:3.0:attribute-category:codebase Codebase urn:oasis:names xacml:3.0:attribute-category:requesting-machine RequestingMachine The JSON format supports the fully qualified XACML data-type URI, and also supports the short name of the data-type. XACML data type identifier JSON shorthand type code Mapping/inference rule http://www.w3.org/2001/XMLSchema#string string JSON \"String\" http://www.w3.org/2001/XMLSchema#boolean boolean JSON \"Boolean\" http://www.w3.org/2001/XMLSchema#integer integer JSON \"Number\" without a fractional portion, and within the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#double double JSON \"Number\" with a fractional portion, or out of the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#time time None. Inference must fail. http://www.w3.org/2001/XMLSchema#date date None. Inference must fail. http://www.w3.org/2001/XMLSchema#dateTime dateTime None. Inference must fail. http://www.w3.org/2001/XMLSchema #dayTimeDuration dayTimeDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema #yearMonthDuration yearMonthDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema #anyURI anyURI None. Inference must fail. http://www.w3.org/2001/XMLSchema #hexBinary hexBinary None. Inference must fail. http://www.w3.org/2001/XMLSchema #base64Binary base64Binary None. Inference must fail. urn:oasis:names xacml:1.0:data-type:rfc822Name rfc822Name None. Inference must fail. urn:oasis:names xacml:1.0:data-type:x500Name x500Name None. Inference must fail. urn:oasis:names xacml:1.0:data-type:ipAddress ipAddress None. Inference must fail. urn:oasis:names xacml:1.0:data-type:dnsName dnsName None. Inference must fail. urn:oasis:names xacml:1.0:data-type:xpathExpression xpathExpression None. Inference must fail. xpathExpression data-type values are represented as JSON objects, and each object contains the following properties: Attribute Type Required Default value XPathCategory URI Yes. You can use the short names defined for identifier URIs as values here. None Namespaces Array of namespace declarations No None XPath String Yes None The namespaces property should contain the following properties: Attribute Type Required Default value Prefix String No None Namespace URI Yes None Following is a sample JSON attribute format that contains the fully qualified XACML data-type URI: { Attribute : { AttributeId : urn:oasis:names:tc:xacml:3.0:content-selector , DataType : xpathExpression , Value : { XPathCategory : urn:oasis:names:tc:xacml:3.0:attribute-category:resource , Namespaces : [{ Namespace : urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 }, { Prefix : md , Namespace : urn:example:med:schemas:record }], XPath : md:record/md:patient/md:patientDoB } } } The MultiRequests object is optional in the JSON representation of XACML. The purpose of the MultiRequests object is to support the XACML multiple decision profile. The JSON attribute object contains an array of attribute objects. The attribute object contains the following properties: Property name Type Required Default value AttributeId URI Yes None. The identifier used in the XML representation of a XACML attribute will be used in its JSON representation Value Either string, boolean, number (this maps to either a XACML integer or double as defined in supported data types), object, array of strings, array of boolean, Array of number, array of object, or a mixed array of string and number where the string values represents a numerical value. Yes None. Issuer String No Null Data Type URI No The data type value can be omitted in the JSON representation. The default value is http://www.w3.org/2001/XMLSchema#string . IncludeInResult Boolean No False The results of the JSON request is represented by the decision object in the form of a JSON Object. This can have following properties: Property name Type Required Default value Decision String Yes. Possible values are: Permit, Deny, NotApplicable, Indeterminate None. The results can have the status , obligations , associatedAdvice , category , and policyIdentifierList , which are optional. Following is a sample JSON request that you can try out with WSO2 Identity Server: { Request : { AccessSubject : { Attribute : [ { AttributeId : subject-id , Value : sam , DataType : string , IncludeInResult : true } ] }, Resource : { Attribute : [ { AttributeId : resource-id , Value : index.jsp , DataType : string , IncludeInResult : true } ] }, Action : { Attribute : [{ AttributeId : action-id , Value : modify-welcome , DataType : string , IncludeInResult : true } ] } } } Following is a sample XACML JSON response that you will get for the above request: { Response : [ { Decision : Deny , Status : { StatusCode : { Value : urn:oasis:names:tc:xacml:1.0:status:ok } }, AccessSubject : { Attribute : [ { AttributeId : subject-id , Value : dinali , IncludeInResult : true , DataType : string } ] }, Resource : { Attribute : [ { AttributeId : resource-id , Value : index.jsp , IncludeInResult : true , DataType : string } ] }, Action : { Attribute : [ { AttributeId : action-id , Value : modify-welcome , IncludeInResult : true , DataType : string } ] } } ] } For a tutorial that demonstrate how WSO2 IS supports fine-grained authorization using XACML requests in JSON format, see Fine-grained Authorization using XACML Requests in JSON Format .","title":"XACML 3.0 JSON Profile"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#administrative-delegation-profile","text":"This is also a new profile that comes with XACML 3.0. This allows you to define policies about who can write policies about what. For example, \u201cBob may issue a policy but only about resources in department X\u201d.","title":"Administrative Delegation Profile"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#xacml-20-and-xacml-30-samples","text":"The biggest difference between XACML 2.0 and XACML 3.0 for your client app is that the structure of the attributes in the authentication request has changed significantly in XACML 3.0. In XACML 2.0, attributes were organized into subject, resource, environment, or action categories using XML element tags: Request xmlns= urn:oasis:names:tc:xacml:2.0:context:schema:os xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= urn:oasis:names:tc:xacml:2.0:context:schema:os access_control-xacml-2.0-context-schema-os.xsd Subject Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:subject:subject-id DataType= http://www.w3.org/2001/XMLSchema#string AttributeValue Julius Hibbert /AttributeValue /Attribute /Subject Resource Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#anyURI AttributeValue http://medico.com/record/patient/BartSimpson /AttributeValue /Attribute /Resource Action Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string AttributeValue read /AttributeValue /Attribute /Action Environment/ /Request In XACML 3.0, these categories are indicated using XML attributes instead of XML element tags: ?xml version= 1.0 encoding= utf-8 ? Request xsi:schemaLocation= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 http://docs.oasis-open.org/xacml/3.0/xacml-core-v3-schema-wd-17.xsd ReturnPolicyIdList= false CombinedDecision= false xmlns= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance Attributes Category= urn:oasis:names:tc:xacml:1.0:subject-category:access-subject Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:subject:subject-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string Julius Hibbert /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:resource Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#anyURI http://medico.com/record/patient/BartSimpson /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string read /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:environment / /Request The element in XACML 2.0 becomes in XACML 3.0, for example. This is the same for the resource, environment, and action categories.","title":"XACML 2.0 and XACML 3.0 samples"},{"location":"Concepts/Access_Control_and_Entitlement_Management/#attachments","text":"{width=\"8\" height=\"8\"} Untitled Diagram.png (image/png) {width=\"8\" height=\"8\"} 10.png (image/png) {width=\"8\" height=\"8\"} image2015-6-16 14:35:7.png (image/png) {width=\"8\" height=\"8\"} image2015-6-16 14:43:33.png (image/png) {width=\"8\" height=\"8\"} image2015-6-16 14:51:40.png (image/png) {width=\"8\" height=\"8\"} image2015-6-16 14:59:29.png (image/png)","title":"Attachments:"},{"location":"Concepts/Identity_Anti-patterns_and_the_Identity_Bus/","text":"Identity Anti-patterns and the Identity Bus This topic explores the problem of identity anti-patterns and the solution provided by the WSO2 Identity Server in the form of the identity bus. Spaghetti identity and federation silos According to research conducted by the analyst firm, Quocirca , many businesses now have more external users than internal ones. Also many businesses are involved in acquisitions, mergers and partnerships, and these result in lots of external users joining the business. Often, these external users have to be integrated with the existing user base in bulk. This sort of integration can be complicated due to the different protocols followed by different identity systems. How this impacts enterprise identity management When working with both external and internal users and merging different systems together, you are faced with technicalities related to management of multiple heterogeneous user stores, different types of authentication protocols, legacy systems and many more. SAML, OpenID Connect, and WS-Federation all support identity federation and cross domain authentication. However, in a real world scenario, not all involved parties in a federation use case will support SAML and OpenID Connect. Most of the federation systems seen today are in silos. It can be a silo of SAML federation or a silo of OpenID Connect federation. While a system that uses SAML as it's protocol may be able to communicate with other SAML protocol-based systems, they may not be able to communicate with OpenID Connect. The diagram below illustrates how a silo of SAML federation and OpenID Connect federation interact within the respective silo and how it cannot interact with different silos. {height=\"250\"} Also consider the scalability of a specific federation silo. Within the SAML federation silo, for example, there can be an increasing number of service providers and identity providers. Each service provider has to trust each identity provider and this leads to the Spaghetti Identity anti-pattern. The following diagram depicts the complexity of this. {width=\"350\"} The identity bus Federation Silos and Spaghetti Identity are two anti-patterns directly addressed by the Identity Bus pattern in the WSO2 Identity Server. With Identity Bus, a given service provider is not coupled to a given identity provider and also not coupled to a given federation protocol. A user should be able to log into a service provider that accepts only SAML 2.0 tokens with an identity provider that issues only OpenID Connect tokens. The Identity Bus acts as a middle-man, or an Identity Broker, that mediates and transforms identity tokens between heterogeneous identity protocols. The following are some of the benefits of using the Identity Bus pattern. Introducing a new service provider is extremely easy. You only need to register the service provider in the Identity Bus and pick which identity providers it trusts. It is not necessary to add the service provider configuration to each and every identity provider. Similarly, removing an existing service provider is extremely easy. You only need to remove the service provider from the Identity Bus. It is not necessary to remove the service provider from each and every identity provider. Introducing a new identity provider is extremely easy. You only need to register the identity provider in the Identity Bus. It will be available for any service provider. Similarly, removing an existing identity provider is extremely easy. You only need to remove the identity provider from the Identity Bus. Enforcing new authentication protocols is extremely easy. Consider a scenario where you need to authenticate users with both the username and password and also Duo Security (SMS based authentication). To do this, you only need to add that capability to the Identity Bus and pick the required set of authentication protocols against a given service provider at the time of service provider registration. In the Identity Bus, each service provider can be configured based on how it authenticates users. Claim transformations. Your service provider may read user's email address from the \" http://sp1.org/claims/email \" attribute id - but the identity provider of the user may send it as \" http://idp1.org/claims/emai \". Identity bus can transform the claims it receives from the identity provider to the format expected by the service provider. Role mapping. Your service provider needs to authorize users once they are logged in. What the user can do at the identity provider is different from what the same user can do at the service provider. User's roles from the identity provider define what he can do at the identity provider. Service provider's roles define the things a user can do at the service provider. Identity bus is capable of mapping identity provider's roles to the service provider's roles. For example a user may bring idp-admin role from his identity provider - in a SAML response - then the identity bus will find the mapped service provider role corresponding to this, say sp-admin, and will add that into the SAML response returning back to the service provider from the identity bus. Just-in-time provisioning. Since identity bus is at the middle of all identity transactions - it can provision all external user identities to an internal user store. Centralized monitoring and auditing. Introducing a new federation protocol needs minimal changes. If you have a service provider or an identity provider, which supports a proprietary federation protocol, then you only need to add that capability to the identity bus. No need to implement it at each and every identity provider or service provider. Attachments: {width=\"8\" height=\"8\"} image2017-11-30_17-30-33.png (image/png) {width=\"8\" height=\"8\"} image2017-11-30_17-29-58.png (image/png) {width=\"8\" height=\"8\"} image2015-3-19 15:29:0.png (image/png) {width=\"8\" height=\"8\"} image2015-3-19 15:13:16.png (image/png) {width=\"8\" height=\"8\"} image2015-3-19 14:59:29.png (image/png) {width=\"8\" height=\"8\"} image2015-3-19 14:14:0.png (image/png)","title":"Identity Anti-patterns and the Identity Bus"},{"location":"Concepts/Identity_Anti-patterns_and_the_Identity_Bus/#identity-anti-patterns-and-the-identity-bus","text":"This topic explores the problem of identity anti-patterns and the solution provided by the WSO2 Identity Server in the form of the identity bus.","title":"Identity Anti-patterns and the Identity Bus"},{"location":"Concepts/Identity_Anti-patterns_and_the_Identity_Bus/#spaghetti-identity-and-federation-silos","text":"According to research conducted by the analyst firm, Quocirca , many businesses now have more external users than internal ones. Also many businesses are involved in acquisitions, mergers and partnerships, and these result in lots of external users joining the business. Often, these external users have to be integrated with the existing user base in bulk. This sort of integration can be complicated due to the different protocols followed by different identity systems.","title":"Spaghetti identity and federation silos"},{"location":"Concepts/Identity_Anti-patterns_and_the_Identity_Bus/#how-this-impacts-enterprise-identity-management","text":"When working with both external and internal users and merging different systems together, you are faced with technicalities related to management of multiple heterogeneous user stores, different types of authentication protocols, legacy systems and many more. SAML, OpenID Connect, and WS-Federation all support identity federation and cross domain authentication. However, in a real world scenario, not all involved parties in a federation use case will support SAML and OpenID Connect. Most of the federation systems seen today are in silos. It can be a silo of SAML federation or a silo of OpenID Connect federation. While a system that uses SAML as it's protocol may be able to communicate with other SAML protocol-based systems, they may not be able to communicate with OpenID Connect. The diagram below illustrates how a silo of SAML federation and OpenID Connect federation interact within the respective silo and how it cannot interact with different silos. {height=\"250\"} Also consider the scalability of a specific federation silo. Within the SAML federation silo, for example, there can be an increasing number of service providers and identity providers. Each service provider has to trust each identity provider and this leads to the Spaghetti Identity anti-pattern. The following diagram depicts the complexity of this. {width=\"350\"}","title":"How this impacts enterprise identity management"},{"location":"Concepts/Identity_Anti-patterns_and_the_Identity_Bus/#the-identity-bus","text":"Federation Silos and Spaghetti Identity are two anti-patterns directly addressed by the Identity Bus pattern in the WSO2 Identity Server. With Identity Bus, a given service provider is not coupled to a given identity provider and also not coupled to a given federation protocol. A user should be able to log into a service provider that accepts only SAML 2.0 tokens with an identity provider that issues only OpenID Connect tokens. The Identity Bus acts as a middle-man, or an Identity Broker, that mediates and transforms identity tokens between heterogeneous identity protocols. The following are some of the benefits of using the Identity Bus pattern. Introducing a new service provider is extremely easy. You only need to register the service provider in the Identity Bus and pick which identity providers it trusts. It is not necessary to add the service provider configuration to each and every identity provider. Similarly, removing an existing service provider is extremely easy. You only need to remove the service provider from the Identity Bus. It is not necessary to remove the service provider from each and every identity provider. Introducing a new identity provider is extremely easy. You only need to register the identity provider in the Identity Bus. It will be available for any service provider. Similarly, removing an existing identity provider is extremely easy. You only need to remove the identity provider from the Identity Bus. Enforcing new authentication protocols is extremely easy. Consider a scenario where you need to authenticate users with both the username and password and also Duo Security (SMS based authentication). To do this, you only need to add that capability to the Identity Bus and pick the required set of authentication protocols against a given service provider at the time of service provider registration. In the Identity Bus, each service provider can be configured based on how it authenticates users. Claim transformations. Your service provider may read user's email address from the \" http://sp1.org/claims/email \" attribute id - but the identity provider of the user may send it as \" http://idp1.org/claims/emai \". Identity bus can transform the claims it receives from the identity provider to the format expected by the service provider. Role mapping. Your service provider needs to authorize users once they are logged in. What the user can do at the identity provider is different from what the same user can do at the service provider. User's roles from the identity provider define what he can do at the identity provider. Service provider's roles define the things a user can do at the service provider. Identity bus is capable of mapping identity provider's roles to the service provider's roles. For example a user may bring idp-admin role from his identity provider - in a SAML response - then the identity bus will find the mapped service provider role corresponding to this, say sp-admin, and will add that into the SAML response returning back to the service provider from the identity bus. Just-in-time provisioning. Since identity bus is at the middle of all identity transactions - it can provision all external user identities to an internal user store. Centralized monitoring and auditing. Introducing a new federation protocol needs minimal changes. If you have a service provider or an identity provider, which supports a proprietary federation protocol, then you only need to add that capability to the identity bus. No need to implement it at each and every identity provider or service provider.","title":"The identity bus"},{"location":"Concepts/Identity_Anti-patterns_and_the_Identity_Bus/#attachments","text":"{width=\"8\" height=\"8\"} image2017-11-30_17-30-33.png (image/png) {width=\"8\" height=\"8\"} image2017-11-30_17-29-58.png (image/png) {width=\"8\" height=\"8\"} image2015-3-19 15:29:0.png (image/png) {width=\"8\" height=\"8\"} image2015-3-19 15:13:16.png (image/png) {width=\"8\" height=\"8\"} image2015-3-19 14:59:29.png (image/png) {width=\"8\" height=\"8\"} image2015-3-19 14:14:0.png (image/png)","title":"Attachments:"},{"location":"Concepts/Identity_Provisioning_and_its_Standards/","text":"Identity Provisioning and its Standards User and identity provisioning plays a key role in propagating users, user groups, and user identities across different systems and SaaS applications. Provisioning is the process of coordinating the creation of user accounts, e-mail authorizations in the form of rules and roles, and other tasks such as provisioning of resources associated with enabling new users. This is particularly useful when adding new users into your organization. WSO2 Identity Server can ensure that provisioning is made easy. A provisioning request can be sent to the Identity Server to add a new user and this user is provisioned to various applications that are configured with the Identity Server. This process is illustrated in the following diagram. {width=\"750\"} Figure : User and identity provisioning using WSO2 Identity Server Inbound and outbound provisioning Inbound provisioning focuses on how to provision users, user groups, and user identities to the Identity Server. This can be done using the REST API available for SCIM. The following figure is an example of this process. Figure : Inbound provisioning Outbound provisioning involves provisioning users, user groups, and user identities to external systems or SaaS applications. Figure : Outbound provisioning Introducing SPML Service Provisioning Markup Language (SPML) is an XML-based framework developed by OASIS for exchanging user, resource, and service provisioning information between cooperating organizations. The Service Provisioning Markup Language is the open standard for the integration and interoperation of service provisioning requests. The goal of SPML is to allow organizations to securely and quickly set up user interfaces for Web services and applications, by letting enterprise platforms such as Web portals, application servers, and service centers generate provisioning requests within and across organizations. This can lead to automation of user or system access and entitlement rights to electronic services across diverse IT infrastructures, so that customers are not locked into proprietary solutions Introducing SCIM The System for Cross-domain Identity Management (SCIM) specification is designed to make managing user identities in cloud based applications and services, easier. User and identity provisioning is a key aspect of any identity management solution. In simple terms, it is to create, maintain, and delete user accounts and related identities in one or more systems or applications in response to business processes that are initiated either by humans directly or by automated tasks. Today the enterprise solutions adopt products and services from multiple cloud providers in order to accomplish various business requirements. Hence, it is no longer sufficient to maintain user identities only in a corporate LDAP. In most cases, SaaS providers also need dedicated user accounts created for the cloud service users, which raises the need of proper identity provisioning mechanisms to be in place. Currently, different cloud vendors expose non-standard provisioning APIs that make it a nightmare for the enterprises to develop and maintain proprietary connectors to integrate with multiple SaaS providers. For example, Google exposes the Google Provisioning API for provisioning user accounts in Google Apps Domain. When enterprise IT systems consist of distributed, heterogeneous components from multiple vendors, and from both in-house and cloud, it is key to have an open standard that all agree upon in order to achieve interoperability and simplicity while getting rid of multiple connectors to perform the same thing. SCIM is an emerging open standard that defines a comprehensive REST API, along with a platform neutral schema and a SAML binding to facilitate the user management operations across SaaS applications; placing specific emphasis on simplicity and interoperability. Brief history of identity provisioning {.expand-control-image}Click here to read about the history of identity provisioning. The following diagram illustrates the progressive development that has taken place in the history of identity provisioning. {width=\"750\"} Figure : Provisioning evolution and history The OASIS Technical Committee for Service Provisioning was formed in 2001 to define an XML-based framework for exchanging user, resource, and service provisioning information. As a result, the SPML (Service Provisioning Mark Language) came up in 2003 and was based on three proprietary provisioning standards by that time. IBM and Microsoft played a major role in building the SPML 1.0. The following are the three proprietary provisioning standards. Information Technology Markup Language (ITML) Active Digital Profile (ADPr) eXtensible Resource Provisioning Management (XRPM) SPML 1.0 defined a Request/Response protocol as well as couple of bindings. Requests/Responses are all based on XML and each operation has it own schema. One of the bindings defined in SPML 1.0 is the SOAP binding. It specifies how to transfer SPML requests and responses wrapped in a SOAP message. All the SPML operations supported by the provisioning entity should be declared in the WSDL file itself. The other one is file binding. This binding refers to using SPML elements in a file, typically for the purposes of bulk processing provisioning data and provisioning schema documentation. In the closing stages of SPML 1.0, IBM and Microsoft felt strongly that support for complex XML objects needed to be done differently. The OASIS TC voted to postpone this effort until 2.0. As a result, IBM unofficially stated that they wouldn't be implementing 1.0 and would wait on the conclusion of the 2.0 process. IBM and Microsoft, who were part of the initial SPML specification, went ahead and started building their own standard for provisioning via SOAP based services. This is called WS-Provisioning. WS-Provisioning describes the APIs and schemas necessary to facilitate interoperability between provisioning systems in a consistent manner using Web services. It includes operations for adding, modifying, deleting, and querying provisioning data. It also specifies a notification interface for subscribing to provisioning events. Provisioning data is described using XML and other types of schema. This facilitates the translation of data between different provisioning systems. WS-Provisioning is part of the Service Oriented Architecture and has been submitted to the Organization for the Advancement of Structured Information Standards (OASIS) Provisioning Service Technical Committee. OASIS PSTC took both SPML 1.0 and WS-Provisioning specification as inputs and developed SPML 2.0 in 2006. SPML 1.0 has been called a slightly improved Directory Services Markup Language (DSML). SPML 2.0 defines an extensible protocol (through capabilities) with support for a DSML profile (SPMLv2 DSMLv2), as well as XML schema profiles. SPML 2.0 differentiates between the protocol and the data it carries. SPML 1.0 defined file bindings and SOAP bindings that assumed the SPML1.0 Schema for DSML. The SPMLv2 DSMLv2 Profile provides a degree of backward compatibility with SPML 1.0. The DSMLv2 profile supports a schema model similar to that of SPML 1.0. The DSMLv2 Profile may be more convenient for applications that mainly access targets that are LDAP or X500 directory services. The XSD Profile may be more convenient for applications that mainly access targets that are Web services. The SPML 2.0 protocol enables better interoperability between vendors, especially for the core capabilities (those found in 1.0). You can \u201cextend\u201d SPML 1.0 using ExtendedRequest, but there is no guidance about what those requests can be. SPML 2.0 defines a set of \u201cstandard capabilities\u201d that allow you to add support in well-defined ways. SPML definitely addressed the key objective of forming the OASIS PSTC in 2001. It solved the interoperability issues, however, it was too complex to implement. It was SOAP biased and was addressing too many concerns in provisioning than what actually was needed. It was around 2009 - 2010 that people started to talk about the death of SPML. In parallel to the criticisms against SPML - another standard known as SCIM (Simple Could Identity Management) started to emerge. This was around mid 2010 - and initiated by Salesforce, Ping Identity, Google and others. WSO2 joined the effort sometime in early 2011 and took part in all the interop events that have happened so far. SCIM is purely RESTful. The initial version supported both JSON and XML. SCIM introduced a REST API for provisioning and also a core schema (which also can be extended) for provisioning objects. SCIM 1.1 was finalized in 2012 - and then it was donated to the IETF . Once in IETF, it changed the definition of SCIM to System for Cross-domain Identity Management and it supports only JSON and now XML. As a result of the increasing pressure on OASIS PSTC, they started working on a REST binding for SPML, which is known as RESTPML , around 2011. This is still based on XML and not yet active so far. Attachments: {width=\"8\" height=\"8\"} image2017-3-31 14:5:18.png (image/png) {width=\"8\" height=\"8\"} image2017-4-3 12:44:11.png (image/png) {width=\"8\" height=\"8\"} image2017-4-3 12:47:23.png (image/png) {width=\"8\" height=\"8\"} SCIM_History.png (image/png)","title":"Identity_Provisioning and its Standards"},{"location":"Concepts/Identity_Provisioning_and_its_Standards/#identity-provisioning-and-its-standards","text":"User and identity provisioning plays a key role in propagating users, user groups, and user identities across different systems and SaaS applications. Provisioning is the process of coordinating the creation of user accounts, e-mail authorizations in the form of rules and roles, and other tasks such as provisioning of resources associated with enabling new users. This is particularly useful when adding new users into your organization. WSO2 Identity Server can ensure that provisioning is made easy. A provisioning request can be sent to the Identity Server to add a new user and this user is provisioned to various applications that are configured with the Identity Server. This process is illustrated in the following diagram. {width=\"750\"} Figure : User and identity provisioning using WSO2 Identity Server","title":"Identity Provisioning and its Standards"},{"location":"Concepts/Identity_Provisioning_and_its_Standards/#inbound-and-outbound-provisioning","text":"Inbound provisioning focuses on how to provision users, user groups, and user identities to the Identity Server. This can be done using the REST API available for SCIM. The following figure is an example of this process. Figure : Inbound provisioning Outbound provisioning involves provisioning users, user groups, and user identities to external systems or SaaS applications. Figure : Outbound provisioning","title":"Inbound and outbound provisioning"},{"location":"Concepts/Identity_Provisioning_and_its_Standards/#introducing-spml","text":"Service Provisioning Markup Language (SPML) is an XML-based framework developed by OASIS for exchanging user, resource, and service provisioning information between cooperating organizations. The Service Provisioning Markup Language is the open standard for the integration and interoperation of service provisioning requests. The goal of SPML is to allow organizations to securely and quickly set up user interfaces for Web services and applications, by letting enterprise platforms such as Web portals, application servers, and service centers generate provisioning requests within and across organizations. This can lead to automation of user or system access and entitlement rights to electronic services across diverse IT infrastructures, so that customers are not locked into proprietary solutions","title":"Introducing SPML"},{"location":"Concepts/Identity_Provisioning_and_its_Standards/#introducing-scim","text":"The System for Cross-domain Identity Management (SCIM) specification is designed to make managing user identities in cloud based applications and services, easier. User and identity provisioning is a key aspect of any identity management solution. In simple terms, it is to create, maintain, and delete user accounts and related identities in one or more systems or applications in response to business processes that are initiated either by humans directly or by automated tasks. Today the enterprise solutions adopt products and services from multiple cloud providers in order to accomplish various business requirements. Hence, it is no longer sufficient to maintain user identities only in a corporate LDAP. In most cases, SaaS providers also need dedicated user accounts created for the cloud service users, which raises the need of proper identity provisioning mechanisms to be in place. Currently, different cloud vendors expose non-standard provisioning APIs that make it a nightmare for the enterprises to develop and maintain proprietary connectors to integrate with multiple SaaS providers. For example, Google exposes the Google Provisioning API for provisioning user accounts in Google Apps Domain. When enterprise IT systems consist of distributed, heterogeneous components from multiple vendors, and from both in-house and cloud, it is key to have an open standard that all agree upon in order to achieve interoperability and simplicity while getting rid of multiple connectors to perform the same thing. SCIM is an emerging open standard that defines a comprehensive REST API, along with a platform neutral schema and a SAML binding to facilitate the user management operations across SaaS applications; placing specific emphasis on simplicity and interoperability.","title":"Introducing SCIM"},{"location":"Concepts/Identity_Provisioning_and_its_Standards/#brief-history-of-identity-provisioning","text":"{.expand-control-image}Click here to read about the history of identity provisioning. The following diagram illustrates the progressive development that has taken place in the history of identity provisioning. {width=\"750\"} Figure : Provisioning evolution and history The OASIS Technical Committee for Service Provisioning was formed in 2001 to define an XML-based framework for exchanging user, resource, and service provisioning information. As a result, the SPML (Service Provisioning Mark Language) came up in 2003 and was based on three proprietary provisioning standards by that time. IBM and Microsoft played a major role in building the SPML 1.0. The following are the three proprietary provisioning standards. Information Technology Markup Language (ITML) Active Digital Profile (ADPr) eXtensible Resource Provisioning Management (XRPM) SPML 1.0 defined a Request/Response protocol as well as couple of bindings. Requests/Responses are all based on XML and each operation has it own schema. One of the bindings defined in SPML 1.0 is the SOAP binding. It specifies how to transfer SPML requests and responses wrapped in a SOAP message. All the SPML operations supported by the provisioning entity should be declared in the WSDL file itself. The other one is file binding. This binding refers to using SPML elements in a file, typically for the purposes of bulk processing provisioning data and provisioning schema documentation. In the closing stages of SPML 1.0, IBM and Microsoft felt strongly that support for complex XML objects needed to be done differently. The OASIS TC voted to postpone this effort until 2.0. As a result, IBM unofficially stated that they wouldn't be implementing 1.0 and would wait on the conclusion of the 2.0 process. IBM and Microsoft, who were part of the initial SPML specification, went ahead and started building their own standard for provisioning via SOAP based services. This is called WS-Provisioning. WS-Provisioning describes the APIs and schemas necessary to facilitate interoperability between provisioning systems in a consistent manner using Web services. It includes operations for adding, modifying, deleting, and querying provisioning data. It also specifies a notification interface for subscribing to provisioning events. Provisioning data is described using XML and other types of schema. This facilitates the translation of data between different provisioning systems. WS-Provisioning is part of the Service Oriented Architecture and has been submitted to the Organization for the Advancement of Structured Information Standards (OASIS) Provisioning Service Technical Committee. OASIS PSTC took both SPML 1.0 and WS-Provisioning specification as inputs and developed SPML 2.0 in 2006. SPML 1.0 has been called a slightly improved Directory Services Markup Language (DSML). SPML 2.0 defines an extensible protocol (through capabilities) with support for a DSML profile (SPMLv2 DSMLv2), as well as XML schema profiles. SPML 2.0 differentiates between the protocol and the data it carries. SPML 1.0 defined file bindings and SOAP bindings that assumed the SPML1.0 Schema for DSML. The SPMLv2 DSMLv2 Profile provides a degree of backward compatibility with SPML 1.0. The DSMLv2 profile supports a schema model similar to that of SPML 1.0. The DSMLv2 Profile may be more convenient for applications that mainly access targets that are LDAP or X500 directory services. The XSD Profile may be more convenient for applications that mainly access targets that are Web services. The SPML 2.0 protocol enables better interoperability between vendors, especially for the core capabilities (those found in 1.0). You can \u201cextend\u201d SPML 1.0 using ExtendedRequest, but there is no guidance about what those requests can be. SPML 2.0 defines a set of \u201cstandard capabilities\u201d that allow you to add support in well-defined ways. SPML definitely addressed the key objective of forming the OASIS PSTC in 2001. It solved the interoperability issues, however, it was too complex to implement. It was SOAP biased and was addressing too many concerns in provisioning than what actually was needed. It was around 2009 - 2010 that people started to talk about the death of SPML. In parallel to the criticisms against SPML - another standard known as SCIM (Simple Could Identity Management) started to emerge. This was around mid 2010 - and initiated by Salesforce, Ping Identity, Google and others. WSO2 joined the effort sometime in early 2011 and took part in all the interop events that have happened so far. SCIM is purely RESTful. The initial version supported both JSON and XML. SCIM introduced a REST API for provisioning and also a core schema (which also can be extended) for provisioning objects. SCIM 1.1 was finalized in 2012 - and then it was donated to the IETF . Once in IETF, it changed the definition of SCIM to System for Cross-domain Identity Management and it supports only JSON and now XML. As a result of the increasing pressure on OASIS PSTC, they started working on a REST binding for SPML, which is known as RESTPML , around 2011. This is still based on XML and not yet active so far.","title":"Brief history of identity provisioning"},{"location":"Concepts/Identity_Provisioning_and_its_Standards/#attachments","text":"{width=\"8\" height=\"8\"} image2017-3-31 14:5:18.png (image/png) {width=\"8\" height=\"8\"} image2017-4-3 12:44:11.png (image/png) {width=\"8\" height=\"8\"} image2017-4-3 12:47:23.png (image/png) {width=\"8\" height=\"8\"} SCIM_History.png (image/png)","title":"Attachments:"},{"location":"Concepts/Key_Concepts/","text":"Key Concepts This section of the WSO2 Identity Server documentation include definitions of identity-related terms and concepts you may come across as you use the product. This serves to provide an introduction into concepts in the identity and access management domain and also enhance understanding of these concepts. [ Single Sign-On and Identity Federation ] [ Identity Provisioning and its Standards ] [ Access Control and Entitlement Management ] [ Identity Anti-patterns and the Identity Bus ] Single Sign-On and Identity Federation The Single Sign-On (SSO) and identity federation section introduces these concepts, provide an explanation of how these work with real world applications, and also list out the various specifications supported by the Identity Server as a solution. Click the button below to view this content. configure SSO and Identity Federation Identity Provisioning and its Standards The identity provisioning section introduces the concept along with inbound and outbound provisioning. This section provides information on SCIM and SPML, which are protocols supported by the Identity Server. It also delves into the history of provisioning standards and how these progressed over time. Click the button below to view this content. configure Identity Provisioning and its Standards {.contentf-button .aui-button} Access Control and Entitlement Management The access control and entitlement management section introduces the concept of access control, the various types of access control and dives deep into XACML. This section provides detailed information on XACML including the concept, terminology, and architecture. Click the button below to view this content. configure Access Control and Entitlement Management {.contentf-button .aui-button} Identity Anti-patterns and the Identity Bus This section introduces the business problem of spaghetti identity and federation silos. It then expands on how the identity bus that runs within the WSO2 Identity Server solves this problem. Click the button below to view this content. configure Identity Anti-patterns and the Identity Bus {.contentf-button .aui-button}","title":"Key Concepts"},{"location":"Concepts/Key_Concepts/#key-concepts","text":"This section of the WSO2 Identity Server documentation include definitions of identity-related terms and concepts you may come across as you use the product. This serves to provide an introduction into concepts in the identity and access management domain and also enhance understanding of these concepts. [ Single Sign-On and Identity Federation ] [ Identity Provisioning and its Standards ] [ Access Control and Entitlement Management ] [ Identity Anti-patterns and the Identity Bus ]","title":"Key Concepts"},{"location":"Concepts/Key_Concepts/#single-sign-on-and-identity-federation","text":"The Single Sign-On (SSO) and identity federation section introduces these concepts, provide an explanation of how these work with real world applications, and also list out the various specifications supported by the Identity Server as a solution. Click the button below to view this content. configure SSO and Identity Federation","title":"Single Sign-On and Identity Federation"},{"location":"Concepts/Key_Concepts/#identity-provisioning-and-its-standards","text":"The identity provisioning section introduces the concept along with inbound and outbound provisioning. This section provides information on SCIM and SPML, which are protocols supported by the Identity Server. It also delves into the history of provisioning standards and how these progressed over time. Click the button below to view this content. configure Identity Provisioning and its Standards {.contentf-button .aui-button}","title":"Identity Provisioning and its Standards"},{"location":"Concepts/Key_Concepts/#access-control-and-entitlement-management","text":"The access control and entitlement management section introduces the concept of access control, the various types of access control and dives deep into XACML. This section provides detailed information on XACML including the concept, terminology, and architecture. Click the button below to view this content. configure Access Control and Entitlement Management {.contentf-button .aui-button}","title":"Access Control and Entitlement Management"},{"location":"Concepts/Key_Concepts/#identity-anti-patterns-and-the-identity-bus","text":"This section introduces the business problem of spaghetti identity and federation silos. It then expands on how the identity bus that runs within the WSO2 Identity Server solves this problem. Click the button below to view this content. configure Identity Anti-patterns and the Identity Bus {.contentf-button .aui-button}","title":"Identity Anti-patterns and the Identity Bus"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/","text":"Single Sign-On and Identity Federation This section includes the following key concepts that are pertaining to Single Sign-On (SSO) and identity federation in WSO2 Identity Server. Introducing single sign-on | How single sign-on works | SSO in reality | Supported protocols for SSO | SAML 2.0 SSO | WS-Federation | OpenID Connect | WS-Trust | Identity federation and a comparison with SSO Introducing single sign-on Single sign-on (SSO) is one of the key features of the WSO2 Identity Server that enables users to provide their credentials once and obtain access to multiple applications. The users are not prompted for their credentials when accessing each application until their session is terminated. Additionally, the user can access all these applications without having to log into each and every one of them individually. So, if users log into application A, for example, they would automatically have access to application B as well for the duration of that session without having to re-enter their credentials. The following are some of the advantages you can have with SSO: Users need only a single username/password pair to access multiple services. Thus they do not have the issue of remembering multiple username/password pairs. Users are authenticated only once at the identity provider and then they are automatically logged into all services within that \"trust-domain\". This process is more convenient to users since they do not have to provide their username/password at every service provider. Service providers do not have the overhead of managing user identities, which is more convenient for them. User identities are managed at a central point. This is more secure, less complex and easily manageable. How single sign-on works To understand how single sign-on works, it is useful to first examine how authentication works in a non SSO environment. The following diagram depicts this flow. Figure : Authentication in a non SSO environment In the above figure, the users access Application 1 first and then Application 2 using the same browser. The user is authenticated in Application 1 first and can access this application. When the users attempt to access Application 2 , they must enter their credentials again and get access to Application 2 separately. There is no way for Application 2 to access the cookie stored in the browser for Application 1 and authenticate the user by that means. The following diagram depicts how this story differs in a SSO environment. Figure : Authentication in a SSO environment In this second figure, the users access Application 1 first followed by Application 2 . Once again, the users use the same browser to access these applications. The users are redirected to the WSO2 Identity Server (or any authentication server that is configured for this task). If the users are already logged in to the Identity Server, the user is authenticated in Application 1 via an authentication token sent by the Identity Server to Application 1 . When Application 2 is accessed, the same thing happens and the users are redirected to the Identity Server and authenticated. This is how SSO works. SSO in reality Single sign-on is widely used in web technologies. Google is one of the best examples. Try this simple exercise. Visit www.google.com from your web browser. Click the SIGN IN button on the top right of the page. Once you sign in, you are redirected to https://accounts.google.com/ServiceLogin . There you are requested to enter your Username and Password. Enter your Google credentials there. Once you enter your Username and Password, you are directed back to www.google.com where you started. Next visit www.gmail.com , the Google mail server. Notice that you are automatically signed in and you directly access your Gmail Inbox. You did not have to enter your Username and Password at Gmail. In addition to that; now try www.youtube.com . You are automatically signed in. You do not have to enter your username and password at YouTube. Tip : Notice the URL of the web browser. Each time you access an application, you see that you are being redirected to https://accounts.google.com/ServiceLogin and return immediately back to the website. Single Sign-On (SSO) allows you to sign in only once but provides access to multiple resources without having to re-enter your username and password. Supported protocols for SSO The following are the supported protocols for agent-based single sign-on. SAML 2.0 WS-Federation OpenID Connect WS-Trust The following sections in this topic expand on these protocols and provide details pertaining to them. SAML 2.0 SSO SAML stands for Security Assertion Markup Language, which is an XML-based data format for exchanging authentication and authorization data between an identity provider and a service provider. The single most important requirement that SAML addresses is web browser single sign-on (SSO). Three main roles are defined in SAML Specification. The Principal : This is typically the user who requires a service from a service provider entity. The Identity Provider : The SAML authority that provides the identity assertion to authenticate a principal. The Service Provider : The SAML consumer that provides the service for principals. The main use case scenario covered by SAML is the principal (the user) requesting access to a resource or service from the service provider. Then the service provider, using SAML, communicates with the identity provider to obtain identity assertion. The service provider makes the access control decision, depending on this assertion. SAML 2.0 is the latest version of SAML, which uses security tokens containing assertions to pass information about a user between an identity provider and a service provider. SAML 2.0 provides five main specifications: Core Bindings Profiles Metadata Conformances SAML 2.0 web browser-based SSO profile SAML 2.0 Web Browser based SSO profile is defined under the SAML 2.0 Profiles specification. In a web browser based SSO system, the flow can be started by the user either by attempting to access a service at the service provider or by directly accessing the identity provider itself. If the user accesses a service at a service provider: The service provider determines which identity provider to use (this is the case when there are multiple identity providers. SAML identity provider discovery profile may be used). The service provider generates a SAML message and then redirects the web browser to the identity provider along with the message. Identity provider authenticates the user. The identity provider generates a SAML message and then redirects the web browser back to the service provider. The service provider processes the SAML message and decides to grant or deny access to the user. If the user accesses the identity provider directly, then only the steps 3, 4 and 5 are in the flow. The following diagram depicts this flow. Figure : SAML 2.0 authentication flow The message MUST contain an element that uniquely identifies the service provider who created the message. Optionally, the message may contain elements such as Issuer, NameIDPolicy, etc. More information regarding the message can be found in SAML Core Specification . {.expand-control-image}Click here for more information on assertion consumers, the authentication request and response. SAML 2.0 SSO assertion consumers Service providers act as SAML assertion consumers. They have two basic functions: Create messages and redirect users to the identity provider with the created message. Process messages from the identity provider and make decisions based on them. The following code is a sketch of a sample service provider servlet in a SAML 2.0 web browser-based SSO system. public class Resource extends HttpServlet { private static SamlConsumer consumer = new SamlConsumer (); public void doGet ( HttpServletRequest request , HttpServletResponse response ) { requestMessage = consumer . buildRequestMessage (); response . sendRedirect ( requestMessage ); } public void doPost ( HttpServletRequest request , HttpServletResponse response ) { responseMessage = request . getParameter ( SAMLResponse ). toString (); result = consumer . processResponseMessage ( responseMessage ); } } When a web user attempts to access the above servlet, its doGet() method is called. Inside the doGet() method, it generates an message and then redirects the user to the identity provider. After authentication is completed by the identity provider, it does a POST callback to the above servlet with a message. Then the doPost() method of the servlet gets called and inside the doPost() method, it retrieves the message from the request and then the message is passed to the SamlConsumer instance for processing. AuthnRequest message To create an AuthnRequest message using the OpenSAML library, do the following. Add the OpenSAML library to the build path of the project. You can download the OpenSAML .jar file from here . A sample AuthnRequest message can be found here . According to SAML 2.0 specifications, the message must contain an element. Create the Issuer element first. String issuerId = saml2.sso.demo ; IssuerBuilder issuerBuilder = new IssuerBuilder (); Issuer issuer = issuerBuilder . buildObject ( urn:oasis:names:tc:SAML:2.0:assertion , Issuer , samlp ); issuer . setValue ( issuerId ); Create the AuthnRequest next. // the issuerUrl is the url of the service provider who generates the message String issuerUrl = http://localhost:8080/saml2.sso.demo/consumer ; DateTime issueInstant = new DateTime (); AuthnRequestBuilder authnRequestBuilder = new AuthnRequestBuilder (); AuthnRequest authnRequest = authnRequestBuilder . buildObject ( urn:oasis:names:tc:SAML:2.0:protocol , AuthnRequest , samlp ); authnRequest . setForceAuthn ( false ); authnRequest . setIsPassive ( false ); authnRequest . setIssueInstant ( issueInstant ); authnRequest . setProtocolBinding ( urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST ); authnRequest . setAssertionConsumerServiceURL ( issuerUrl ); authnRequest . setIssuer ( issuer ); authnRequest . setID ( aRandomId ); authnRequest . setVersion ( SAMLVersion . VERSION_20 ); The message may contain many other elements like \",\" etc. those elements can be created and added to the message in the same way. Next encode the message. Marshaller marshaller = Configuration . getMarshallerFactory (). getMarshaller ( authnRequest ); Element authDOM = marshaller . marshall ( authnRequest ); StringWriter rspWrt = new StringWriter (); XMLHelper . writeNode ( authDOM , rspWrt ); String requestMessage = rspWrt . toString (); Deflater deflater = new Deflater ( Deflater . DEFLATED , true ); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream (); DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream ( byteArrayOutputStream , deflater ); deflaterOutputStream . write ( requestMessage . getBytes ()); deflaterOutputStream . close (); /* Encoding the compressed message */ String encodedRequestMessage = Base64 . encodeBytes ( byteArrayOutputStream . toByteArray (), Base64 . DONT_BREAK_LINES ); String encodedAuthnRequest = URLEncoder . encode ( encodedRequestMessage , UTF-8 ). trim (); Construct the redirection URL. redirectionUrl = identitypProviderUrl + ?SAMLRequest= + encodedRequestMessage ; Redirect the user to the identity provider. response . sendRedirect ( redirectionUrl ); Response message The Identity provider must use HTTP POST or artifact binding to transfer the SAMLResponse message to the service provider. To read the Response message issued by the WSO2 Identity Server, do the following: A sample Response message can be found here . The response message must be fetched from the request. responseMessage = request . getParameter ( SAMLResponse ). toString (); The fetched responseMessage is unmarshaled and the SAML message is retrieved. DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance (); documentBuilderFactory . setNamespaceAware ( true ); DocumentBuilder docBuilder = documentBuilderFactory . newDocumentBuilder (); byte [] base64DecodedResponse = Base64 . decode ( responseMessage ); ByteArrayInputStream is = new ByteArrayInputStream ( base64DecodedResponse ); Document document = docBuilder . parse ( is ); Element element = document . getDocumentElement (); UnmarshallerFactory unmarshallerFactory = Configuration . getUnmarshallerFactory (); Unmarshaller unmarshaller = unmarshallerFactory . getUnmarshaller ( element ); Response response = ( Response ) unmarshaller . unmarshall ( element ); The retrieved SAML 2.0 response message can be easily processed. For example, let's take the username or the subject's NameID . String subject = response . getAssertions (). get ( 0 ). getSubject () . getNameID (). getValue (); Alternatively, if the response is signed by the identity provider, you can retrieve the certificate. String certificate = response . getSignature (). getKeyInfo (). getX509Datas (). get ( 0 ). getX509Certificates (). get ( 0 ). getValue (); Identity provider initiated SSO To initiate IdP Initiated SSO you need to perform a HTTP GET/POST to the following URL (assume the registered service provider issuer ID is foo.com ). The SAML protocol message can be encoded using Base64 encoding. https://localhost:9443/samlsso?spEntityID=foo.com This request will authenticate and redirect the user to the registered Assertion Consumer URL. Optionally, you can send in a RelayState parameter as follows: https://localhost:9443/samlsso?spEntityID=foo.com RelayState=http://localhost:8080/foo.com/my-home.jsp The RelayState parameter must be URL encoded. This request will authenticate and redirect the user to the URL in the RelayState parameter itself. Either you could have service provider initiated SSO only, or service provider initiated SSO and identity provider initiated SSO. You cannot have only identity provider initiated SSO. By design, service provider initiated SSO is more restrictive and secure. If a service provider is allowed to do identity provider initiated SSO, it would automatically imply that this service provider is allowed to do service provider initiated SSO as well. Recommended reading See SAML 2.0 specification documentation for more information. WS-Federation WS-Federation (Web Services Federation) describes the management and brokering of trust relationships and security token exchange across Web services and organizational boundaries. WS-Federation is a part of the larger WS-Security framework. For example, WS-Federation builds on the Security Token Service (STS) by providing mechanisms that facilitate interactions. In the WS-Federation Model, an Identity Provider is a Security Token Service (STS). Recommended reading See WS-Federation specification documentation for more information. OpenID Connect OpenID Connect is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. OpenID Connect allows clients of all types, including Web-based, mobile, and JavaScript clients, to request and receive information about authenticated sessions and end-users. The specification suite is extensible, allowing participants to use optional features such as encryption of identity data, discovery of OpenID Providers, and session management, when it makes sense for them. Recommended reading See OpenID Connect specification documentation for more information. WS-Trust The \"Security Token Service\" (STS) component of WSO2 Identity Server enables you to configure the generic STS to issue claim-based security tokens. A claim-based security token is a common way for applications to acquire and authenticate the identity information they need about users inside their organization, in other organizations, and on the Internet. This Security Token Service is capable of issuing SAML 1.1 and SAML 2.0 tokens as recommended in WS-Trust and SAML Web Service Token Profile specifications. The WSDL of this service can be accessed by clicking this URL: https://(hostname):(port)/services/wso2carbon-sts?wsdl . For instance, with the default configuration, the URL is https://localhost:9443/services/wso2carbon-sts?wsdl . Both SAML 1.1 and SAML 2.0 token types are supported by default. The issued token type is decided based on the type of token defined in the RST (Request Security Token). Currently, the Bearer Subject Confirmation and Holder-Of-Key subject confirmation methods are both supported. With Holder-Of-Key, both Symmetric and Asymmetric key types are supported. You can obtain tokens containing claims that hold certain information about the subject. These claims can be extracted from the profiles or through custom claim callbacks which can be registered to the Carbon runtime. Related Topics See WS-Trust specification documentation for more information. See Configuring WS-Trust Security Token Service to configure WS-Trust in WSO2 Identity Server. Identity federation and a comparison with SSO Identity and access management requirements are rapidly evolving over the years. Organizations cannot survive with authentication and authorization mechanisms that only span a single boundary of trust. Hence, these organizations often provide and consume services across trust boundaries, which may include partners, subsidiaries, customers or suppliers and may span across multiple buildings, cities, states, countries and even continents. Identity federation and Single Sign On (SSO) come into the picture to provide and consume these services across trust boundaries. Identity federation and SSO have similarities as well as key differences. Identity federation enables users to access multiple applications using the same access credentials. This makes access easy, as users do not have to remember a different set of credentials for every application they use. However, the users have to provide their credentials to each one of the applications separately although the credentials used are the same. On the other hand, SSO enables users to provide their credentials once and obtain access to multiple applications. In SSO, the users are not prompted for their credentials when accessing each application until their session is terminated. Attachments: {width=\"8\" height=\"8\"} image2017-6-15_23-10-49.png (image/png) {width=\"8\" height=\"8\"} image2017-6-15_23-6-13.png (image/png) {width=\"8\" height=\"8\"} image2017-6-15_23-2-15.png (image/png) {width=\"8\" height=\"8\"} image2017-2-15 15:58:36.png (image/png) {width=\"8\" height=\"8\"} image2017-2-15 16:41:33.png (image/png) {width=\"8\" height=\"8\"} image2017-2-15 19:30:0.png (image/png)","title":"Single Sign-On and Identity Federation"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#single-sign-on-and-identity-federation","text":"This section includes the following key concepts that are pertaining to Single Sign-On (SSO) and identity federation in WSO2 Identity Server. Introducing single sign-on | How single sign-on works | SSO in reality | Supported protocols for SSO | SAML 2.0 SSO | WS-Federation | OpenID Connect | WS-Trust | Identity federation and a comparison with SSO","title":"Single Sign-On and Identity Federation"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#introducing-single-sign-on","text":"Single sign-on (SSO) is one of the key features of the WSO2 Identity Server that enables users to provide their credentials once and obtain access to multiple applications. The users are not prompted for their credentials when accessing each application until their session is terminated. Additionally, the user can access all these applications without having to log into each and every one of them individually. So, if users log into application A, for example, they would automatically have access to application B as well for the duration of that session without having to re-enter their credentials. The following are some of the advantages you can have with SSO: Users need only a single username/password pair to access multiple services. Thus they do not have the issue of remembering multiple username/password pairs. Users are authenticated only once at the identity provider and then they are automatically logged into all services within that \"trust-domain\". This process is more convenient to users since they do not have to provide their username/password at every service provider. Service providers do not have the overhead of managing user identities, which is more convenient for them. User identities are managed at a central point. This is more secure, less complex and easily manageable.","title":"Introducing single sign-on"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#how-single-sign-on-works","text":"To understand how single sign-on works, it is useful to first examine how authentication works in a non SSO environment. The following diagram depicts this flow. Figure : Authentication in a non SSO environment In the above figure, the users access Application 1 first and then Application 2 using the same browser. The user is authenticated in Application 1 first and can access this application. When the users attempt to access Application 2 , they must enter their credentials again and get access to Application 2 separately. There is no way for Application 2 to access the cookie stored in the browser for Application 1 and authenticate the user by that means. The following diagram depicts how this story differs in a SSO environment. Figure : Authentication in a SSO environment In this second figure, the users access Application 1 first followed by Application 2 . Once again, the users use the same browser to access these applications. The users are redirected to the WSO2 Identity Server (or any authentication server that is configured for this task). If the users are already logged in to the Identity Server, the user is authenticated in Application 1 via an authentication token sent by the Identity Server to Application 1 . When Application 2 is accessed, the same thing happens and the users are redirected to the Identity Server and authenticated. This is how SSO works.","title":"How single sign-on works"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#sso-in-reality","text":"Single sign-on is widely used in web technologies. Google is one of the best examples. Try this simple exercise. Visit www.google.com from your web browser. Click the SIGN IN button on the top right of the page. Once you sign in, you are redirected to https://accounts.google.com/ServiceLogin . There you are requested to enter your Username and Password. Enter your Google credentials there. Once you enter your Username and Password, you are directed back to www.google.com where you started. Next visit www.gmail.com , the Google mail server. Notice that you are automatically signed in and you directly access your Gmail Inbox. You did not have to enter your Username and Password at Gmail. In addition to that; now try www.youtube.com . You are automatically signed in. You do not have to enter your username and password at YouTube. Tip : Notice the URL of the web browser. Each time you access an application, you see that you are being redirected to https://accounts.google.com/ServiceLogin and return immediately back to the website. Single Sign-On (SSO) allows you to sign in only once but provides access to multiple resources without having to re-enter your username and password.","title":"SSO in reality"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#supported-protocols-for-sso","text":"The following are the supported protocols for agent-based single sign-on. SAML 2.0 WS-Federation OpenID Connect WS-Trust The following sections in this topic expand on these protocols and provide details pertaining to them.","title":"Supported protocols for SSO"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#saml-20-sso","text":"SAML stands for Security Assertion Markup Language, which is an XML-based data format for exchanging authentication and authorization data between an identity provider and a service provider. The single most important requirement that SAML addresses is web browser single sign-on (SSO). Three main roles are defined in SAML Specification. The Principal : This is typically the user who requires a service from a service provider entity. The Identity Provider : The SAML authority that provides the identity assertion to authenticate a principal. The Service Provider : The SAML consumer that provides the service for principals. The main use case scenario covered by SAML is the principal (the user) requesting access to a resource or service from the service provider. Then the service provider, using SAML, communicates with the identity provider to obtain identity assertion. The service provider makes the access control decision, depending on this assertion. SAML 2.0 is the latest version of SAML, which uses security tokens containing assertions to pass information about a user between an identity provider and a service provider. SAML 2.0 provides five main specifications: Core Bindings Profiles Metadata Conformances","title":"SAML 2.0 SSO"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#saml-20-web-browser-based-sso-profile","text":"SAML 2.0 Web Browser based SSO profile is defined under the SAML 2.0 Profiles specification. In a web browser based SSO system, the flow can be started by the user either by attempting to access a service at the service provider or by directly accessing the identity provider itself. If the user accesses a service at a service provider: The service provider determines which identity provider to use (this is the case when there are multiple identity providers. SAML identity provider discovery profile may be used). The service provider generates a SAML message and then redirects the web browser to the identity provider along with the message. Identity provider authenticates the user. The identity provider generates a SAML message and then redirects the web browser back to the service provider. The service provider processes the SAML message and decides to grant or deny access to the user. If the user accesses the identity provider directly, then only the steps 3, 4 and 5 are in the flow. The following diagram depicts this flow. Figure : SAML 2.0 authentication flow The message MUST contain an element that uniquely identifies the service provider who created the message. Optionally, the message may contain elements such as Issuer, NameIDPolicy, etc. More information regarding the message can be found in SAML Core Specification . {.expand-control-image}Click here for more information on assertion consumers, the authentication request and response.","title":"SAML 2.0 web browser-based SSO profile"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#saml-20-sso-assertion-consumers","text":"Service providers act as SAML assertion consumers. They have two basic functions: Create messages and redirect users to the identity provider with the created message. Process messages from the identity provider and make decisions based on them. The following code is a sketch of a sample service provider servlet in a SAML 2.0 web browser-based SSO system. public class Resource extends HttpServlet { private static SamlConsumer consumer = new SamlConsumer (); public void doGet ( HttpServletRequest request , HttpServletResponse response ) { requestMessage = consumer . buildRequestMessage (); response . sendRedirect ( requestMessage ); } public void doPost ( HttpServletRequest request , HttpServletResponse response ) { responseMessage = request . getParameter ( SAMLResponse ). toString (); result = consumer . processResponseMessage ( responseMessage ); } } When a web user attempts to access the above servlet, its doGet() method is called. Inside the doGet() method, it generates an message and then redirects the user to the identity provider. After authentication is completed by the identity provider, it does a POST callback to the above servlet with a message. Then the doPost() method of the servlet gets called and inside the doPost() method, it retrieves the message from the request and then the message is passed to the SamlConsumer instance for processing.","title":"SAML 2.0 SSO assertion consumers"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#authnrequest-message","text":"To create an AuthnRequest message using the OpenSAML library, do the following. Add the OpenSAML library to the build path of the project. You can download the OpenSAML .jar file from here . A sample AuthnRequest message can be found here . According to SAML 2.0 specifications, the message must contain an element. Create the Issuer element first. String issuerId = saml2.sso.demo ; IssuerBuilder issuerBuilder = new IssuerBuilder (); Issuer issuer = issuerBuilder . buildObject ( urn:oasis:names:tc:SAML:2.0:assertion , Issuer , samlp ); issuer . setValue ( issuerId ); Create the AuthnRequest next. // the issuerUrl is the url of the service provider who generates the message String issuerUrl = http://localhost:8080/saml2.sso.demo/consumer ; DateTime issueInstant = new DateTime (); AuthnRequestBuilder authnRequestBuilder = new AuthnRequestBuilder (); AuthnRequest authnRequest = authnRequestBuilder . buildObject ( urn:oasis:names:tc:SAML:2.0:protocol , AuthnRequest , samlp ); authnRequest . setForceAuthn ( false ); authnRequest . setIsPassive ( false ); authnRequest . setIssueInstant ( issueInstant ); authnRequest . setProtocolBinding ( urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST ); authnRequest . setAssertionConsumerServiceURL ( issuerUrl ); authnRequest . setIssuer ( issuer ); authnRequest . setID ( aRandomId ); authnRequest . setVersion ( SAMLVersion . VERSION_20 ); The message may contain many other elements like \",\" etc. those elements can be created and added to the message in the same way. Next encode the message. Marshaller marshaller = Configuration . getMarshallerFactory (). getMarshaller ( authnRequest ); Element authDOM = marshaller . marshall ( authnRequest ); StringWriter rspWrt = new StringWriter (); XMLHelper . writeNode ( authDOM , rspWrt ); String requestMessage = rspWrt . toString (); Deflater deflater = new Deflater ( Deflater . DEFLATED , true ); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream (); DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream ( byteArrayOutputStream , deflater ); deflaterOutputStream . write ( requestMessage . getBytes ()); deflaterOutputStream . close (); /* Encoding the compressed message */ String encodedRequestMessage = Base64 . encodeBytes ( byteArrayOutputStream . toByteArray (), Base64 . DONT_BREAK_LINES ); String encodedAuthnRequest = URLEncoder . encode ( encodedRequestMessage , UTF-8 ). trim (); Construct the redirection URL. redirectionUrl = identitypProviderUrl + ?SAMLRequest= + encodedRequestMessage ; Redirect the user to the identity provider. response . sendRedirect ( redirectionUrl );","title":"&lt;AuthnRequest&gt; message"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#response-message","text":"The Identity provider must use HTTP POST or artifact binding to transfer the SAMLResponse message to the service provider. To read the Response message issued by the WSO2 Identity Server, do the following: A sample Response message can be found here . The response message must be fetched from the request. responseMessage = request . getParameter ( SAMLResponse ). toString (); The fetched responseMessage is unmarshaled and the SAML message is retrieved. DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance (); documentBuilderFactory . setNamespaceAware ( true ); DocumentBuilder docBuilder = documentBuilderFactory . newDocumentBuilder (); byte [] base64DecodedResponse = Base64 . decode ( responseMessage ); ByteArrayInputStream is = new ByteArrayInputStream ( base64DecodedResponse ); Document document = docBuilder . parse ( is ); Element element = document . getDocumentElement (); UnmarshallerFactory unmarshallerFactory = Configuration . getUnmarshallerFactory (); Unmarshaller unmarshaller = unmarshallerFactory . getUnmarshaller ( element ); Response response = ( Response ) unmarshaller . unmarshall ( element ); The retrieved SAML 2.0 response message can be easily processed. For example, let's take the username or the subject's NameID . String subject = response . getAssertions (). get ( 0 ). getSubject () . getNameID (). getValue (); Alternatively, if the response is signed by the identity provider, you can retrieve the certificate. String certificate = response . getSignature (). getKeyInfo (). getX509Datas (). get ( 0 ). getX509Certificates (). get ( 0 ). getValue ();","title":"&lt;Response&gt; message"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#identity-provider-initiated-sso","text":"To initiate IdP Initiated SSO you need to perform a HTTP GET/POST to the following URL (assume the registered service provider issuer ID is foo.com ). The SAML protocol message can be encoded using Base64 encoding. https://localhost:9443/samlsso?spEntityID=foo.com This request will authenticate and redirect the user to the registered Assertion Consumer URL. Optionally, you can send in a RelayState parameter as follows: https://localhost:9443/samlsso?spEntityID=foo.com RelayState=http://localhost:8080/foo.com/my-home.jsp The RelayState parameter must be URL encoded. This request will authenticate and redirect the user to the URL in the RelayState parameter itself. Either you could have service provider initiated SSO only, or service provider initiated SSO and identity provider initiated SSO. You cannot have only identity provider initiated SSO. By design, service provider initiated SSO is more restrictive and secure. If a service provider is allowed to do identity provider initiated SSO, it would automatically imply that this service provider is allowed to do service provider initiated SSO as well. Recommended reading See SAML 2.0 specification documentation for more information.","title":"Identity provider initiated SSO"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#ws-federation","text":"WS-Federation (Web Services Federation) describes the management and brokering of trust relationships and security token exchange across Web services and organizational boundaries. WS-Federation is a part of the larger WS-Security framework. For example, WS-Federation builds on the Security Token Service (STS) by providing mechanisms that facilitate interactions. In the WS-Federation Model, an Identity Provider is a Security Token Service (STS). Recommended reading See WS-Federation specification documentation for more information.","title":"WS-Federation"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#openid-connect","text":"OpenID Connect is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. OpenID Connect allows clients of all types, including Web-based, mobile, and JavaScript clients, to request and receive information about authenticated sessions and end-users. The specification suite is extensible, allowing participants to use optional features such as encryption of identity data, discovery of OpenID Providers, and session management, when it makes sense for them. Recommended reading See OpenID Connect specification documentation for more information.","title":"OpenID Connect"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#ws-trust","text":"The \"Security Token Service\" (STS) component of WSO2 Identity Server enables you to configure the generic STS to issue claim-based security tokens. A claim-based security token is a common way for applications to acquire and authenticate the identity information they need about users inside their organization, in other organizations, and on the Internet. This Security Token Service is capable of issuing SAML 1.1 and SAML 2.0 tokens as recommended in WS-Trust and SAML Web Service Token Profile specifications. The WSDL of this service can be accessed by clicking this URL: https://(hostname):(port)/services/wso2carbon-sts?wsdl . For instance, with the default configuration, the URL is https://localhost:9443/services/wso2carbon-sts?wsdl . Both SAML 1.1 and SAML 2.0 token types are supported by default. The issued token type is decided based on the type of token defined in the RST (Request Security Token). Currently, the Bearer Subject Confirmation and Holder-Of-Key subject confirmation methods are both supported. With Holder-Of-Key, both Symmetric and Asymmetric key types are supported. You can obtain tokens containing claims that hold certain information about the subject. These claims can be extracted from the profiles or through custom claim callbacks which can be registered to the Carbon runtime. Related Topics See WS-Trust specification documentation for more information. See Configuring WS-Trust Security Token Service to configure WS-Trust in WSO2 Identity Server.","title":"WS-Trust"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#identity-federation-and-a-comparison-with-sso","text":"Identity and access management requirements are rapidly evolving over the years. Organizations cannot survive with authentication and authorization mechanisms that only span a single boundary of trust. Hence, these organizations often provide and consume services across trust boundaries, which may include partners, subsidiaries, customers or suppliers and may span across multiple buildings, cities, states, countries and even continents. Identity federation and Single Sign On (SSO) come into the picture to provide and consume these services across trust boundaries. Identity federation and SSO have similarities as well as key differences. Identity federation enables users to access multiple applications using the same access credentials. This makes access easy, as users do not have to remember a different set of credentials for every application they use. However, the users have to provide their credentials to each one of the applications separately although the credentials used are the same. On the other hand, SSO enables users to provide their credentials once and obtain access to multiple applications. In SSO, the users are not prompted for their credentials when accessing each application until their session is terminated.","title":"Identity federation and a comparison with SSO"},{"location":"Concepts/Single_Sign-On_and_Identity_Federation/#attachments","text":"{width=\"8\" height=\"8\"} image2017-6-15_23-10-49.png (image/png) {width=\"8\" height=\"8\"} image2017-6-15_23-6-13.png (image/png) {width=\"8\" height=\"8\"} image2017-6-15_23-2-15.png (image/png) {width=\"8\" height=\"8\"} image2017-2-15 15:58:36.png (image/png) {width=\"8\" height=\"8\"} image2017-2-15 16:41:33.png (image/png) {width=\"8\" height=\"8\"} image2017-2-15 19:30:0.png (image/png)","title":"Attachments:"},{"location":"Develop/federate/Writing_a_Custom_Federated_Authenticator/","text":"Writing a Custom Federated Authenticator It is possible to use the extension points available in the WSO2 Identity Server to create custom federated authenticators. See the following topics to create different custom authenticators. Authenticator API Writing a custom authenticator for Twitter Custom authenticator for Facebook Custom authenticator for Google Authenticator API The following is the API used to implement a custom federated authenticator. /* * Copyright (c) 2005-2013, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License ); you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authentication.framework ; import java.io.Serializable ; import java.util.List ; import javax.servlet.http.HttpServletRequest ; import javax.servlet.http.HttpServletResponse ; import org.wso2.carbon.identity.application.authentication.framework.context.AuthenticationContext ; import org.wso2.carbon.identity.application.authentication.framework.exception.AuthenticationFailedException ; import org.wso2.carbon.identity.application.authentication.framework.exception.LogoutFailedException ; import org.wso2.carbon.identity.application.common.model.Property ; /** * API of the Application Authenticators. * */ public interface ApplicationAuthenticator extends Serializable { /** * Check whether the authentication or logout request can be handled by the * authenticator * * @param request * @return boolean */ public boolean canHandle ( HttpServletRequest request ); /** * Process the authentication or logout request. * * @param request * @param response * @param context * @return the status of the flow * @throws AuthenticationFailedException * @throws LogoutFailedException */ public AuthenticatorFlowStatus process ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException , LogoutFailedException ; /** * Get the Context identifier sent with the request. This identifier is used * to retrieve the state of the authentication/logout flow * * @param request * @return */ public String getContextIdentifier ( HttpServletRequest request ); /** * Get the name of the Authenticator * @return name */ public String getName (); /** * @return */ public String getFriendlyName (); /** * Get the claim dialect URI if this authenticator receives claims in a standard dialect * and needs to be mapped to the Carbon dialect http://wso2.org/claims * @return boolean */ public String getClaimDialectURI (); /** * @return */ public List Property getConfigurationProperties (); } This API can be used to configure a custom authenticator. As an example, a Twitter authenticator is configured using the above API. Writing a custom authenticator for Twitter The WSO2 Identity Server comes with several built in authenticators like Facebook, Google, OpenID, and SAML. This topic provides instructions on how to authenticate users via Twitter using the SAML configurations available in the Identity Server. Related links See here for information on browser sign in flow. This information is useful when working with websites and applications that are able to open or embed a web browser. See here for information on implementing the sign in functionality using Twitter. If you are doing this using Java, there is a library you can use called twitter4j . See the link for code samples on signing in with Twitter. The following code block represents the structure of an authenticator pom.xml . Authenticators are basically OSGi (Open Service Gateway initiative) bundles, which are units of modularization that are comprised of Java classes and other resources that provide functions to end users. The pom.xml includes the dependencies for the project. Other than the twitter4j dependency, other dependencies are mandatory. {.expand-control-image}Click here to expand and view the code block ?xml version= 1.0 encoding= utf-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd groupId org.emojotFoundation /groupId modelVersion 4.0.0 /modelVersion artifactId authenticator-twitter /artifactId packaging bundle /packaging version 1.0.0 /version dependencies dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.logging /artifactId version 4.2.0 /version /dependency dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.identity.application.authentication.framework /artifactId version 4.2.2 /version /dependency dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.ui /artifactId version 4.2.0 /version /dependency dependency groupId org.apache.amber.wso2 /groupId artifactId amber /artifactId version 0.22.1358727.wso2v4 /version /dependency dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.identity.application.common /artifactId version 4.2.0 /version /dependency dependency groupId org.twitter4j /groupId artifactId twitter4j-core /artifactId version [4.0,) /version /dependency /dependencies repositories repository id wso2-nexus /id name WSO2 Internal Repository /name url http://maven.wso2.org/nexus/content/groups/wso2-public/ /url releases enabled true /enabled updatePolicy daily /updatePolicy checksumPolicy ignore /checksumPolicy /releases /repository repository id twitter4j.org /id name twitter4j.org Repository /name url http://twitter4j.org/maven2 /url releases enabled true /enabled /releases snapshots enabled true /enabled /snapshots /repository /repositories build plugins plugin groupId org.apache.felix /groupId artifactId maven-scr-plugin /artifactId version 1.7.4 /version executions execution id generate-scr-scrdescriptor /id goals goal scr /goal /goals /execution /executions /plugin plugin groupId org.apache.felix /groupId artifactId maven-bundle-plugin /artifactId extensions true /extensions configuration instructions Bundle-SymbolicName ${project.artifactId} /Bundle-SymbolicName Bundle-Name ${project.artifactId} /Bundle-Name Private-Package org.emojotFoundation.authenticator.twitter.internal /Private-Package Import-Package org.twitter4j.*; version= [4.0,) , org.apache.axis2.*; version= [1.6.1.wso2v1, 1.7.0) , org.apache.axiom.*; version= [1.2.11.wso2v2, 1.3.0) , org.wso2.carbon.ui.*, org.apache.commons.logging.*; version= 1.0.4 , org.osgi.framework, org.wso2.carbon.identity.application.authentication.framework.*, javax.servlet;version= [2.6.0,3.0.0) , javax.servlet.http;version= [2.6.0,3.0.0) , *;resolution:=optional /Import-Package Export-Package !org.emojotFoundation.authenticator.twitter.internal, org.emojotFoundation.authenticator.twitter.* /Export-Package DynamicImport-Package * /DynamicImport-Package /instructions /configuration /plugin /plugins /build /project Since the project is an OSGi bundle, you must add this class to define the bundle activate method and deactivate method. {.expand-control-image}Click here to expand and view the class used to define the bundle activate method and deactivate method package org.emojotFoundation.authenticator.twitter.internal ; import java.util.Hashtable ; import org.apache.commons.logging.Log ; import org.apache.commons.logging.LogFactory ; import org.osgi.service.component.ComponentContext ; import org.wso2.carbon.identity.application.authentication.framework.ApplicationAuthenticator ; import org.emojotFoundation.authenticator.twitter.TwitterAuthenticator ; /** * @scr.component name= authenticator.twitter immediate= true */ public class TwitterAuthenticatorServiceComponent { private static final Log LOGGER = LogFactory . getLog ( TwitterAuthenticatorServiceComponent . class ); protected void activate ( ComponentContext ctxt ) { try { TwitterAuthenticator twitterAuthenticator = new TwitterAuthenticator (); Hashtable String , String props = new Hashtable String , String () ctxt . getBundleContext (). registerService ( ApplicationAuthenticator . class . getName (), twitterAuthenticator , props ); LOGGER . info ( ----Twitter Authenticator bundle is activated---- ); } catch ( Throwable e ) { LOGGER . fatal ( ----Error while activating Twitter authenticator---- , e ); } } protected void deactivate ( ComponentContext ctxt ) { LOGGER . info ( ----Twitter Authenticator bundle is deactivated---- ); } } After adding this to your project, you are in a position to write your authenticator. Authenticators are defined by extending the AbstractApplicationAuthenticator class and implementing the FederatedApplicationAuthenticator interface. The important methods in the AbstractApplicationAuthenticator class and the FederatedApplicationAuthenticator interface are listed as follows. public String getName() public String getFriendlyName() public String getContextIdentifier(HttpServletRequest request) - Returns a unique identifier that will map the authentication request and the response. The value returned by the invocation of authentication request and the response should be the same. public boolean canHandle(HttpServletRequest request) - Specifies whether this authenticator can handle the authentication response. protected void initiateAuthenticationRequest(HttpServletRequest request,HttpServletResponse response, AuthenticationContext context) protected void processAuthenticationResponse(HttpServletRequest request,HttpServletResponse response, AuthenticationContext context) Use the following steps to write the Twitter authenticator. Implement the canHandle() method using the above methods. When Twitter sends the OAuth response, it sends the parameters oauth_token and oauth_verifier in the request. This is a notification to identify that this response can be handled by the authenticator. {.expand-control-image}Click here to expand and view a sample canHandle() method public boolean canHandle ( HttpServletRequest request ) { if ( request . getParameter ( oauth_token )!= null request . getParameter ( oauth_verifier )!= null ) { return true ; } return false ; } For each authentication request that comes into the Identity Server, there is unique value that comes along as a parameter. That parameter is the sessionDataKey . Store this in the Twitter authentication redirection session to facilitate the requirement where getContextIdentifier gives the same value for authentication request and its response. {.expand-control-image}Click here to expand and view getContextIdentifier() public String getContextIdentifier ( HttpServletRequest request ) { if ( request . getSession (). getAttribute ( contextIdentifier )== null ){ request . getSession (). setAttribute ( contextIdentifier , request . getParameter ( sessionDataKey )); return request . getParameter ( sessionDataKey ); } else { return ( String ) request . getSession (). getAttribute ( contextIdentifier ); } } Next, implement the initiateAuthenticationRequest method and the processAuthenticationResponse method as follows. {.expand-control-image}Click here to expand and view the initiateAuthenticationRequest method and processAuthenticationResponse method protected void initiateAuthenticationRequest ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { String apiKey = resourceBundle . getString ( API_Key ); String apiSecret = resourceBundle . getString ( API_Secret ); Twitter twitter = new TwitterFactory (). getInstance (); twitter . setOAuthConsumer ( apiKey , apiSecret ); try { String callbackURL = resourceBundle . getString ( Call_Back_URL ); RequestToken requestToken = twitter . getOAuthRequestToken ( callbackURL . toString ()); request . getSession (). setAttribute ( requestToken , requestToken ); request . getSession (). setAttribute ( twitter , twitter ); response . sendRedirect ( requestToken . getAuthenticationURL ()); } catch ( TwitterException e ) { LOGGER . error ( Exception while sending to the Twitter login page. , e ); throw new AuthenticationFailedException ( e . getMessage (), e ); } catch ( IOException e ) { LOGGER . error ( Exception while sending to the Twitter login page. , e ); throw new AuthenticationFailedException ( e . getMessage (), e ); } return ; } protected void processAuthenticationResponse ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { Twitter twitter = ( Twitter ) request . getSession (). getAttribute ( twitter ); RequestToken requestToken = ( RequestToken ) request . getSession (). getAttribute ( requestToken ); String verifier = request . getParameter ( oauth_verifier ); try { AccessToken token = twitter . getOAuthAccessToken ( requestToken , verifier ); request . getSession (). removeAttribute ( requestToken ); User user = twitter . verifyCredentials (); buildClaims ( user , context ); } catch ( TwitterException e ) { LOGGER . error ( Exception while obtaining OAuth token form Twitter , e ); throw new AuthenticationFailedException ( Exception while obtaining OAuth token form Twitter , e ); } } public void buildClaims ( User user , AuthenticationContext context ) { context . setSubject ( String . valueOf ( user . getId ())); Map ClaimMapping , String claims = new HashMap ClaimMapping , String (); claims . put ( ClaimMapping . build ( name , name , null , false ), user . getName ()); claims . put ( ClaimMapping . build ( screen_name , screen_name , null , false ), user . getScreenName ()); claims . put ( ClaimMapping . build ( url , url , null , false ), user . getURL ()); context . setSubjectAttributes ( claims ); } The buildClaims method saves the retrieved user attributes to the authenticated context in the Identity Server. That is needed to map the claims to the built in claims of IS. After implementing these methods you can build your bundle. After building it you have to put that into the IS_HOME /repository/components/dropins directory. Restart the Identity Server to use the Twitter authenticator in IS. Custom authenticator for Facebook This section includes the code used to write the custom authenticator for Facebook. Download the source code from here using the following command on your terminal. $ svn checkout https : //svn.wso2.org/repos/wso2/people/isura/org.wso2.carbon.identity.application.authenticator.social/ Navigate to the folder you just downloaded, which contains the pom.xml file and build the source code by running the following command on your terminal. $ mvn clean install Copy the org.wso2.carbon.identity.application.authenticator.social.facebook2-5.0.0.jar file found inside the target folder and paste it in the IS_HOME /repository/components/dropins folder. The source code is as follows. /* * Copyright (c) 2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.social.facebook2 \u037e import org.apache.commons.lang.StringUtils \u037e import org.apache.commons.logging.Log \u037e import org.apache.commons.logging.LogFactory \u037e import org.apache.oltu.oauth2.client.request.OAuthClientRequest \u037e import org.apache.oltu.oauth2.client.response.OAuthAuthzResponse \u037e import org.apache.oltu.oauth2.common.exception.OAuthProblemException \u037e import org.apache.oltu.oauth2.common.exception.OAuthSystemException \u037e import org.apache.oltu.oauth2.common.utils.JSONUtils \u037e import org.wso2.carbon.identity.application.authentication.framework.AbstractApplicationAuthenticator \u037e import org.wso2.carbon.identity.application.authentication.framework.FederatedApplicationAuthenticator \u037e import org.wso2.carbon.identity.application.authentication.framework.context.AuthenticationContext \u037e import org.wso2.carbon.identity.application.authentication.framework.exception.ApplicationAuthenticatorException \u037e import org.wso2.carbon.identity.application.authentication.framework.exception.AuthenticationFailedException \u037e import org.wso2.carbon.identity.application.authentication.framework.model.AuthenticatedUser \u037e import org.wso2.carbon.identity.application.authentication.framework.util.FrameworkConstants \u037e import org.wso2.carbon.identity.application.authentication.framework.util.FrameworkUtils \u037e import org.wso2.carbon.identity.application.common.model.ClaimMapping \u037e import org.wso2.carbon.identity.application.common.model.Property \u037e import org.wso2.carbon.identity.application.common.util.IdentityApplicationConstants \u037e import org.wso2.carbon.identity.base.IdentityConstants \u037e import org.wso2.carbon.identity.core.util.IdentityUtil \u037e import org.wso2.carbon.identity.core.util.IdentityIOStreamUtils \u037e import javax.servlet.http.HttpServletRequest \u037e import javax.servlet.http.HttpServletResponse \u037e import java.io.BufferedReader \u037e import java.io.IOException \u037e import java.io.InputStreamReader \u037e import java.net.MalformedURLException \u037e import java.net.URL \u037e import java.net.URLConnection \u037e import java.nio.charset.Charset \u037e import java.util.* \u037e public class FacebookCustomAuthenticator extends AbstractApplicationAuthenticator implements FederatedApplicationAuthenticator { private static final Log log = LogFactory . getLog ( FacebookCustomAuthenticator . class ) \u037e private static final long serialVersionUID = \u00ad 1465329490183756028 L \u037e private String tokenEndpoint \u037e private String oAuthEndpoint \u037e private String userInfoEndpoint \u037e /** * initiate tokenEndpoint */ private void initTokenEndpoint () { this . tokenEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( FacebookCustomAuthenticatorConstants . FB_TOKEN_URL ) \u037e if ( StringUtils . isBlank ( this . tokenEndpoint )) { this . tokenEndpoint = IdentityApplicationConstants . FB_TOKEN_URL \u037e } } /** * initiate authorization server endpoint */ private void initOAuthEndpoint () { this . oAuthEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( FacebookCustomAuthenticatorConstants . FB_AUTHZ_URL ) \u037e if ( StringUtils . isBlank ( this . oAuthEndpoint )) { this . oAuthEndpoint = IdentityApplicationConstants . FB_AUTHZ_URL \u037e } } /** * initiate userInfoEndpoint */ private void initUserInfoEndPoint () { this . userInfoEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( FacebookCustomAuthenticatorConstants . FB_USER_INFO_URL ) \u037e if ( StringUtils . isBlank ( this . userInfoEndpoint )) { this . userInfoEndpoint = IdentityApplicationConstants . FB_USER_INFO_URL \u037e } } /** * get the tokenEndpoint. * @return tokenEndpoint */ private String getTokenEndpoint () { if ( StringUtils . isBlank ( this . tokenEndpoint )) { initTokenEndpoint () \u037e } return this . tokenEndpoint \u037e } /** * get the oAuthEndpoint. * @return oAuthEndpoint */ private String getAuthorizationServerEndpoint () { if ( StringUtils . isBlank ( this . oAuthEndpoint )) { initOAuthEndpoint () \u037e } return this . oAuthEndpoint \u037e } /** * get the userInfoEndpoint. * @return userInfoEndpoint */ private String getUserInfoEndpoint () { if ( StringUtils . isBlank ( this . userInfoEndpoint )) { initUserInfoEndPoint () \u037e } return this . userInfoEndpoint \u037e } @Override public boolean canHandle ( HttpServletRequest request ) { log . trace ( Inside FacebookAuthenticator.canHandle() ) \u037e if ( request . getParameter ( FacebookCustomAuthenticatorConstants . OAUTH2_GRANT_TYPE_CODE ) != null request . getParameter ( FacebookCustomAuthenticatorConstants . OAUTH2_PARAM_STATE ) != null FacebookCustomAuthenticatorConstants . FACEBOOK_LOGIN_TYPE . equals ( getLoginType ( request ))) { return true \u037e } return false \u037e } @Override protected void initiateAuthenticationRequest ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { try { Map authenticatorProperties = context . getAuthenticatorProperties () \u037e String clientId = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . CLIENT_ID ) \u037e String authorizationEP = getAuthorizationServerEndpoint () \u037e String scope = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . SCOPE ) \u037e if ( StringUtils . isEmpty ( scope )) { scope = FacebookCustomAuthenticatorConstants . EMAIL \u037e } String callbackUrl = IdentityUtil . getServerURL ( FrameworkConstants . COMMONAUTH , true , true ) \u037e String state = context . getContextIdentifier () + , + FacebookCustomAuthenticatorConstants . FACEBOOK_LOGIN_TYPE \u037e OAuthClientRequest authzRequest = OAuthClientRequest . authorizationLocation ( authorizationEP ) . setClientId ( clientId ) . setRedirectURI ( callbackUrl ) . setResponseType ( FacebookCustomAuthenticatorConstants . OAUTH2_GRANT_TYPE_CODE ) . setScope ( scope ). setState ( state ) . buildQueryMessage () \u037e response . sendRedirect ( authzRequest . getLocationUri ()) \u037e } catch ( IOException e ) { log . error ( Exception while sending to the login page. , e ) \u037e throw new AuthenticationFailedException ( e . getMessage (), e ) \u037e } catch ( OAuthSystemException e ) { log . error ( Exception while building authorization code request. , e ) \u037e throw new AuthenticationFailedException ( e . getMessage (), e ) \u037e } return \u037e } @Override protected void processAuthenticationResponse ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { log . trace ( Inside FacebookAuthenticator.authenticate() ) \u037e try { Map authenticatorProperties = context . getAuthenticatorProperties () \u037e String clientId = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . CLIENT_ID ) \u037e String clientSecret = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . CLIENT_SECRET ) \u037e String userInfoFields = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . USER_INFO_FIELDS ) \u037e String tokenEndPoint = getTokenEndpoint () \u037e String fbauthUserInfoUrl = getUserInfoEndpoint () \u037e String callbackUrl = IdentityUtil . getServerURL ( FrameworkConstants . COMMONAUTH , true , true ) \u037e String code = getAuthorizationCode ( request ) \u037e String token = getToken ( tokenEndPoint , clientId , clientSecret , callbackUrl , code ) \u037e if (! StringUtils . isBlank ( userInfoFields )) { if ( context . getExternalIdP (). getIdentityProvider (). getClaimConfig () != null ! StringUtils . isBlank ( context . getExternalIdP (). getIdentityProvider (). getClaimConfig (). getUserClaimURI ())) { String userClaimUri = context . getExternalIdP (). getIdentityProvider (). getClaimConfig () . getUserClaimURI () \u037e if (! Arrays . asList ( userInfoFields . split ( , )). contains ( userClaimUri )) { userInfoFields += ( , + userClaimUri ) \u037e } } else { if (! Arrays . asList ( userInfoFields . split ( , )). contains ( FacebookCustomAuthenticatorConstants . DEFAULT_USER_IDENTIFIER )) { userInfoFields += ( , + FacebookCustomAuthenticatorConstants . DEFAULT_USER_IDENTIFIER ) \u037e } } } Map userInfoJson = getUserInfoJson ( fbauthUserInfoUrl , userInfoFields , token ) \u037e buildClaims ( context , userInfoJson ) \u037e } catch ( ApplicationAuthenticatorException e ) { log . error ( Failed to process Facebook Connect response. , e ) \u037e throw new AuthenticationFailedException ( e . getMessage (), e ) \u037e } } private String getAuthorizationCode ( HttpServletRequest request ) throws ApplicationAuthenticatorException { OAuthAuthzResponse authzResponse \u037e try { authzResponse = OAuthAuthzResponse . oauthCodeAuthzResponse ( request ) \u037e return authzResponse . getCode () \u037e } catch ( OAuthProblemException e ) { throw new ApplicationAuthenticatorException ( Exception while reading authorization code. , e ) \u037e } } private String getToken ( String tokenEndPoint , String clientId , String clientSecret , String callbackurl , String code ) throws ApplicationAuthenticatorException { OAuthClientRequest tokenRequest = null \u037e String token = null \u037e try { tokenRequest = buidTokenRequest ( tokenEndPoint , clientId , clientSecret , callbackurl , code ) \u037e token = sendRequest ( tokenRequest . getLocationUri ()) \u037e if ( token . startsWith ( { )) { throw new ApplicationAuthenticatorException ( Received access token is invalid. ) \u037e } } catch ( MalformedURLException e ) { if ( log . isDebugEnabled ()) { log . debug ( URL : + tokenRequest . getLocationUri ()) \u037e } throw new ApplicationAuthenticatorException ( MalformedURLException while sending access token request. , e ) \u037e } catch ( IOException e ) { throw new ApplicationAuthenticatorException ( IOException while sending access token request. , e ) \u037e } return token \u037e } private OAuthClientRequest buidTokenRequest ( String tokenEndPoint , String clientId , String clientSecret , String callbackurl , String code ) throws ApplicationAuthenticatorException { OAuthClientRequest tokenRequest = null \u037e try { tokenRequest = OAuthClientRequest . tokenLocation ( tokenEndPoint ). setClientId ( clientId ) . setClientSecret ( clientSecret ) . setRedirectURI ( callbackurl ). setCode ( code ) . buildQueryMessage () \u037e } catch ( OAuthSystemException e ) { throw new ApplicationAuthenticatorException ( Exception while building access token request. , e ) \u037e } return tokenRequest \u037e } private String getUserInfoString ( String fbAuthUserInfoUrl , String userInfoFields , String token ) throws ApplicationAuthenticatorException { String userInfoString \u037e try { if ( StringUtils . isBlank ( userInfoFields )) { userInfoString = sendRequest ( String . format ( %s?%s , fbAuthUserInfoUrl , token )) \u037e } else { userInfoString = sendRequest ( String . format ( %s?fields=%s %s , fbAuthUserInfoUrl , userInfoFields , token )) \u037e } } catch ( MalformedURLException e ) { if ( log . isDebugEnabled ()) { log . debug ( URL : + fbAuthUserInfoUrl , e ) \u037e } throw new ApplicationAuthenticatorException ( MalformedURLException while sending user information request. , e ) \u037e } catch ( IOException e ) { throw new ApplicationAuthenticatorException ( IOException while sending sending user information request. , e ) \u037e } return userInfoString \u037e } private void setSubject ( AuthenticationContext context , Map jsonObject ) throws ApplicationAuthenticatorException { String authenticatedUserId = ( String ) jsonObject . get ( FacebookCustomAuthenticatorConstants . DEFAULT_USER_IDENTIFIER ) \u037e if ( StringUtils . isEmpty ( authenticatedUserId )) { throw new ApplicationAuthenticatorException ( Authenticated user identifier is empty ) \u037e } AuthenticatedUser authenticatedUser = AuthenticatedUser . createFederateAuthenticatedUserFromSubjectIdentifier ( authenticatedUserId ) \u037e context . setSubject ( authenticatedUser ) \u037e } private Map getUserInfoJson ( String fbAuthUserInfoUrl , String userInfoFields , String token ) throws ApplicationAuthenticatorException { String userInfoString = getUserInfoString ( fbAuthUserInfoUrl , userInfoFields , token ) \u037e if ( log . isDebugEnabled () IdentityUtil . isTokenLoggable ( IdentityConstants . IdentityTokens . USER_ID_TOKEN )) { log . debug ( UserInfoString : + userInfoString ) \u037e } Map jsonObject = JSONUtils . parseJSON ( userInfoString ) \u037e return jsonObject \u037e } public void buildClaims ( AuthenticationContext context , Map jsonObject ) throws ApplicationAuthenticatorException { if ( jsonObject != null ) { Map claims = new HashMap () \u037e for ( Map . Entry entry : jsonObject . entrySet ()) { claims . put ( ClaimMapping . build ( entry . getKey (), entry . getKey (), null , false ), entry . getValue (). toString ()) \u037e if ( log . isDebugEnabled () IdentityUtil . isTokenLoggable ( IdentityConstants . IdentityTokens . USER_CLAIMS )) { log . debug ( Adding claim mapping : + entry . getKey () + + entry . getKey () + : + entry . getValue ()) \u037e } } if ( StringUtils . isBlank ( context . getExternalIdP (). getIdentityProvider (). getClaimConfig (). getUserClaimURI ())) { context . getExternalIdP (). getIdentityProvider (). getClaimConfig (). setUserClaimURI ( FacebookCustomAuthenticatorConstants . EMAIL ) \u037e } String subjectFromClaims = FrameworkUtils . getFederatedSubjectFromClaims ( context . getExternalIdP (). getIdentityProvider (), claims ) \u037e if ( subjectFromClaims != null ! subjectFromClaims . isEmpty ()) { AuthenticatedUser authenticatedUser = AuthenticatedUser . createFederateAuthenticatedUserFromSubjectIdentifier ( subjectFromClaims ) \u037e context . setSubject ( authenticatedUser ) \u037e } else { setSubject ( context , jsonObject ) \u037e } context . getSubject (). setUserAttributes ( claims ) \u037e } else { if ( log . isDebugEnabled ()) { log . debug ( Decoded json object is null ) \u037e } throw new ApplicationAuthenticatorException ( Decoded json object is null ) \u037e } } @Override public String getContextIdentifier ( HttpServletRequest request ) { log . trace ( Inside FacebookAuthenticator.getContextIdentifier() ) \u037e String state = request . getParameter ( FacebookCustomAuthenticatorConstants . OAUTH2_PARAM_STATE ) \u037e if ( state != null ) { return state . split ( , )[ 0 ] \u037e } else { return null \u037e } } private String sendRequest ( String url ) throws IOException { BufferedReader in = null \u037e StringBuilder b = new StringBuilder () \u037e try { URLConnection urlConnection = new URL ( url ). openConnection () \u037e in = new BufferedReader ( new InputStreamReader ( urlConnection . getInputStream (), Charset . forName ( utf\u00ad8 ))) \u037e String inputLine = in . readLine () \u037e while ( inputLine != null ) { b . append ( inputLine ). append ( \\n ) \u037e inputLine = in . readLine () \u037e } } finally { IdentityIOStreamUtils . closeReader ( in ) \u037e } return b . toString () \u037e } private String getLoginType ( HttpServletRequest request ) { String state = request . getParameter ( FacebookCustomAuthenticatorConstants . OAUTH2_PARAM_STATE ) \u037e if ( state != null ) { return state . split ( , )[ 1 ] \u037e } else { return null \u037e } } @Override public String getFriendlyName () { return Custom\u00adFacebook \u037e } @Override public String getName () { return FacebookCustomAuthenticatorConstants . AUTHENTICATOR_NAME \u037e } @Override public List getConfigurationProperties () { List configProperties = new ArrayList () \u037e Property clientId = new Property () \u037e clientId . setName ( FacebookCustomAuthenticatorConstants . CLIENT_ID ) \u037e clientId . setDisplayName ( Client Id ) \u037e clientId . setRequired ( true ) \u037e clientId . setDescription ( Enter Facebook client identifier value ) \u037e configProperties . add ( clientId ) \u037e Property clientSecret = new Property () \u037e clientSecret . setName ( FacebookCustomAuthenticatorConstants . CLIENT_SECRET ) \u037e clientSecret . setDisplayName ( Client Secret ) \u037e clientSecret . setRequired ( true ) \u037e clientSecret . setConfidential ( true ) \u037e clientSecret . setDescription ( Enter Facebook client secret value ) \u037e configProperties . add ( clientSecret ) \u037e Property scope = new Property () \u037e scope . setName ( FacebookCustomAuthenticatorConstants . SCOPE ) \u037e scope . setDisplayName ( Scope ) \u037e scope . setDescription ( Enter Facebook scopes ) \u037e scope . setDefaultValue ( id ) \u037e scope . setRequired ( false ) \u037e configProperties . add ( scope ) \u037e Property userIdentifier = new Property () \u037e userIdentifier . setName ( FacebookCustomAuthenticatorConstants . USER_INFO_FIELDS ) \u037e userIdentifier . setDisplayName ( User Identifier Field ) \u037e userIdentifier . setDescription ( Enter Facebook user identifier field ) \u037e userIdentifier . setDefaultValue ( id ) \u037e userIdentifier . setRequired ( false ) \u037e configProperties . add ( userIdentifier ) \u037e return configProperties \u037e } } /* * Copyright (c) 2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.social.facebook2 \u037e public class FacebookCustomAuthenticatorConstants { public static final String AUTHENTICATOR_NAME = FacebookAuthenticator\u00adCustom \u037e public static final String FACEBOOK_LOGIN_TYPE = facebook \u037e public static final String OAUTH2_GRANT_TYPE_CODE = code \u037e public static final String OAUTH2_PARAM_STATE = state \u037e public static final String EMAIL = email \u037e public static final String SCOPE = Scope \u037e public static final String USER_INFO_FIELDS = UserInfoFields \u037e public static final String DEFAULT_USER_IDENTIFIER = id \u037e public static final String CLIENT_ID = ClientId \u037e public static final String CLIENT_SECRET = ClientSecret \u037e public static final String FB_AUTHZ_URL = AuthnEndpoint \u037e public static final String FB_TOKEN_URL = AuthTokenEndpoint \u037e public static final String FB_USER_INFO_URL = UserInfoEndpoint \u037e private FacebookCustomAuthenticatorConstants () {} } /* * Copyright (c) WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.social.internal \u037e import org.apache.commons.logging.Log \u037e import org.apache.commons.logging.LogFactory \u037e import org.osgi.service.component.ComponentContext \u037e import org.wso2.carbon.identity.application.authentication.framework.ApplicationAuthenticator \u037e import org.wso2.carbon.identity.application.authenticator.social.facebook2.FacebookCustomAuthenticator \u037e import java.util.Hashtable \u037e /** * @scr.component name= identity.application.authenticator.facebook.component * immediate= true */ public class FacebookCustomAuthenticatorServiceComponent { private static final Log LOGGER = LogFactory . getLog ( FacebookCustomAuthenticatorServiceComponent . class ) \u037e protected void activate ( ComponentContext ctxt ) { try { FacebookCustomAuthenticator facebookAuthenticator = new FacebookCustomAuthenticator () \u037e Hashtable props = new Hashtable () \u037e ctxt . getBundleContext (). registerService ( ApplicationAuthenticator . class . getName (), facebookAuthenticator , props ) \u037e if ( LOGGER . isDebugEnabled ()) { LOGGER . debug ( Facebook Custome Authenticator bundle is activated ) \u037e } } catch ( Throwable e ) { LOGGER . fatal ( Error while activating Facebook authenticator , e ) \u037e } } protected void deactivate ( ComponentContext ctxt ) { if ( LOGGER . isDebugEnabled ()) { LOGGER . debug ( Facebook Custom Authenticator bundle is deactivated ) \u037e } } } Custom authenticator for Google This section includes the code used to write the custom authenticator for Google. Download the source code from here using the following command on your terminal. $ svn checkout https : //svn.wso2.org/repos/wso2/people/thanuja/org.wso2.carbon.identity.application.authenticator.social/ Navigate to the folder you just downloaded, which contains the pom.xml file and build the source code by running the following command on your terminal. $ mvn clean install Copy the org.wso2.carbon.identity.application.authenticator.custom.google\u00ad5.0.0.jar file found inside the target folder and paste it in the IS_HOME /repository/components/dropins folder. The source code is as follows. /* * Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.custom.google \u037e import org.apache.commons.lang.StringUtils \u037e import org.apache.oltu.oauth2.client.response.OAuthClientResponse \u037e import org.wso2.carbon.identity.application.authentication.framework.context.AuthenticationContext \u037e import org.wso2.carbon.identity.application.authenticator.oidc.OIDCAuthenticatorConstants \u037e import org.wso2.carbon.identity.application.authenticator.oidc.OpenIDConnectAuthenticator \u037e import org.wso2.carbon.identity.application.common.model.Property \u037e import org.wso2.carbon.identity.application.common.util.IdentityApplicationConstants \u037e import java.util.ArrayList \u037e import java.util.List \u037e import java.util.Map \u037e public class GoogleCustomOAuth2Authenticator extends OpenIDConnectAuthenticator { private static final long serialVersionUID = \u00ad 4154255583070524011 L \u037e private String tokenEndpoint \u037e private String oAuthEndpoint \u037e private String userInfoURL \u037e /** * initiate tokenEndpoint */ private void initTokenEndpoint () { this . tokenEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( GoogleCustomOAuth2AuthenticationConstant . GOOGLE_TOKEN_ENDPOINT ) \u037e if ( StringUtils . isBlank ( this . tokenEndpoint )) { this . tokenEndpoint = IdentityApplicationConstants . GOOGLE_TOKEN_URL \u037e } } /** * initiate authorization server endpoint */ private void initOAuthEndpoint () { this . oAuthEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( GoogleCustomOAuth2AuthenticationConstant . GOOGLE_AUTHZ_ENDPOINT ) \u037e if ( StringUtils . isBlank ( this . oAuthEndpoint )) { this . oAuthEndpoint = IdentityApplicationConstants . GOOGLE_OAUTH_URL \u037e } } /** * Initialize the Yahoo user info url. */ private void initUserInfoURL () { userInfoURL = getAuthenticatorConfig () . getParameterMap () . get ( GoogleCustomOAuth2AuthenticationConstant . GOOGLE_USERINFO_ENDPOINT ) \u037e if ( userInfoURL == null ) { userInfoURL = IdentityApplicationConstants . GOOGLE_USERINFO_URL \u037e } } /** * Get the user info endpoint url. * @return User info endpoint url. */ private String getUserInfoURL () { if ( userInfoURL == null ) { initUserInfoURL () \u037e } return userInfoURL \u037e } /** * Get Authorization Server Endpoint * * @param authenticatorProperties this is not used currently in the method * @return oAuthEndpoint */ @Override protected String getAuthorizationServerEndpoint ( Map String , String authenticatorProperties ) { if ( StringUtils . isBlank ( this . oAuthEndpoint )) { initOAuthEndpoint () \u037e } return this . oAuthEndpoint \u037e } /** * Get Token Endpoint * * @param authenticatorProperties this is not used currently in the method * @return tokenEndpoint */ @Override protected String getTokenEndpoint ( Map String , String authenticatorProperties ) { if ( StringUtils . isBlank ( this . tokenEndpoint )) { initTokenEndpoint () \u037e } return this . tokenEndpoint \u037e } /** * Get Scope * * @param scope * @param authenticatorProperties * @return */ @Override protected String getScope ( String scope , Map String , String authenticatorProperties ) { return GoogleCustomOAuth2AuthenticationConstant . GOOGLE_SCOPE \u037e } @Override protected String getAuthenticateUser ( AuthenticationContext context , Map String , Object jsonObject , OAuthClientResponse token ) { if ( jsonObject . get ( OIDCAuthenticatorConstants . Claim . EMAIL ) == null ) { return ( String ) jsonObject . get ( sub ) \u037e } else { return ( String ) jsonObject . get ( OIDCAuthenticatorConstants . Claim . EMAIL ) \u037e } } /** * Get google user info endpoint. * @param token OAuth client response. * @return User info endpoint. */ @Override protected String getUserInfoEndpoint ( OAuthClientResponse token , Map String , String authenticatorProperties ) { return getUserInfoURL () \u037e } @Override protected String getQueryString ( Map String , String authenticatorProperties ) { return authenticatorProperties . get ( GoogleCustomOAuth2AuthenticationConstant . ADDITIONAL_QUERY_PARAMS ) \u037e } /** * Get Configuration Properties * * @return */ @Override public List Property getConfigurationProperties () { List Property configProperties = new ArrayList Property () \u037e Property clientId = new Property () \u037e clientId . setName ( OIDCAuthenticatorConstants . CLIENT_ID ) \u037e clientId . setDisplayName ( Client Id ) \u037e clientId . setRequired ( true ) \u037e clientId . setDescription ( Enter Google IDP client identifier value ) \u037e clientId . setDisplayOrder ( 1 ) \u037e configProperties . add ( clientId ) \u037e Property clientSecret = new Property () \u037e clientSecret . setName ( OIDCAuthenticatorConstants . CLIENT_SECRET ) \u037e clientSecret . setDisplayName ( Client Secret ) \u037e clientSecret . setRequired ( true ) \u037e clientSecret . setConfidential ( true ) \u037e clientSecret . setDescription ( Enter Google IDP client secret value ) \u037e clientSecret . setDisplayOrder ( 2 ) \u037e configProperties . add ( clientSecret ) \u037e Property callbackUrl = new Property () \u037e callbackUrl . setDisplayName ( Callback Url ) \u037e callbackUrl . setName ( IdentityApplicationConstants . OAuth2 . CALLBACK_URL ) \u037e callbackUrl . setDescription ( Enter value corresponding to callback url. ) \u037e callbackUrl . setDisplayOrder ( 3 ) \u037e configProperties . add ( callbackUrl ) \u037e Property scope = new Property () \u037e scope . setDisplayName ( Additional Query Parameters ) \u037e scope . setName ( AdditionalQueryParameters ) \u037e scope . setValue ( scope=openid email profile ) \u037e scope . setDescription ( Additional query parameters. e.g: paramName1=value1 ) \u037e scope . setDisplayOrder ( 4 ) \u037e configProperties . add ( scope ) \u037e return configProperties \u037e } /** * Get Friendly Name * * @return */ @Override public String getFriendlyName () { return GoogleCustomOAuth2AuthenticationConstant . GOOGLE_CONNECTOR_FRIENDLY_NAME \u037e } /** * GetName * * @return */ @Override public String getName () { return GoogleCustomOAuth2AuthenticationConstant . GOOGLE_CONNECTOR_NAME \u037e } } /* * Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.custom.google \u037e public class GoogleCustomOAuth2AuthenticationConstant { private GoogleCustomOAuth2AuthenticationConstant () {} public static final String GOOGLE_AUTHZ_ENDPOINT = GoogleAuthzEndpoint \u037e public static final String GOOGLE_TOKEN_ENDPOINT = GoogleTokenEndpoint \u037e public static final String GOOGLE_USERINFO_ENDPOINT = GoogleUserInfoEndpoint \u037e public static final String GOOGLE_CONNECTOR_FRIENDLY_NAME = Custom Google Authenticator \u037e public static final String GOOGLE_CONNECTOR_NAME = CustomGoogleOAUth2OpenIDAuthenticator \u037e public static final String GOOGLE_SCOPE = openid email profile \u037e public static final String CALLBACK_URL = Google\u00adcallback\u00adurl \u037e public static final String ADDITIONAL_QUERY_PARAMS = AdditionalQueryParameters \u037e } /* * Copyright (c) WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.custom.internal \u037e import org.apache.commons.logging.Log \u037e import org.apache.commons.logging.LogFactory \u037e import org.osgi.service.component.ComponentContext \u037e import org.wso2.carbon.identity.application.authentication.framework.ApplicationAuthenticator \u037e import org.wso2.carbon.identity.application.authenticator.custom.google.GoogleCustomOAuth2Authenticator \u037e import java.util.Hashtable \u037e /** * @scr.component name= identity.application.authenticator.custom.google.component immediate= true */ public class GoogleCustomAuthenticatorServiceComponent { private static final Log LOGGER = LogFactory . getLog ( GoogleCustomAuthenticatorServiceComponent . class ) \u037e protected void activate ( ComponentContext context ) { try { GoogleCustomOAuth2Authenticator googleAuthenticator = new GoogleCustomOAuth2Authenticator () \u037e Hashtable String , String props = new Hashtable String , String () \u037e context . getBundleContext (). registerService ( ApplicationAuthenticator . class . getName (), googleAuthenticator , props ) \u037e if ( LOGGER . isDebugEnabled ()) { LOGGER . debug ( Google custom authenticator bundle is activated ) \u037e } } catch ( Exception e ) { LOGGER . fatal ( Error while activating Google authenticator , e ) \u037e } } protected void deactivate ( ComponentContext context ) { if ( LOGGER . isDebugEnabled ()) { LOGGER . debug ( Google custom authenticator bundle is deactivated ) \u037e } } } ? xml version = 1.0 encoding = utf\u00ad8 ? ! \u00ad\u00ad ~ Copyright ( c ) 2015 , WSO2 Inc . ( http : //www.wso2.org) All Rights Reserved. ~ ~ Licensed under the Apache License , Version 2.0 ( the License ) \u037e ~ you may not use this file except in compliance with the License . ~ You may obtain a copy of the License at ~ ~ http : //www.apache.org/licenses/LICENSE\u00ad2.0 ~ ~ Unless required by applicable law or agreed to in writing , software ~ distributed under the License is distributed on an AS IS BASIS , ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . ~ See the License for the specific language governing permissions and ~ limitations under the License . project xmlns = http://maven.apache.org/POM/4.0.0 xmlns : xsi = http://www.w3.org/2001/XMLSchema\u00adinstance xsi : schemaLocation = http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven\u00adv4_0_0.xsd parent groupId org . wso2 . carbon . identity / groupId artifactId application \u00ad authenticators / artifactId version 5.0.7 / version / parent modelVersion 4.0.0 / modelVersion artifactId org . wso2 . carbon . identity . application . authenticator . custom . google / artifactId packaging bundle / packaging version 5.0.0 / version repositories ! \u00ad\u00ad Before adding ANYTHING in here , please start a discussion on the dev list . Ideally the Axis2 build should only use Maven central ( which is available by default ) and nothing else . We had troubles with other repositories in the past . Therefore configuring additional repositories here should be considered very carefully . \u00ad\u00ad repository id wso2 \u00ad nexus / id name WSO2 internal Repository / name url http : //maven.wso2.org/nexus/content/groups/wso2\u00adpublic/ /url releases enabled true / enabled updatePolicy daily / updatePolicy checksumPolicy ignore / checksumPolicy / releases / repository repository id wso2 . releases / id name WSO2 internal Repository / name url http : //maven.wso2.org/nexus/content/repositories/releases/ /url releases enabled true / enabled updatePolicy daily / updatePolicy checksumPolicy ignore / checksumPolicy / releases / repository repository id wso2 . snapshots / id name WSO2 Snapshot Repository / name url http : //maven.wso2.org/nexus/content/repositories/snapshots/ /url snapshots enabled true / enabled updatePolicy daily / updatePolicy / snapshots releases enabled false / enabled / releases / repository / repositories dependencies dependency groupId org . wso2 . carbon / groupId artifactId org . wso2 . carbon . logging / artifactId / dependency dependency groupId org . wso2 . carbon . identity / groupId artifactId org . wso2 . carbon . identity . application . authentication . framework / artifactId / dependency dependency groupId org . wso2 . carbon / groupId artifactId org . wso2 . carbon . ui / artifactId / dependency dependency groupId org . wso2 . orbit . org . apache . oltu . oauth2 / groupId artifactId oltu / artifactId / dependency dependency groupId org . wso2 . carbon . identity / groupId artifactId org . wso2 . carbon . identity . application . common / artifactId / dependency dependency groupId org . wso2 . carbon . identity / groupId artifactId org . wso2 . carbon . identity . application . authenticator . openid / artifactId / dependency dependency groupId org . wso2 . carbon . identity / groupId artifactId org . wso2 . carbon . identity . application . authenticator . oidc / artifactId / dependency / dependencies build plugins plugin groupId org . apache . felix / groupId artifactId maven \u00ad scr \u00ad plugin / artifactId / plugin plugin groupId org . apache . felix / groupId artifactId maven \u00ad bundle \u00ad plugin / artifactId extensions true / extensions configuration instructions Bundle \u00ad SymbolicName $ { project . artifactId } / Bundle \u00ad SymbolicName Bundle \u00ad Name $ { project . artifactId } / Bundle \u00ad Name Private \u00ad Package org . wso2 . carbon . identity . application . authenticator . custom . internal / Private \u00ad Package Import \u00ad Package javax . servlet . http \u037e version = ${imp.pkg.version.javax.servlet} , org . apache . oltu . oauth2 .* \u037e version = ${oltu.package.import.version.range} , org . apache . commons . lang \u037e version = ${commons\u00adlang.wso2.osgi.version.range} , org . apache . commons . logging \u037e version = ${commons\u00adlogging.osgi.version.range} , org . apache . commons . codec . binary \u037e version = ${commons\u00adcodec.wso2.osgi.version.range} , org . osgi . framework \u037e version = ${osgi.framework.imp.pkg.version.range} , org . osgi . service . component \u037e version = ${osgi.service.component.imp.pkg.version.range} , org . wso2 . carbon . identity . application . authentication . framework .* \u037e version = ${carbon.identity.package.import.version.range} , org . wso2 . carbon . identity . application . common . model \u037e version = ${carbon.identity.package.import.version.range} , org . wso2 . carbon . identity . core . util \u037e version = ${carbon.identity.package.import.version.range} , org . wso2 . carbon . ui \u037e version = ${carbon.kernel.package.import.version.range} , org . wso2 . carbon . identity . application . authenticator . oidc \u037e version = [5.0.7, 5.1.0) / Import \u00ad Package Export \u00ad Package ! org . wso2 . carbon . identity . application . authenticator . custom . internal , org . wso2 . carbon . identity . application . authenticator . custom . google .* \u037e version = 5.0.0 / Export \u00ad Package / instructions / configuration / plugin / plugins / build / project","title":"Writing a Custom Federated Authenticator"},{"location":"Develop/federate/Writing_a_Custom_Federated_Authenticator/#writing-a-custom-federated-authenticator","text":"It is possible to use the extension points available in the WSO2 Identity Server to create custom federated authenticators. See the following topics to create different custom authenticators. Authenticator API Writing a custom authenticator for Twitter Custom authenticator for Facebook Custom authenticator for Google","title":"Writing a Custom Federated Authenticator"},{"location":"Develop/federate/Writing_a_Custom_Federated_Authenticator/#authenticator-api","text":"The following is the API used to implement a custom federated authenticator. /* * Copyright (c) 2005-2013, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License ); you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authentication.framework ; import java.io.Serializable ; import java.util.List ; import javax.servlet.http.HttpServletRequest ; import javax.servlet.http.HttpServletResponse ; import org.wso2.carbon.identity.application.authentication.framework.context.AuthenticationContext ; import org.wso2.carbon.identity.application.authentication.framework.exception.AuthenticationFailedException ; import org.wso2.carbon.identity.application.authentication.framework.exception.LogoutFailedException ; import org.wso2.carbon.identity.application.common.model.Property ; /** * API of the Application Authenticators. * */ public interface ApplicationAuthenticator extends Serializable { /** * Check whether the authentication or logout request can be handled by the * authenticator * * @param request * @return boolean */ public boolean canHandle ( HttpServletRequest request ); /** * Process the authentication or logout request. * * @param request * @param response * @param context * @return the status of the flow * @throws AuthenticationFailedException * @throws LogoutFailedException */ public AuthenticatorFlowStatus process ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException , LogoutFailedException ; /** * Get the Context identifier sent with the request. This identifier is used * to retrieve the state of the authentication/logout flow * * @param request * @return */ public String getContextIdentifier ( HttpServletRequest request ); /** * Get the name of the Authenticator * @return name */ public String getName (); /** * @return */ public String getFriendlyName (); /** * Get the claim dialect URI if this authenticator receives claims in a standard dialect * and needs to be mapped to the Carbon dialect http://wso2.org/claims * @return boolean */ public String getClaimDialectURI (); /** * @return */ public List Property getConfigurationProperties (); } This API can be used to configure a custom authenticator. As an example, a Twitter authenticator is configured using the above API.","title":"Authenticator API"},{"location":"Develop/federate/Writing_a_Custom_Federated_Authenticator/#writing-a-custom-authenticator-for-twitter","text":"The WSO2 Identity Server comes with several built in authenticators like Facebook, Google, OpenID, and SAML. This topic provides instructions on how to authenticate users via Twitter using the SAML configurations available in the Identity Server. Related links See here for information on browser sign in flow. This information is useful when working with websites and applications that are able to open or embed a web browser. See here for information on implementing the sign in functionality using Twitter. If you are doing this using Java, there is a library you can use called twitter4j . See the link for code samples on signing in with Twitter. The following code block represents the structure of an authenticator pom.xml . Authenticators are basically OSGi (Open Service Gateway initiative) bundles, which are units of modularization that are comprised of Java classes and other resources that provide functions to end users. The pom.xml includes the dependencies for the project. Other than the twitter4j dependency, other dependencies are mandatory. {.expand-control-image}Click here to expand and view the code block ?xml version= 1.0 encoding= utf-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd groupId org.emojotFoundation /groupId modelVersion 4.0.0 /modelVersion artifactId authenticator-twitter /artifactId packaging bundle /packaging version 1.0.0 /version dependencies dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.logging /artifactId version 4.2.0 /version /dependency dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.identity.application.authentication.framework /artifactId version 4.2.2 /version /dependency dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.ui /artifactId version 4.2.0 /version /dependency dependency groupId org.apache.amber.wso2 /groupId artifactId amber /artifactId version 0.22.1358727.wso2v4 /version /dependency dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.identity.application.common /artifactId version 4.2.0 /version /dependency dependency groupId org.twitter4j /groupId artifactId twitter4j-core /artifactId version [4.0,) /version /dependency /dependencies repositories repository id wso2-nexus /id name WSO2 Internal Repository /name url http://maven.wso2.org/nexus/content/groups/wso2-public/ /url releases enabled true /enabled updatePolicy daily /updatePolicy checksumPolicy ignore /checksumPolicy /releases /repository repository id twitter4j.org /id name twitter4j.org Repository /name url http://twitter4j.org/maven2 /url releases enabled true /enabled /releases snapshots enabled true /enabled /snapshots /repository /repositories build plugins plugin groupId org.apache.felix /groupId artifactId maven-scr-plugin /artifactId version 1.7.4 /version executions execution id generate-scr-scrdescriptor /id goals goal scr /goal /goals /execution /executions /plugin plugin groupId org.apache.felix /groupId artifactId maven-bundle-plugin /artifactId extensions true /extensions configuration instructions Bundle-SymbolicName ${project.artifactId} /Bundle-SymbolicName Bundle-Name ${project.artifactId} /Bundle-Name Private-Package org.emojotFoundation.authenticator.twitter.internal /Private-Package Import-Package org.twitter4j.*; version= [4.0,) , org.apache.axis2.*; version= [1.6.1.wso2v1, 1.7.0) , org.apache.axiom.*; version= [1.2.11.wso2v2, 1.3.0) , org.wso2.carbon.ui.*, org.apache.commons.logging.*; version= 1.0.4 , org.osgi.framework, org.wso2.carbon.identity.application.authentication.framework.*, javax.servlet;version= [2.6.0,3.0.0) , javax.servlet.http;version= [2.6.0,3.0.0) , *;resolution:=optional /Import-Package Export-Package !org.emojotFoundation.authenticator.twitter.internal, org.emojotFoundation.authenticator.twitter.* /Export-Package DynamicImport-Package * /DynamicImport-Package /instructions /configuration /plugin /plugins /build /project Since the project is an OSGi bundle, you must add this class to define the bundle activate method and deactivate method. {.expand-control-image}Click here to expand and view the class used to define the bundle activate method and deactivate method package org.emojotFoundation.authenticator.twitter.internal ; import java.util.Hashtable ; import org.apache.commons.logging.Log ; import org.apache.commons.logging.LogFactory ; import org.osgi.service.component.ComponentContext ; import org.wso2.carbon.identity.application.authentication.framework.ApplicationAuthenticator ; import org.emojotFoundation.authenticator.twitter.TwitterAuthenticator ; /** * @scr.component name= authenticator.twitter immediate= true */ public class TwitterAuthenticatorServiceComponent { private static final Log LOGGER = LogFactory . getLog ( TwitterAuthenticatorServiceComponent . class ); protected void activate ( ComponentContext ctxt ) { try { TwitterAuthenticator twitterAuthenticator = new TwitterAuthenticator (); Hashtable String , String props = new Hashtable String , String () ctxt . getBundleContext (). registerService ( ApplicationAuthenticator . class . getName (), twitterAuthenticator , props ); LOGGER . info ( ----Twitter Authenticator bundle is activated---- ); } catch ( Throwable e ) { LOGGER . fatal ( ----Error while activating Twitter authenticator---- , e ); } } protected void deactivate ( ComponentContext ctxt ) { LOGGER . info ( ----Twitter Authenticator bundle is deactivated---- ); } } After adding this to your project, you are in a position to write your authenticator. Authenticators are defined by extending the AbstractApplicationAuthenticator class and implementing the FederatedApplicationAuthenticator interface. The important methods in the AbstractApplicationAuthenticator class and the FederatedApplicationAuthenticator interface are listed as follows. public String getName() public String getFriendlyName() public String getContextIdentifier(HttpServletRequest request) - Returns a unique identifier that will map the authentication request and the response. The value returned by the invocation of authentication request and the response should be the same. public boolean canHandle(HttpServletRequest request) - Specifies whether this authenticator can handle the authentication response. protected void initiateAuthenticationRequest(HttpServletRequest request,HttpServletResponse response, AuthenticationContext context) protected void processAuthenticationResponse(HttpServletRequest request,HttpServletResponse response, AuthenticationContext context) Use the following steps to write the Twitter authenticator. Implement the canHandle() method using the above methods. When Twitter sends the OAuth response, it sends the parameters oauth_token and oauth_verifier in the request. This is a notification to identify that this response can be handled by the authenticator. {.expand-control-image}Click here to expand and view a sample canHandle() method public boolean canHandle ( HttpServletRequest request ) { if ( request . getParameter ( oauth_token )!= null request . getParameter ( oauth_verifier )!= null ) { return true ; } return false ; } For each authentication request that comes into the Identity Server, there is unique value that comes along as a parameter. That parameter is the sessionDataKey . Store this in the Twitter authentication redirection session to facilitate the requirement where getContextIdentifier gives the same value for authentication request and its response. {.expand-control-image}Click here to expand and view getContextIdentifier() public String getContextIdentifier ( HttpServletRequest request ) { if ( request . getSession (). getAttribute ( contextIdentifier )== null ){ request . getSession (). setAttribute ( contextIdentifier , request . getParameter ( sessionDataKey )); return request . getParameter ( sessionDataKey ); } else { return ( String ) request . getSession (). getAttribute ( contextIdentifier ); } } Next, implement the initiateAuthenticationRequest method and the processAuthenticationResponse method as follows. {.expand-control-image}Click here to expand and view the initiateAuthenticationRequest method and processAuthenticationResponse method protected void initiateAuthenticationRequest ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { String apiKey = resourceBundle . getString ( API_Key ); String apiSecret = resourceBundle . getString ( API_Secret ); Twitter twitter = new TwitterFactory (). getInstance (); twitter . setOAuthConsumer ( apiKey , apiSecret ); try { String callbackURL = resourceBundle . getString ( Call_Back_URL ); RequestToken requestToken = twitter . getOAuthRequestToken ( callbackURL . toString ()); request . getSession (). setAttribute ( requestToken , requestToken ); request . getSession (). setAttribute ( twitter , twitter ); response . sendRedirect ( requestToken . getAuthenticationURL ()); } catch ( TwitterException e ) { LOGGER . error ( Exception while sending to the Twitter login page. , e ); throw new AuthenticationFailedException ( e . getMessage (), e ); } catch ( IOException e ) { LOGGER . error ( Exception while sending to the Twitter login page. , e ); throw new AuthenticationFailedException ( e . getMessage (), e ); } return ; } protected void processAuthenticationResponse ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { Twitter twitter = ( Twitter ) request . getSession (). getAttribute ( twitter ); RequestToken requestToken = ( RequestToken ) request . getSession (). getAttribute ( requestToken ); String verifier = request . getParameter ( oauth_verifier ); try { AccessToken token = twitter . getOAuthAccessToken ( requestToken , verifier ); request . getSession (). removeAttribute ( requestToken ); User user = twitter . verifyCredentials (); buildClaims ( user , context ); } catch ( TwitterException e ) { LOGGER . error ( Exception while obtaining OAuth token form Twitter , e ); throw new AuthenticationFailedException ( Exception while obtaining OAuth token form Twitter , e ); } } public void buildClaims ( User user , AuthenticationContext context ) { context . setSubject ( String . valueOf ( user . getId ())); Map ClaimMapping , String claims = new HashMap ClaimMapping , String (); claims . put ( ClaimMapping . build ( name , name , null , false ), user . getName ()); claims . put ( ClaimMapping . build ( screen_name , screen_name , null , false ), user . getScreenName ()); claims . put ( ClaimMapping . build ( url , url , null , false ), user . getURL ()); context . setSubjectAttributes ( claims ); } The buildClaims method saves the retrieved user attributes to the authenticated context in the Identity Server. That is needed to map the claims to the built in claims of IS. After implementing these methods you can build your bundle. After building it you have to put that into the IS_HOME /repository/components/dropins directory. Restart the Identity Server to use the Twitter authenticator in IS.","title":"Writing a custom authenticator for Twitter"},{"location":"Develop/federate/Writing_a_Custom_Federated_Authenticator/#custom-authenticator-for-facebook","text":"This section includes the code used to write the custom authenticator for Facebook. Download the source code from here using the following command on your terminal. $ svn checkout https : //svn.wso2.org/repos/wso2/people/isura/org.wso2.carbon.identity.application.authenticator.social/ Navigate to the folder you just downloaded, which contains the pom.xml file and build the source code by running the following command on your terminal. $ mvn clean install Copy the org.wso2.carbon.identity.application.authenticator.social.facebook2-5.0.0.jar file found inside the target folder and paste it in the IS_HOME /repository/components/dropins folder. The source code is as follows. /* * Copyright (c) 2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.social.facebook2 \u037e import org.apache.commons.lang.StringUtils \u037e import org.apache.commons.logging.Log \u037e import org.apache.commons.logging.LogFactory \u037e import org.apache.oltu.oauth2.client.request.OAuthClientRequest \u037e import org.apache.oltu.oauth2.client.response.OAuthAuthzResponse \u037e import org.apache.oltu.oauth2.common.exception.OAuthProblemException \u037e import org.apache.oltu.oauth2.common.exception.OAuthSystemException \u037e import org.apache.oltu.oauth2.common.utils.JSONUtils \u037e import org.wso2.carbon.identity.application.authentication.framework.AbstractApplicationAuthenticator \u037e import org.wso2.carbon.identity.application.authentication.framework.FederatedApplicationAuthenticator \u037e import org.wso2.carbon.identity.application.authentication.framework.context.AuthenticationContext \u037e import org.wso2.carbon.identity.application.authentication.framework.exception.ApplicationAuthenticatorException \u037e import org.wso2.carbon.identity.application.authentication.framework.exception.AuthenticationFailedException \u037e import org.wso2.carbon.identity.application.authentication.framework.model.AuthenticatedUser \u037e import org.wso2.carbon.identity.application.authentication.framework.util.FrameworkConstants \u037e import org.wso2.carbon.identity.application.authentication.framework.util.FrameworkUtils \u037e import org.wso2.carbon.identity.application.common.model.ClaimMapping \u037e import org.wso2.carbon.identity.application.common.model.Property \u037e import org.wso2.carbon.identity.application.common.util.IdentityApplicationConstants \u037e import org.wso2.carbon.identity.base.IdentityConstants \u037e import org.wso2.carbon.identity.core.util.IdentityUtil \u037e import org.wso2.carbon.identity.core.util.IdentityIOStreamUtils \u037e import javax.servlet.http.HttpServletRequest \u037e import javax.servlet.http.HttpServletResponse \u037e import java.io.BufferedReader \u037e import java.io.IOException \u037e import java.io.InputStreamReader \u037e import java.net.MalformedURLException \u037e import java.net.URL \u037e import java.net.URLConnection \u037e import java.nio.charset.Charset \u037e import java.util.* \u037e public class FacebookCustomAuthenticator extends AbstractApplicationAuthenticator implements FederatedApplicationAuthenticator { private static final Log log = LogFactory . getLog ( FacebookCustomAuthenticator . class ) \u037e private static final long serialVersionUID = \u00ad 1465329490183756028 L \u037e private String tokenEndpoint \u037e private String oAuthEndpoint \u037e private String userInfoEndpoint \u037e /** * initiate tokenEndpoint */ private void initTokenEndpoint () { this . tokenEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( FacebookCustomAuthenticatorConstants . FB_TOKEN_URL ) \u037e if ( StringUtils . isBlank ( this . tokenEndpoint )) { this . tokenEndpoint = IdentityApplicationConstants . FB_TOKEN_URL \u037e } } /** * initiate authorization server endpoint */ private void initOAuthEndpoint () { this . oAuthEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( FacebookCustomAuthenticatorConstants . FB_AUTHZ_URL ) \u037e if ( StringUtils . isBlank ( this . oAuthEndpoint )) { this . oAuthEndpoint = IdentityApplicationConstants . FB_AUTHZ_URL \u037e } } /** * initiate userInfoEndpoint */ private void initUserInfoEndPoint () { this . userInfoEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( FacebookCustomAuthenticatorConstants . FB_USER_INFO_URL ) \u037e if ( StringUtils . isBlank ( this . userInfoEndpoint )) { this . userInfoEndpoint = IdentityApplicationConstants . FB_USER_INFO_URL \u037e } } /** * get the tokenEndpoint. * @return tokenEndpoint */ private String getTokenEndpoint () { if ( StringUtils . isBlank ( this . tokenEndpoint )) { initTokenEndpoint () \u037e } return this . tokenEndpoint \u037e } /** * get the oAuthEndpoint. * @return oAuthEndpoint */ private String getAuthorizationServerEndpoint () { if ( StringUtils . isBlank ( this . oAuthEndpoint )) { initOAuthEndpoint () \u037e } return this . oAuthEndpoint \u037e } /** * get the userInfoEndpoint. * @return userInfoEndpoint */ private String getUserInfoEndpoint () { if ( StringUtils . isBlank ( this . userInfoEndpoint )) { initUserInfoEndPoint () \u037e } return this . userInfoEndpoint \u037e } @Override public boolean canHandle ( HttpServletRequest request ) { log . trace ( Inside FacebookAuthenticator.canHandle() ) \u037e if ( request . getParameter ( FacebookCustomAuthenticatorConstants . OAUTH2_GRANT_TYPE_CODE ) != null request . getParameter ( FacebookCustomAuthenticatorConstants . OAUTH2_PARAM_STATE ) != null FacebookCustomAuthenticatorConstants . FACEBOOK_LOGIN_TYPE . equals ( getLoginType ( request ))) { return true \u037e } return false \u037e } @Override protected void initiateAuthenticationRequest ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { try { Map authenticatorProperties = context . getAuthenticatorProperties () \u037e String clientId = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . CLIENT_ID ) \u037e String authorizationEP = getAuthorizationServerEndpoint () \u037e String scope = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . SCOPE ) \u037e if ( StringUtils . isEmpty ( scope )) { scope = FacebookCustomAuthenticatorConstants . EMAIL \u037e } String callbackUrl = IdentityUtil . getServerURL ( FrameworkConstants . COMMONAUTH , true , true ) \u037e String state = context . getContextIdentifier () + , + FacebookCustomAuthenticatorConstants . FACEBOOK_LOGIN_TYPE \u037e OAuthClientRequest authzRequest = OAuthClientRequest . authorizationLocation ( authorizationEP ) . setClientId ( clientId ) . setRedirectURI ( callbackUrl ) . setResponseType ( FacebookCustomAuthenticatorConstants . OAUTH2_GRANT_TYPE_CODE ) . setScope ( scope ). setState ( state ) . buildQueryMessage () \u037e response . sendRedirect ( authzRequest . getLocationUri ()) \u037e } catch ( IOException e ) { log . error ( Exception while sending to the login page. , e ) \u037e throw new AuthenticationFailedException ( e . getMessage (), e ) \u037e } catch ( OAuthSystemException e ) { log . error ( Exception while building authorization code request. , e ) \u037e throw new AuthenticationFailedException ( e . getMessage (), e ) \u037e } return \u037e } @Override protected void processAuthenticationResponse ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { log . trace ( Inside FacebookAuthenticator.authenticate() ) \u037e try { Map authenticatorProperties = context . getAuthenticatorProperties () \u037e String clientId = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . CLIENT_ID ) \u037e String clientSecret = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . CLIENT_SECRET ) \u037e String userInfoFields = authenticatorProperties . get ( FacebookCustomAuthenticatorConstants . USER_INFO_FIELDS ) \u037e String tokenEndPoint = getTokenEndpoint () \u037e String fbauthUserInfoUrl = getUserInfoEndpoint () \u037e String callbackUrl = IdentityUtil . getServerURL ( FrameworkConstants . COMMONAUTH , true , true ) \u037e String code = getAuthorizationCode ( request ) \u037e String token = getToken ( tokenEndPoint , clientId , clientSecret , callbackUrl , code ) \u037e if (! StringUtils . isBlank ( userInfoFields )) { if ( context . getExternalIdP (). getIdentityProvider (). getClaimConfig () != null ! StringUtils . isBlank ( context . getExternalIdP (). getIdentityProvider (). getClaimConfig (). getUserClaimURI ())) { String userClaimUri = context . getExternalIdP (). getIdentityProvider (). getClaimConfig () . getUserClaimURI () \u037e if (! Arrays . asList ( userInfoFields . split ( , )). contains ( userClaimUri )) { userInfoFields += ( , + userClaimUri ) \u037e } } else { if (! Arrays . asList ( userInfoFields . split ( , )). contains ( FacebookCustomAuthenticatorConstants . DEFAULT_USER_IDENTIFIER )) { userInfoFields += ( , + FacebookCustomAuthenticatorConstants . DEFAULT_USER_IDENTIFIER ) \u037e } } } Map userInfoJson = getUserInfoJson ( fbauthUserInfoUrl , userInfoFields , token ) \u037e buildClaims ( context , userInfoJson ) \u037e } catch ( ApplicationAuthenticatorException e ) { log . error ( Failed to process Facebook Connect response. , e ) \u037e throw new AuthenticationFailedException ( e . getMessage (), e ) \u037e } } private String getAuthorizationCode ( HttpServletRequest request ) throws ApplicationAuthenticatorException { OAuthAuthzResponse authzResponse \u037e try { authzResponse = OAuthAuthzResponse . oauthCodeAuthzResponse ( request ) \u037e return authzResponse . getCode () \u037e } catch ( OAuthProblemException e ) { throw new ApplicationAuthenticatorException ( Exception while reading authorization code. , e ) \u037e } } private String getToken ( String tokenEndPoint , String clientId , String clientSecret , String callbackurl , String code ) throws ApplicationAuthenticatorException { OAuthClientRequest tokenRequest = null \u037e String token = null \u037e try { tokenRequest = buidTokenRequest ( tokenEndPoint , clientId , clientSecret , callbackurl , code ) \u037e token = sendRequest ( tokenRequest . getLocationUri ()) \u037e if ( token . startsWith ( { )) { throw new ApplicationAuthenticatorException ( Received access token is invalid. ) \u037e } } catch ( MalformedURLException e ) { if ( log . isDebugEnabled ()) { log . debug ( URL : + tokenRequest . getLocationUri ()) \u037e } throw new ApplicationAuthenticatorException ( MalformedURLException while sending access token request. , e ) \u037e } catch ( IOException e ) { throw new ApplicationAuthenticatorException ( IOException while sending access token request. , e ) \u037e } return token \u037e } private OAuthClientRequest buidTokenRequest ( String tokenEndPoint , String clientId , String clientSecret , String callbackurl , String code ) throws ApplicationAuthenticatorException { OAuthClientRequest tokenRequest = null \u037e try { tokenRequest = OAuthClientRequest . tokenLocation ( tokenEndPoint ). setClientId ( clientId ) . setClientSecret ( clientSecret ) . setRedirectURI ( callbackurl ). setCode ( code ) . buildQueryMessage () \u037e } catch ( OAuthSystemException e ) { throw new ApplicationAuthenticatorException ( Exception while building access token request. , e ) \u037e } return tokenRequest \u037e } private String getUserInfoString ( String fbAuthUserInfoUrl , String userInfoFields , String token ) throws ApplicationAuthenticatorException { String userInfoString \u037e try { if ( StringUtils . isBlank ( userInfoFields )) { userInfoString = sendRequest ( String . format ( %s?%s , fbAuthUserInfoUrl , token )) \u037e } else { userInfoString = sendRequest ( String . format ( %s?fields=%s %s , fbAuthUserInfoUrl , userInfoFields , token )) \u037e } } catch ( MalformedURLException e ) { if ( log . isDebugEnabled ()) { log . debug ( URL : + fbAuthUserInfoUrl , e ) \u037e } throw new ApplicationAuthenticatorException ( MalformedURLException while sending user information request. , e ) \u037e } catch ( IOException e ) { throw new ApplicationAuthenticatorException ( IOException while sending sending user information request. , e ) \u037e } return userInfoString \u037e } private void setSubject ( AuthenticationContext context , Map jsonObject ) throws ApplicationAuthenticatorException { String authenticatedUserId = ( String ) jsonObject . get ( FacebookCustomAuthenticatorConstants . DEFAULT_USER_IDENTIFIER ) \u037e if ( StringUtils . isEmpty ( authenticatedUserId )) { throw new ApplicationAuthenticatorException ( Authenticated user identifier is empty ) \u037e } AuthenticatedUser authenticatedUser = AuthenticatedUser . createFederateAuthenticatedUserFromSubjectIdentifier ( authenticatedUserId ) \u037e context . setSubject ( authenticatedUser ) \u037e } private Map getUserInfoJson ( String fbAuthUserInfoUrl , String userInfoFields , String token ) throws ApplicationAuthenticatorException { String userInfoString = getUserInfoString ( fbAuthUserInfoUrl , userInfoFields , token ) \u037e if ( log . isDebugEnabled () IdentityUtil . isTokenLoggable ( IdentityConstants . IdentityTokens . USER_ID_TOKEN )) { log . debug ( UserInfoString : + userInfoString ) \u037e } Map jsonObject = JSONUtils . parseJSON ( userInfoString ) \u037e return jsonObject \u037e } public void buildClaims ( AuthenticationContext context , Map jsonObject ) throws ApplicationAuthenticatorException { if ( jsonObject != null ) { Map claims = new HashMap () \u037e for ( Map . Entry entry : jsonObject . entrySet ()) { claims . put ( ClaimMapping . build ( entry . getKey (), entry . getKey (), null , false ), entry . getValue (). toString ()) \u037e if ( log . isDebugEnabled () IdentityUtil . isTokenLoggable ( IdentityConstants . IdentityTokens . USER_CLAIMS )) { log . debug ( Adding claim mapping : + entry . getKey () + + entry . getKey () + : + entry . getValue ()) \u037e } } if ( StringUtils . isBlank ( context . getExternalIdP (). getIdentityProvider (). getClaimConfig (). getUserClaimURI ())) { context . getExternalIdP (). getIdentityProvider (). getClaimConfig (). setUserClaimURI ( FacebookCustomAuthenticatorConstants . EMAIL ) \u037e } String subjectFromClaims = FrameworkUtils . getFederatedSubjectFromClaims ( context . getExternalIdP (). getIdentityProvider (), claims ) \u037e if ( subjectFromClaims != null ! subjectFromClaims . isEmpty ()) { AuthenticatedUser authenticatedUser = AuthenticatedUser . createFederateAuthenticatedUserFromSubjectIdentifier ( subjectFromClaims ) \u037e context . setSubject ( authenticatedUser ) \u037e } else { setSubject ( context , jsonObject ) \u037e } context . getSubject (). setUserAttributes ( claims ) \u037e } else { if ( log . isDebugEnabled ()) { log . debug ( Decoded json object is null ) \u037e } throw new ApplicationAuthenticatorException ( Decoded json object is null ) \u037e } } @Override public String getContextIdentifier ( HttpServletRequest request ) { log . trace ( Inside FacebookAuthenticator.getContextIdentifier() ) \u037e String state = request . getParameter ( FacebookCustomAuthenticatorConstants . OAUTH2_PARAM_STATE ) \u037e if ( state != null ) { return state . split ( , )[ 0 ] \u037e } else { return null \u037e } } private String sendRequest ( String url ) throws IOException { BufferedReader in = null \u037e StringBuilder b = new StringBuilder () \u037e try { URLConnection urlConnection = new URL ( url ). openConnection () \u037e in = new BufferedReader ( new InputStreamReader ( urlConnection . getInputStream (), Charset . forName ( utf\u00ad8 ))) \u037e String inputLine = in . readLine () \u037e while ( inputLine != null ) { b . append ( inputLine ). append ( \\n ) \u037e inputLine = in . readLine () \u037e } } finally { IdentityIOStreamUtils . closeReader ( in ) \u037e } return b . toString () \u037e } private String getLoginType ( HttpServletRequest request ) { String state = request . getParameter ( FacebookCustomAuthenticatorConstants . OAUTH2_PARAM_STATE ) \u037e if ( state != null ) { return state . split ( , )[ 1 ] \u037e } else { return null \u037e } } @Override public String getFriendlyName () { return Custom\u00adFacebook \u037e } @Override public String getName () { return FacebookCustomAuthenticatorConstants . AUTHENTICATOR_NAME \u037e } @Override public List getConfigurationProperties () { List configProperties = new ArrayList () \u037e Property clientId = new Property () \u037e clientId . setName ( FacebookCustomAuthenticatorConstants . CLIENT_ID ) \u037e clientId . setDisplayName ( Client Id ) \u037e clientId . setRequired ( true ) \u037e clientId . setDescription ( Enter Facebook client identifier value ) \u037e configProperties . add ( clientId ) \u037e Property clientSecret = new Property () \u037e clientSecret . setName ( FacebookCustomAuthenticatorConstants . CLIENT_SECRET ) \u037e clientSecret . setDisplayName ( Client Secret ) \u037e clientSecret . setRequired ( true ) \u037e clientSecret . setConfidential ( true ) \u037e clientSecret . setDescription ( Enter Facebook client secret value ) \u037e configProperties . add ( clientSecret ) \u037e Property scope = new Property () \u037e scope . setName ( FacebookCustomAuthenticatorConstants . SCOPE ) \u037e scope . setDisplayName ( Scope ) \u037e scope . setDescription ( Enter Facebook scopes ) \u037e scope . setDefaultValue ( id ) \u037e scope . setRequired ( false ) \u037e configProperties . add ( scope ) \u037e Property userIdentifier = new Property () \u037e userIdentifier . setName ( FacebookCustomAuthenticatorConstants . USER_INFO_FIELDS ) \u037e userIdentifier . setDisplayName ( User Identifier Field ) \u037e userIdentifier . setDescription ( Enter Facebook user identifier field ) \u037e userIdentifier . setDefaultValue ( id ) \u037e userIdentifier . setRequired ( false ) \u037e configProperties . add ( userIdentifier ) \u037e return configProperties \u037e } } /* * Copyright (c) 2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.social.facebook2 \u037e public class FacebookCustomAuthenticatorConstants { public static final String AUTHENTICATOR_NAME = FacebookAuthenticator\u00adCustom \u037e public static final String FACEBOOK_LOGIN_TYPE = facebook \u037e public static final String OAUTH2_GRANT_TYPE_CODE = code \u037e public static final String OAUTH2_PARAM_STATE = state \u037e public static final String EMAIL = email \u037e public static final String SCOPE = Scope \u037e public static final String USER_INFO_FIELDS = UserInfoFields \u037e public static final String DEFAULT_USER_IDENTIFIER = id \u037e public static final String CLIENT_ID = ClientId \u037e public static final String CLIENT_SECRET = ClientSecret \u037e public static final String FB_AUTHZ_URL = AuthnEndpoint \u037e public static final String FB_TOKEN_URL = AuthTokenEndpoint \u037e public static final String FB_USER_INFO_URL = UserInfoEndpoint \u037e private FacebookCustomAuthenticatorConstants () {} } /* * Copyright (c) WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.social.internal \u037e import org.apache.commons.logging.Log \u037e import org.apache.commons.logging.LogFactory \u037e import org.osgi.service.component.ComponentContext \u037e import org.wso2.carbon.identity.application.authentication.framework.ApplicationAuthenticator \u037e import org.wso2.carbon.identity.application.authenticator.social.facebook2.FacebookCustomAuthenticator \u037e import java.util.Hashtable \u037e /** * @scr.component name= identity.application.authenticator.facebook.component * immediate= true */ public class FacebookCustomAuthenticatorServiceComponent { private static final Log LOGGER = LogFactory . getLog ( FacebookCustomAuthenticatorServiceComponent . class ) \u037e protected void activate ( ComponentContext ctxt ) { try { FacebookCustomAuthenticator facebookAuthenticator = new FacebookCustomAuthenticator () \u037e Hashtable props = new Hashtable () \u037e ctxt . getBundleContext (). registerService ( ApplicationAuthenticator . class . getName (), facebookAuthenticator , props ) \u037e if ( LOGGER . isDebugEnabled ()) { LOGGER . debug ( Facebook Custome Authenticator bundle is activated ) \u037e } } catch ( Throwable e ) { LOGGER . fatal ( Error while activating Facebook authenticator , e ) \u037e } } protected void deactivate ( ComponentContext ctxt ) { if ( LOGGER . isDebugEnabled ()) { LOGGER . debug ( Facebook Custom Authenticator bundle is deactivated ) \u037e } } }","title":"Custom authenticator for Facebook"},{"location":"Develop/federate/Writing_a_Custom_Federated_Authenticator/#custom-authenticator-for-google","text":"This section includes the code used to write the custom authenticator for Google. Download the source code from here using the following command on your terminal. $ svn checkout https : //svn.wso2.org/repos/wso2/people/thanuja/org.wso2.carbon.identity.application.authenticator.social/ Navigate to the folder you just downloaded, which contains the pom.xml file and build the source code by running the following command on your terminal. $ mvn clean install Copy the org.wso2.carbon.identity.application.authenticator.custom.google\u00ad5.0.0.jar file found inside the target folder and paste it in the IS_HOME /repository/components/dropins folder. The source code is as follows. /* * Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.custom.google \u037e import org.apache.commons.lang.StringUtils \u037e import org.apache.oltu.oauth2.client.response.OAuthClientResponse \u037e import org.wso2.carbon.identity.application.authentication.framework.context.AuthenticationContext \u037e import org.wso2.carbon.identity.application.authenticator.oidc.OIDCAuthenticatorConstants \u037e import org.wso2.carbon.identity.application.authenticator.oidc.OpenIDConnectAuthenticator \u037e import org.wso2.carbon.identity.application.common.model.Property \u037e import org.wso2.carbon.identity.application.common.util.IdentityApplicationConstants \u037e import java.util.ArrayList \u037e import java.util.List \u037e import java.util.Map \u037e public class GoogleCustomOAuth2Authenticator extends OpenIDConnectAuthenticator { private static final long serialVersionUID = \u00ad 4154255583070524011 L \u037e private String tokenEndpoint \u037e private String oAuthEndpoint \u037e private String userInfoURL \u037e /** * initiate tokenEndpoint */ private void initTokenEndpoint () { this . tokenEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( GoogleCustomOAuth2AuthenticationConstant . GOOGLE_TOKEN_ENDPOINT ) \u037e if ( StringUtils . isBlank ( this . tokenEndpoint )) { this . tokenEndpoint = IdentityApplicationConstants . GOOGLE_TOKEN_URL \u037e } } /** * initiate authorization server endpoint */ private void initOAuthEndpoint () { this . oAuthEndpoint = getAuthenticatorConfig (). getParameterMap (). get ( GoogleCustomOAuth2AuthenticationConstant . GOOGLE_AUTHZ_ENDPOINT ) \u037e if ( StringUtils . isBlank ( this . oAuthEndpoint )) { this . oAuthEndpoint = IdentityApplicationConstants . GOOGLE_OAUTH_URL \u037e } } /** * Initialize the Yahoo user info url. */ private void initUserInfoURL () { userInfoURL = getAuthenticatorConfig () . getParameterMap () . get ( GoogleCustomOAuth2AuthenticationConstant . GOOGLE_USERINFO_ENDPOINT ) \u037e if ( userInfoURL == null ) { userInfoURL = IdentityApplicationConstants . GOOGLE_USERINFO_URL \u037e } } /** * Get the user info endpoint url. * @return User info endpoint url. */ private String getUserInfoURL () { if ( userInfoURL == null ) { initUserInfoURL () \u037e } return userInfoURL \u037e } /** * Get Authorization Server Endpoint * * @param authenticatorProperties this is not used currently in the method * @return oAuthEndpoint */ @Override protected String getAuthorizationServerEndpoint ( Map String , String authenticatorProperties ) { if ( StringUtils . isBlank ( this . oAuthEndpoint )) { initOAuthEndpoint () \u037e } return this . oAuthEndpoint \u037e } /** * Get Token Endpoint * * @param authenticatorProperties this is not used currently in the method * @return tokenEndpoint */ @Override protected String getTokenEndpoint ( Map String , String authenticatorProperties ) { if ( StringUtils . isBlank ( this . tokenEndpoint )) { initTokenEndpoint () \u037e } return this . tokenEndpoint \u037e } /** * Get Scope * * @param scope * @param authenticatorProperties * @return */ @Override protected String getScope ( String scope , Map String , String authenticatorProperties ) { return GoogleCustomOAuth2AuthenticationConstant . GOOGLE_SCOPE \u037e } @Override protected String getAuthenticateUser ( AuthenticationContext context , Map String , Object jsonObject , OAuthClientResponse token ) { if ( jsonObject . get ( OIDCAuthenticatorConstants . Claim . EMAIL ) == null ) { return ( String ) jsonObject . get ( sub ) \u037e } else { return ( String ) jsonObject . get ( OIDCAuthenticatorConstants . Claim . EMAIL ) \u037e } } /** * Get google user info endpoint. * @param token OAuth client response. * @return User info endpoint. */ @Override protected String getUserInfoEndpoint ( OAuthClientResponse token , Map String , String authenticatorProperties ) { return getUserInfoURL () \u037e } @Override protected String getQueryString ( Map String , String authenticatorProperties ) { return authenticatorProperties . get ( GoogleCustomOAuth2AuthenticationConstant . ADDITIONAL_QUERY_PARAMS ) \u037e } /** * Get Configuration Properties * * @return */ @Override public List Property getConfigurationProperties () { List Property configProperties = new ArrayList Property () \u037e Property clientId = new Property () \u037e clientId . setName ( OIDCAuthenticatorConstants . CLIENT_ID ) \u037e clientId . setDisplayName ( Client Id ) \u037e clientId . setRequired ( true ) \u037e clientId . setDescription ( Enter Google IDP client identifier value ) \u037e clientId . setDisplayOrder ( 1 ) \u037e configProperties . add ( clientId ) \u037e Property clientSecret = new Property () \u037e clientSecret . setName ( OIDCAuthenticatorConstants . CLIENT_SECRET ) \u037e clientSecret . setDisplayName ( Client Secret ) \u037e clientSecret . setRequired ( true ) \u037e clientSecret . setConfidential ( true ) \u037e clientSecret . setDescription ( Enter Google IDP client secret value ) \u037e clientSecret . setDisplayOrder ( 2 ) \u037e configProperties . add ( clientSecret ) \u037e Property callbackUrl = new Property () \u037e callbackUrl . setDisplayName ( Callback Url ) \u037e callbackUrl . setName ( IdentityApplicationConstants . OAuth2 . CALLBACK_URL ) \u037e callbackUrl . setDescription ( Enter value corresponding to callback url. ) \u037e callbackUrl . setDisplayOrder ( 3 ) \u037e configProperties . add ( callbackUrl ) \u037e Property scope = new Property () \u037e scope . setDisplayName ( Additional Query Parameters ) \u037e scope . setName ( AdditionalQueryParameters ) \u037e scope . setValue ( scope=openid email profile ) \u037e scope . setDescription ( Additional query parameters. e.g: paramName1=value1 ) \u037e scope . setDisplayOrder ( 4 ) \u037e configProperties . add ( scope ) \u037e return configProperties \u037e } /** * Get Friendly Name * * @return */ @Override public String getFriendlyName () { return GoogleCustomOAuth2AuthenticationConstant . GOOGLE_CONNECTOR_FRIENDLY_NAME \u037e } /** * GetName * * @return */ @Override public String getName () { return GoogleCustomOAuth2AuthenticationConstant . GOOGLE_CONNECTOR_NAME \u037e } } /* * Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.custom.google \u037e public class GoogleCustomOAuth2AuthenticationConstant { private GoogleCustomOAuth2AuthenticationConstant () {} public static final String GOOGLE_AUTHZ_ENDPOINT = GoogleAuthzEndpoint \u037e public static final String GOOGLE_TOKEN_ENDPOINT = GoogleTokenEndpoint \u037e public static final String GOOGLE_USERINFO_ENDPOINT = GoogleUserInfoEndpoint \u037e public static final String GOOGLE_CONNECTOR_FRIENDLY_NAME = Custom Google Authenticator \u037e public static final String GOOGLE_CONNECTOR_NAME = CustomGoogleOAUth2OpenIDAuthenticator \u037e public static final String GOOGLE_SCOPE = openid email profile \u037e public static final String CALLBACK_URL = Google\u00adcallback\u00adurl \u037e public static final String ADDITIONAL_QUERY_PARAMS = AdditionalQueryParameters \u037e } /* * Copyright (c) WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License )\u037e you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE\u00ad2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.application.authenticator.custom.internal \u037e import org.apache.commons.logging.Log \u037e import org.apache.commons.logging.LogFactory \u037e import org.osgi.service.component.ComponentContext \u037e import org.wso2.carbon.identity.application.authentication.framework.ApplicationAuthenticator \u037e import org.wso2.carbon.identity.application.authenticator.custom.google.GoogleCustomOAuth2Authenticator \u037e import java.util.Hashtable \u037e /** * @scr.component name= identity.application.authenticator.custom.google.component immediate= true */ public class GoogleCustomAuthenticatorServiceComponent { private static final Log LOGGER = LogFactory . getLog ( GoogleCustomAuthenticatorServiceComponent . class ) \u037e protected void activate ( ComponentContext context ) { try { GoogleCustomOAuth2Authenticator googleAuthenticator = new GoogleCustomOAuth2Authenticator () \u037e Hashtable String , String props = new Hashtable String , String () \u037e context . getBundleContext (). registerService ( ApplicationAuthenticator . class . getName (), googleAuthenticator , props ) \u037e if ( LOGGER . isDebugEnabled ()) { LOGGER . debug ( Google custom authenticator bundle is activated ) \u037e } } catch ( Exception e ) { LOGGER . fatal ( Error while activating Google authenticator , e ) \u037e } } protected void deactivate ( ComponentContext context ) { if ( LOGGER . isDebugEnabled ()) { LOGGER . debug ( Google custom authenticator bundle is deactivated ) \u037e } } } ? xml version = 1.0 encoding = utf\u00ad8 ? ! \u00ad\u00ad ~ Copyright ( c ) 2015 , WSO2 Inc . ( http : //www.wso2.org) All Rights Reserved. ~ ~ Licensed under the Apache License , Version 2.0 ( the License ) \u037e ~ you may not use this file except in compliance with the License . ~ You may obtain a copy of the License at ~ ~ http : //www.apache.org/licenses/LICENSE\u00ad2.0 ~ ~ Unless required by applicable law or agreed to in writing , software ~ distributed under the License is distributed on an AS IS BASIS , ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . ~ See the License for the specific language governing permissions and ~ limitations under the License . project xmlns = http://maven.apache.org/POM/4.0.0 xmlns : xsi = http://www.w3.org/2001/XMLSchema\u00adinstance xsi : schemaLocation = http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven\u00adv4_0_0.xsd parent groupId org . wso2 . carbon . identity / groupId artifactId application \u00ad authenticators / artifactId version 5.0.7 / version / parent modelVersion 4.0.0 / modelVersion artifactId org . wso2 . carbon . identity . application . authenticator . custom . google / artifactId packaging bundle / packaging version 5.0.0 / version repositories ! \u00ad\u00ad Before adding ANYTHING in here , please start a discussion on the dev list . Ideally the Axis2 build should only use Maven central ( which is available by default ) and nothing else . We had troubles with other repositories in the past . Therefore configuring additional repositories here should be considered very carefully . \u00ad\u00ad repository id wso2 \u00ad nexus / id name WSO2 internal Repository / name url http : //maven.wso2.org/nexus/content/groups/wso2\u00adpublic/ /url releases enabled true / enabled updatePolicy daily / updatePolicy checksumPolicy ignore / checksumPolicy / releases / repository repository id wso2 . releases / id name WSO2 internal Repository / name url http : //maven.wso2.org/nexus/content/repositories/releases/ /url releases enabled true / enabled updatePolicy daily / updatePolicy checksumPolicy ignore / checksumPolicy / releases / repository repository id wso2 . snapshots / id name WSO2 Snapshot Repository / name url http : //maven.wso2.org/nexus/content/repositories/snapshots/ /url snapshots enabled true / enabled updatePolicy daily / updatePolicy / snapshots releases enabled false / enabled / releases / repository / repositories dependencies dependency groupId org . wso2 . carbon / groupId artifactId org . wso2 . carbon . logging / artifactId / dependency dependency groupId org . wso2 . carbon . identity / groupId artifactId org . wso2 . carbon . identity . application . authentication . framework / artifactId / dependency dependency groupId org . wso2 . carbon / groupId artifactId org . wso2 . carbon . ui / artifactId / dependency dependency groupId org . wso2 . orbit . org . apache . oltu . oauth2 / groupId artifactId oltu / artifactId / dependency dependency groupId org . wso2 . carbon . identity / groupId artifactId org . wso2 . carbon . identity . application . common / artifactId / dependency dependency groupId org . wso2 . carbon . identity / groupId artifactId org . wso2 . carbon . identity . application . authenticator . openid / artifactId / dependency dependency groupId org . wso2 . carbon . identity / groupId artifactId org . wso2 . carbon . identity . application . authenticator . oidc / artifactId / dependency / dependencies build plugins plugin groupId org . apache . felix / groupId artifactId maven \u00ad scr \u00ad plugin / artifactId / plugin plugin groupId org . apache . felix / groupId artifactId maven \u00ad bundle \u00ad plugin / artifactId extensions true / extensions configuration instructions Bundle \u00ad SymbolicName $ { project . artifactId } / Bundle \u00ad SymbolicName Bundle \u00ad Name $ { project . artifactId } / Bundle \u00ad Name Private \u00ad Package org . wso2 . carbon . identity . application . authenticator . custom . internal / Private \u00ad Package Import \u00ad Package javax . servlet . http \u037e version = ${imp.pkg.version.javax.servlet} , org . apache . oltu . oauth2 .* \u037e version = ${oltu.package.import.version.range} , org . apache . commons . lang \u037e version = ${commons\u00adlang.wso2.osgi.version.range} , org . apache . commons . logging \u037e version = ${commons\u00adlogging.osgi.version.range} , org . apache . commons . codec . binary \u037e version = ${commons\u00adcodec.wso2.osgi.version.range} , org . osgi . framework \u037e version = ${osgi.framework.imp.pkg.version.range} , org . osgi . service . component \u037e version = ${osgi.service.component.imp.pkg.version.range} , org . wso2 . carbon . identity . application . authentication . framework .* \u037e version = ${carbon.identity.package.import.version.range} , org . wso2 . carbon . identity . application . common . model \u037e version = ${carbon.identity.package.import.version.range} , org . wso2 . carbon . identity . core . util \u037e version = ${carbon.identity.package.import.version.range} , org . wso2 . carbon . ui \u037e version = ${carbon.kernel.package.import.version.range} , org . wso2 . carbon . identity . application . authenticator . oidc \u037e version = [5.0.7, 5.1.0) / Import \u00ad Package Export \u00ad Package ! org . wso2 . carbon . identity . application . authenticator . custom . internal , org . wso2 . carbon . identity . application . authenticator . custom . google .* \u037e version = 5.0.0 / Export \u00ad Package / instructions / configuration / plugin / plugins / build / project","title":"Custom authenticator for Google"},{"location":"Develop/federate/Writing_a_Custom_Local_Authenticator/","text":"Writing a Custom Local Authenticator Default authenticator of WSO2 Identity Server, is the basic authenticator and it is also a local authenticator which authenticates the end user with connected user store using provided username and password. If a user needs to be authenticated with the user store and authorized based on a specific assigned role, you can write a custom local authenticator. Let's take following sample requirement. You have an app called \u2018playground\u2019 that is used for importing/exporting photos. This app uses OpenID Connect to let the users log into it. During login, only the users who belong to the user role called 'photoSharingRole' should be allowed to be logged in. In other words, the users with other roles should not be able to log into the playground app. To facilitate the above requirement, WSO2 Identity Server provides extension points that has the ability to plug custom local authenticators. The following steps explain how you can write a custom local authenticator by extending the AbstractApplicationAuthenticator class and implementing the LocalApplicationAuthenticator class and how to this custom local authenticator can be plugged in to these extension points. Now let's begin. Create a maven project to write the custom authenticator. ( pom.xml example is given below) ?xml version= 1.0 encoding= utf-8 ? !-- ~ Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. ~ ~ Licensed under the Apache License, Version 2.0 (the License ); ~ you may not use this file except in compliance with the License. ~ You may obtain a copy of the License at ~ ~ http://www.apache.org/licenses/LICENSE-2.0 ~ ~ Unless required by applicable law or agreed to in writing, software ~ distributed under the License is distributed on an AS IS BASIS, ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ~ See the License for the specific language governing permissions and ~ limitations under the License. -- project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd modelVersion 4.0.0 /modelVersion groupId org.wso2.custom.authenticator /groupId artifactId org.wso2.custom.authenticator.local /artifactId packaging bundle /packaging version 1.0.0 /version name WSO2 Carbon - BasicAuth Custom Authenticator /name dependencies dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.utils /artifactId version 4.4.11 /version /dependency dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.logging /artifactId version 4.4.11 /version /dependency dependency groupId org.wso2.carbon.identity.framework /groupId artifactId org.wso2.carbon.identity.application.authentication.framework /artifactId version 5.7.5 /version /dependency /dependencies build plugins plugin artifactId maven-compiler-plugin /artifactId version 2.3.1 /version inherited true /inherited configuration encoding UTF-8 /encoding source 1.7 /source target 1.7 /target /configuration /plugin plugin groupId org.apache.felix /groupId artifactId maven-scr-plugin /artifactId version 1.7.2 /version executions execution id generate-scr-scrdescriptor /id goals goal scr /goal /goals /execution /executions /plugin plugin groupId org.apache.felix /groupId artifactId maven-bundle-plugin /artifactId version 2.3.5 /version extensions true /extensions configuration instructions Bundle-SymbolicName ${project.artifactId} /Bundle-SymbolicName Bundle-Name ${project.artifactId} /Bundle-Name Axis2Module ${project.artifactId}-${project.version} /Axis2Module Import-Package javax.servlet, javax.servlet.http, *;resolution:=optional /Import-Package Private-Package org.wso2.custom.authenticator.local.internal, /Private-Package Export-Package !org.wso2.custom.authenticator.local.internal, org.wso2.custom.authenticator.local.*; version= 1.0.0 /Export-Package /instructions /configuration /plugin /plugins /build repositories repository id wso2-nexus /id name WSO2 internal Repository /name url http://maven.wso2.org/nexus/content/groups/wso2-public/ /url releases enabled true /enabled updatePolicy daily /updatePolicy checksumPolicy ignore /checksumPolicy /releases /repository /repositories pluginRepositories pluginRepository id wso2-maven2-repository /id url http://dist.wso2.org/maven2 /url /pluginRepository /pluginRepositories /project Write a custom local authenticator. The BasicCustomAuthenticatorConsta nts.java file that is referred in the below example is available here. You dont need to write this from scratch. Sample custom authenticator class /* * Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License ); you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.custom.authenticator.local ; import org.apache.commons.logging.Log ; import org.apache.commons.logging.LogFactory ; import org.wso2.carbon.identity.application.common.model.User ; import org.wso2.carbon.identity.core.util.IdentityUtil ; import org.wso2.custom.authenticator.local.internal.BasicCustomAuthenticatorServiceComponent ; import org.wso2.carbon.identity.application.authentication.framework.AbstractApplicationAuthenticator ; import org.wso2.carbon.identity.application.authentication.framework.LocalApplicationAuthenticator ; import org.wso2.carbon.identity.application.authentication.framework.config.ConfigurationFacade ; import org.wso2.carbon.identity.application.authentication.framework.context.AuthenticationContext ; import org.wso2.carbon.identity.application.authentication.framework.exception.AuthenticationFailedException ; import org.wso2.carbon.identity.application.authentication.framework.exception.InvalidCredentialsException ; import org.wso2.carbon.identity.application.authentication.framework.model.AuthenticatedUser ; import org.wso2.carbon.identity.application.authentication.framework.util.FrameworkUtils ; import org.wso2.carbon.user.core.UserStoreException ; import org.wso2.carbon.user.core.UserStoreManager ; import org.wso2.carbon.user.core.common.AbstractUserStoreManager ; import org.wso2.carbon.utils.multitenancy.MultitenantUtils ; import javax.servlet.http.HttpServletRequest ; import javax.servlet.http.HttpServletResponse ; import java.io.IOException ; /** * Username Password based custom Authenticator */ public class BasicCustomAuthenticator extends AbstractApplicationAuthenticator implements LocalApplicationAuthenticator { private static final long serialVersionUID = 4345354156955223654L ; private static final Log log = LogFactory . getLog ( BasicCustomAuthenticator . class ); @Override protected void initiateAuthenticationRequest ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { String loginPage = ConfigurationFacade . getInstance (). getAuthenticationEndpointURL (); //This is the // default WSO2 IS login page. If you can create your custom login page you can use // that instead. String queryParams = FrameworkUtils . getQueryStringWithFrameworkContextId ( context . getQueryParams (), context . getCallerSessionKey (), context . getContextIdentifier ()); try { String retryParam = ; if ( context . isRetrying ()) { retryParam = authFailure=true authFailureMsg=login.fail.message ; } response . sendRedirect ( response . encodeRedirectURL ( loginPage + ( ? + queryParams )) + authenticators=BasicAuthenticator: + LOCAL + retryParam ); } catch ( IOException e ) { throw new AuthenticationFailedException ( e . getMessage (), e ); } } /** * This method is used to process the authentication response. * Inside here we check if this is a authentication request coming from oidc flow and then check if the user is * in the photoSharingRole . */ @Override protected void processAuthenticationResponse ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { String username = request . getParameter ( BasicCustomAuthenticatorConstants . USER_NAME ); boolean isAuthenticated = true ; context . setSubject ( AuthenticatedUser . createLocalAuthenticatedUserFromSubjectIdentifier ( username )); boolean authorization = false ; if ( isAuthenticated ) { if ( oidc . equalsIgnoreCase ( context . getRequestType ())) { // authorization only for openid connect requests try { int tenantId = BasicCustomAuthenticatorServiceComponent . getRealmService (). getTenantManager (). getTenantId ( MultitenantUtils . getTenantDomain ( username )); UserStoreManager userStoreManager = ( UserStoreManager ) BasicCustomAuthenticatorServiceComponent . getRealmService (). getTenantUserRealm ( tenantId ). getUserStoreManager (); // verify user is assigned to role authorization = (( AbstractUserStoreManager ) userStoreManager ). isUserInRole ( username , photoSharingRole ); } catch ( UserStoreException e ) { log . error ( e ); } catch ( org . wso2 . carbon . user . api . UserStoreException e ) { log . error ( e ); } } else { // others scenarios are not verified. authorization = false ; } if (! authorization ) { log . error ( user authorization is failed. ); throw new InvalidCredentialsException ( User authentication failed due to invalid credentials , User . getUserFromUserName ( username )); } } } @Override protected boolean retryAuthenticationEnabled () { return true ; } @Override public String getFriendlyName () { //Set the name to be displayed in local authenticator drop down lsit return BasicCustomAuthenticatorConstants . AUTHENTICATOR_FRIENDLY_NAME ; } @Override public boolean canHandle ( HttpServletRequest httpServletRequest ) { String userName = httpServletRequest . getParameter ( BasicCustomAuthenticatorConstants . USER_NAME ); String password = httpServletRequest . getParameter ( BasicCustomAuthenticatorConstants . PASSWORD ); if ( userName != null password != null ) { return true ; } return false ; } @Override public String getContextIdentifier ( HttpServletRequest httpServletRequest ) { return httpServletRequest . getParameter ( sessionDataKey ); } @Override public String getName () { return BasicCustomAuthenticatorConstants . AUTHENTICATOR_NAME ; } } Write a osgi service component class to register the custom authenticator. /* * Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License ); you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.custom.authenticator.local.internal ; import org.apache.commons.logging.Log ; import org.apache.commons.logging.LogFactory ; import org.osgi.service.component.ComponentContext ; import org.wso2.custom.authenticator.local.BasicCustomAuthenticator ; import org.wso2.carbon.identity.application.authentication.framework.ApplicationAuthenticator ; import org.wso2.carbon.user.core.service.RealmService ; /** * @scr.component name= org.wso2.custom.authenticator.local.basic.component immediate= true * @scr.reference name= realm.service * interface= org.wso2.carbon.user.core.service.RealmService cardinality= 1..1 * policy= dynamic bind= setRealmService unbind= unsetRealmService */ public class BasicCustomAuthenticatorServiceComponent { private static Log log = LogFactory . getLog ( BasicCustomAuthenticatorServiceComponent . class ); private static RealmService realmService ; public static RealmService getRealmService () { return realmService ; } protected void activate ( ComponentContext ctxt ) { try { BasicCustomAuthenticator basicCustomAuth = new BasicCustomAuthenticator (); ctxt . getBundleContext (). registerService ( ApplicationAuthenticator . class . getName (), basicCustomAuth , null ); if ( log . isDebugEnabled ()) { log . info ( BasicCustomAuthenticator bundle is activated ); } } catch ( Throwable e ) { log . error ( BasicCustomAuthenticator bundle activation Failed , e ); } } protected void deactivate ( ComponentContext ctxt ) { if ( log . isDebugEnabled ()) { log . info ( BasicCustomAuthenticator bundle is deactivated ); } } protected void unsetRealmService ( RealmService realmService ) { log . debug ( UnSetting the Realm Service ); BasicCustomAuthenticatorServiceComponent . realmService = null ; } protected void setRealmService ( RealmService realmService ) { log . debug ( Setting the Realm Service ); BasicCustomAuthenticatorServiceComponent . realmService = realmService ; } } Build the project using maven. (Click to see the sample project here) Copy the .jar file org.wso2.custom.authenticator.local-1.0.0.jar inside IS_HOME /repository/components/dropins folder. Start the server. Log into Admin Console. Create a new user (ex: \u2018Alice\u2019). Create a new role (ex: photoSharingRole) and assign the user to it. Create a service provider for the application. (You must have the app deployed on the tomcat server.) In service provider configuration, under \u2018Inbound Authentication Configuration\u2019/\u2018Oauth/OpenID Connect Configuration\u2019, click Configure . {width=\"700\"} Provide the Callback URL and register it as a OAuth2 client app. Under \u2018Local Outbound Authentication Configuration\u2019, select \u2018Local authentication\u2019 check box. On the corresponding drop down list, you can see, \u2018BasicCustom\u2019 which is the display name of the custom authenticator that was written. From the above step, you can make sure your custom authenticator is there and ready for use. Visit the playground app and provide Client ID of the registered playground app and give the Scope as \u2018openid\u2019 to make sure it is in the OpenID Connect flow. Click Authorize . Then you will be directed to WSO2 Identity Server login page. 15. Provide the username and password of the user 'Alice' who is in the \u2018photoSharingRole\u2019. You are prompted to approve the app and logged in. The following is a set of methods related to writing a custom local authenticator. Method Description canHandle() This method checks whether the authentication request is valid, according to the custom authenticator\u2019s requirements. The user will be authenticated if the method returns 'true'. This method also checks whether the authentication or logout request can be handled by the authenticator. For example, you can check if the username and password is 'not null' in the canHandle method. if that succeeds, the authentication flow will continue (to have the user authenticated). process() This method is used to process or carry out the user authentication process. It calls the super.process(), so that the super class will handle the authentication process, and it calls processAuthenticationResponse() method in the custom authenticator class to execute the custom authentication logic. processAuthenticationResponse() Implementation of custom authentication logic happens inside this method. For example, you can call any API that can do authentication and authenticate the user or you can authenticate the user against the underlying user store. Then you can also do any other custom logic after authenticating the user. For example, you can check if a user belongs to a particular role and allow authentication accordingly. initiateAuthenticationrequest() This method is used to redirect the user to the login page in order to authenticate. You can redirect the user to a custom login URL using this method or you can use default WSO2 Identity Server login page. retryAuthenticationEnabled() This method returns a boolean value. If the authentication fails due to some issue like invalid credentials, this method will be called to know whether to retry the authentication flow. If this method returns 'true', the authentication flow will be retried. If returns 'false', the flow is stopped with an exception thrown. You need to override this method if you are calling the super.process() method. But if you are writing your own process() method, you can handle all the retrying logic accordingly within the method. getContextIdentifier() This method gets the Context identifier sent with the request. This identifier is used to retrieve the state of the authentication/logout flow. getFriendlyName() This method returns the name you want to display for your custom authenticator. This name will be displayed in the local authenticators drop down. getname() This method is used to get the name of the authenticator. Attachments: {width=\"8\" height=\"8\"} Service Provider Click Configure.png (image/png)","title":"Writing a Custom Local Authenticator"},{"location":"Develop/federate/Writing_a_Custom_Local_Authenticator/#writing-a-custom-local-authenticator","text":"Default authenticator of WSO2 Identity Server, is the basic authenticator and it is also a local authenticator which authenticates the end user with connected user store using provided username and password. If a user needs to be authenticated with the user store and authorized based on a specific assigned role, you can write a custom local authenticator. Let's take following sample requirement. You have an app called \u2018playground\u2019 that is used for importing/exporting photos. This app uses OpenID Connect to let the users log into it. During login, only the users who belong to the user role called 'photoSharingRole' should be allowed to be logged in. In other words, the users with other roles should not be able to log into the playground app. To facilitate the above requirement, WSO2 Identity Server provides extension points that has the ability to plug custom local authenticators. The following steps explain how you can write a custom local authenticator by extending the AbstractApplicationAuthenticator class and implementing the LocalApplicationAuthenticator class and how to this custom local authenticator can be plugged in to these extension points. Now let's begin. Create a maven project to write the custom authenticator. ( pom.xml example is given below) ?xml version= 1.0 encoding= utf-8 ? !-- ~ Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. ~ ~ Licensed under the Apache License, Version 2.0 (the License ); ~ you may not use this file except in compliance with the License. ~ You may obtain a copy of the License at ~ ~ http://www.apache.org/licenses/LICENSE-2.0 ~ ~ Unless required by applicable law or agreed to in writing, software ~ distributed under the License is distributed on an AS IS BASIS, ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ~ See the License for the specific language governing permissions and ~ limitations under the License. -- project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd modelVersion 4.0.0 /modelVersion groupId org.wso2.custom.authenticator /groupId artifactId org.wso2.custom.authenticator.local /artifactId packaging bundle /packaging version 1.0.0 /version name WSO2 Carbon - BasicAuth Custom Authenticator /name dependencies dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.utils /artifactId version 4.4.11 /version /dependency dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.logging /artifactId version 4.4.11 /version /dependency dependency groupId org.wso2.carbon.identity.framework /groupId artifactId org.wso2.carbon.identity.application.authentication.framework /artifactId version 5.7.5 /version /dependency /dependencies build plugins plugin artifactId maven-compiler-plugin /artifactId version 2.3.1 /version inherited true /inherited configuration encoding UTF-8 /encoding source 1.7 /source target 1.7 /target /configuration /plugin plugin groupId org.apache.felix /groupId artifactId maven-scr-plugin /artifactId version 1.7.2 /version executions execution id generate-scr-scrdescriptor /id goals goal scr /goal /goals /execution /executions /plugin plugin groupId org.apache.felix /groupId artifactId maven-bundle-plugin /artifactId version 2.3.5 /version extensions true /extensions configuration instructions Bundle-SymbolicName ${project.artifactId} /Bundle-SymbolicName Bundle-Name ${project.artifactId} /Bundle-Name Axis2Module ${project.artifactId}-${project.version} /Axis2Module Import-Package javax.servlet, javax.servlet.http, *;resolution:=optional /Import-Package Private-Package org.wso2.custom.authenticator.local.internal, /Private-Package Export-Package !org.wso2.custom.authenticator.local.internal, org.wso2.custom.authenticator.local.*; version= 1.0.0 /Export-Package /instructions /configuration /plugin /plugins /build repositories repository id wso2-nexus /id name WSO2 internal Repository /name url http://maven.wso2.org/nexus/content/groups/wso2-public/ /url releases enabled true /enabled updatePolicy daily /updatePolicy checksumPolicy ignore /checksumPolicy /releases /repository /repositories pluginRepositories pluginRepository id wso2-maven2-repository /id url http://dist.wso2.org/maven2 /url /pluginRepository /pluginRepositories /project Write a custom local authenticator. The BasicCustomAuthenticatorConsta nts.java file that is referred in the below example is available here. You dont need to write this from scratch. Sample custom authenticator class /* * Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License ); you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.custom.authenticator.local ; import org.apache.commons.logging.Log ; import org.apache.commons.logging.LogFactory ; import org.wso2.carbon.identity.application.common.model.User ; import org.wso2.carbon.identity.core.util.IdentityUtil ; import org.wso2.custom.authenticator.local.internal.BasicCustomAuthenticatorServiceComponent ; import org.wso2.carbon.identity.application.authentication.framework.AbstractApplicationAuthenticator ; import org.wso2.carbon.identity.application.authentication.framework.LocalApplicationAuthenticator ; import org.wso2.carbon.identity.application.authentication.framework.config.ConfigurationFacade ; import org.wso2.carbon.identity.application.authentication.framework.context.AuthenticationContext ; import org.wso2.carbon.identity.application.authentication.framework.exception.AuthenticationFailedException ; import org.wso2.carbon.identity.application.authentication.framework.exception.InvalidCredentialsException ; import org.wso2.carbon.identity.application.authentication.framework.model.AuthenticatedUser ; import org.wso2.carbon.identity.application.authentication.framework.util.FrameworkUtils ; import org.wso2.carbon.user.core.UserStoreException ; import org.wso2.carbon.user.core.UserStoreManager ; import org.wso2.carbon.user.core.common.AbstractUserStoreManager ; import org.wso2.carbon.utils.multitenancy.MultitenantUtils ; import javax.servlet.http.HttpServletRequest ; import javax.servlet.http.HttpServletResponse ; import java.io.IOException ; /** * Username Password based custom Authenticator */ public class BasicCustomAuthenticator extends AbstractApplicationAuthenticator implements LocalApplicationAuthenticator { private static final long serialVersionUID = 4345354156955223654L ; private static final Log log = LogFactory . getLog ( BasicCustomAuthenticator . class ); @Override protected void initiateAuthenticationRequest ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { String loginPage = ConfigurationFacade . getInstance (). getAuthenticationEndpointURL (); //This is the // default WSO2 IS login page. If you can create your custom login page you can use // that instead. String queryParams = FrameworkUtils . getQueryStringWithFrameworkContextId ( context . getQueryParams (), context . getCallerSessionKey (), context . getContextIdentifier ()); try { String retryParam = ; if ( context . isRetrying ()) { retryParam = authFailure=true authFailureMsg=login.fail.message ; } response . sendRedirect ( response . encodeRedirectURL ( loginPage + ( ? + queryParams )) + authenticators=BasicAuthenticator: + LOCAL + retryParam ); } catch ( IOException e ) { throw new AuthenticationFailedException ( e . getMessage (), e ); } } /** * This method is used to process the authentication response. * Inside here we check if this is a authentication request coming from oidc flow and then check if the user is * in the photoSharingRole . */ @Override protected void processAuthenticationResponse ( HttpServletRequest request , HttpServletResponse response , AuthenticationContext context ) throws AuthenticationFailedException { String username = request . getParameter ( BasicCustomAuthenticatorConstants . USER_NAME ); boolean isAuthenticated = true ; context . setSubject ( AuthenticatedUser . createLocalAuthenticatedUserFromSubjectIdentifier ( username )); boolean authorization = false ; if ( isAuthenticated ) { if ( oidc . equalsIgnoreCase ( context . getRequestType ())) { // authorization only for openid connect requests try { int tenantId = BasicCustomAuthenticatorServiceComponent . getRealmService (). getTenantManager (). getTenantId ( MultitenantUtils . getTenantDomain ( username )); UserStoreManager userStoreManager = ( UserStoreManager ) BasicCustomAuthenticatorServiceComponent . getRealmService (). getTenantUserRealm ( tenantId ). getUserStoreManager (); // verify user is assigned to role authorization = (( AbstractUserStoreManager ) userStoreManager ). isUserInRole ( username , photoSharingRole ); } catch ( UserStoreException e ) { log . error ( e ); } catch ( org . wso2 . carbon . user . api . UserStoreException e ) { log . error ( e ); } } else { // others scenarios are not verified. authorization = false ; } if (! authorization ) { log . error ( user authorization is failed. ); throw new InvalidCredentialsException ( User authentication failed due to invalid credentials , User . getUserFromUserName ( username )); } } } @Override protected boolean retryAuthenticationEnabled () { return true ; } @Override public String getFriendlyName () { //Set the name to be displayed in local authenticator drop down lsit return BasicCustomAuthenticatorConstants . AUTHENTICATOR_FRIENDLY_NAME ; } @Override public boolean canHandle ( HttpServletRequest httpServletRequest ) { String userName = httpServletRequest . getParameter ( BasicCustomAuthenticatorConstants . USER_NAME ); String password = httpServletRequest . getParameter ( BasicCustomAuthenticatorConstants . PASSWORD ); if ( userName != null password != null ) { return true ; } return false ; } @Override public String getContextIdentifier ( HttpServletRequest httpServletRequest ) { return httpServletRequest . getParameter ( sessionDataKey ); } @Override public String getName () { return BasicCustomAuthenticatorConstants . AUTHENTICATOR_NAME ; } } Write a osgi service component class to register the custom authenticator. /* * Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License ); you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.custom.authenticator.local.internal ; import org.apache.commons.logging.Log ; import org.apache.commons.logging.LogFactory ; import org.osgi.service.component.ComponentContext ; import org.wso2.custom.authenticator.local.BasicCustomAuthenticator ; import org.wso2.carbon.identity.application.authentication.framework.ApplicationAuthenticator ; import org.wso2.carbon.user.core.service.RealmService ; /** * @scr.component name= org.wso2.custom.authenticator.local.basic.component immediate= true * @scr.reference name= realm.service * interface= org.wso2.carbon.user.core.service.RealmService cardinality= 1..1 * policy= dynamic bind= setRealmService unbind= unsetRealmService */ public class BasicCustomAuthenticatorServiceComponent { private static Log log = LogFactory . getLog ( BasicCustomAuthenticatorServiceComponent . class ); private static RealmService realmService ; public static RealmService getRealmService () { return realmService ; } protected void activate ( ComponentContext ctxt ) { try { BasicCustomAuthenticator basicCustomAuth = new BasicCustomAuthenticator (); ctxt . getBundleContext (). registerService ( ApplicationAuthenticator . class . getName (), basicCustomAuth , null ); if ( log . isDebugEnabled ()) { log . info ( BasicCustomAuthenticator bundle is activated ); } } catch ( Throwable e ) { log . error ( BasicCustomAuthenticator bundle activation Failed , e ); } } protected void deactivate ( ComponentContext ctxt ) { if ( log . isDebugEnabled ()) { log . info ( BasicCustomAuthenticator bundle is deactivated ); } } protected void unsetRealmService ( RealmService realmService ) { log . debug ( UnSetting the Realm Service ); BasicCustomAuthenticatorServiceComponent . realmService = null ; } protected void setRealmService ( RealmService realmService ) { log . debug ( Setting the Realm Service ); BasicCustomAuthenticatorServiceComponent . realmService = realmService ; } } Build the project using maven. (Click to see the sample project here) Copy the .jar file org.wso2.custom.authenticator.local-1.0.0.jar inside IS_HOME /repository/components/dropins folder. Start the server. Log into Admin Console. Create a new user (ex: \u2018Alice\u2019). Create a new role (ex: photoSharingRole) and assign the user to it. Create a service provider for the application. (You must have the app deployed on the tomcat server.) In service provider configuration, under \u2018Inbound Authentication Configuration\u2019/\u2018Oauth/OpenID Connect Configuration\u2019, click Configure . {width=\"700\"} Provide the Callback URL and register it as a OAuth2 client app. Under \u2018Local Outbound Authentication Configuration\u2019, select \u2018Local authentication\u2019 check box. On the corresponding drop down list, you can see, \u2018BasicCustom\u2019 which is the display name of the custom authenticator that was written. From the above step, you can make sure your custom authenticator is there and ready for use. Visit the playground app and provide Client ID of the registered playground app and give the Scope as \u2018openid\u2019 to make sure it is in the OpenID Connect flow. Click Authorize . Then you will be directed to WSO2 Identity Server login page. 15. Provide the username and password of the user 'Alice' who is in the \u2018photoSharingRole\u2019. You are prompted to approve the app and logged in. The following is a set of methods related to writing a custom local authenticator. Method Description canHandle() This method checks whether the authentication request is valid, according to the custom authenticator\u2019s requirements. The user will be authenticated if the method returns 'true'. This method also checks whether the authentication or logout request can be handled by the authenticator. For example, you can check if the username and password is 'not null' in the canHandle method. if that succeeds, the authentication flow will continue (to have the user authenticated). process() This method is used to process or carry out the user authentication process. It calls the super.process(), so that the super class will handle the authentication process, and it calls processAuthenticationResponse() method in the custom authenticator class to execute the custom authentication logic. processAuthenticationResponse() Implementation of custom authentication logic happens inside this method. For example, you can call any API that can do authentication and authenticate the user or you can authenticate the user against the underlying user store. Then you can also do any other custom logic after authenticating the user. For example, you can check if a user belongs to a particular role and allow authentication accordingly. initiateAuthenticationrequest() This method is used to redirect the user to the login page in order to authenticate. You can redirect the user to a custom login URL using this method or you can use default WSO2 Identity Server login page. retryAuthenticationEnabled() This method returns a boolean value. If the authentication fails due to some issue like invalid credentials, this method will be called to know whether to retry the authentication flow. If this method returns 'true', the authentication flow will be retried. If returns 'false', the flow is stopped with an exception thrown. You need to override this method if you are calling the super.process() method. But if you are writing your own process() method, you can handle all the retrying logic accordingly within the method. getContextIdentifier() This method gets the Context identifier sent with the request. This identifier is used to retrieve the state of the authentication/logout flow. getFriendlyName() This method returns the name you want to display for your custom authenticator. This name will be displayed in the local authenticators drop down. getname() This method is used to get the name of the authenticator.","title":"Writing a Custom Local Authenticator"},{"location":"Develop/federate/Writing_a_Custom_Local_Authenticator/#attachments","text":"{width=\"8\" height=\"8\"} Service Provider Click Configure.png (image/png)","title":"Attachments:"},{"location":"Develop/provision/Extensible_SCIM_User_Schemas_With_WSO2_Identity_Server/","text":"Extensible SCIM User Schemas With WSO2 Identity Server The SCIM (System for Cross-Domain Identity Management) specification defines a fixed set of default attributes for the user object. This set is defined to ensure the interoperability and it can cater to most of the industry's identity management requirements. Given below is a sample user object with the default attributes set. However the SCIM specification itself introduces the Enterprise User Extension to support extra attributes for the SCIM user object. However the reality in the industry is that organizations have their own attributes defined for the users. These attributes are already there in their LDAP schemas. Therefore SCIM should be extensible enough to cope with these custom attributes of the users. WSO2 Identity Server allows users to define their own user schema in a configuration file ( [IS-HOME]/repository/conf/scim-schema-extension.config ). Then these configured schema are used while creating, validating user objects. With this the users can pass their custom attributes of users over SCIM for Identity Management requirements. The implementation is adhering to the Schema Extension Model . Given below is a sample extended user object with the default schema configuration. Enable Extension Locate the provisioning-config.xml file in the path [IS-HOME]/repository/conf/identity/provisioning-config.xml . Open the file and locate the \" user-schema-extension-enabled \" property and set it to true. Save the file and restart the server. Claims Mapping Log into the Identity Server and do the claim mapping for the following claim URIs (see here for more information on how to do claim mappings). urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . costCenter urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . department urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . division urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . employeeNumber urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . organization urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . manager . displayName urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . manager . managerId Now the server is up and running with the new extended user schema. The claim mappings can map the SCIM user attributes to the LDAP user attributes. Create a new user with the new schema. The following screen depicts the user to be added with the wso2Extension attributes. CURL Commands The following is the cURL command to add a user: Primary Userstore Command Secondary Userstore Command curl - v - k -- user admin : admin -- data { schemas :[], userName : SureshAtt , password : Wso2@123 , wso2Extension :{ employeeNumber : 000111 , costCenter : 111111 , organization : WSO2Org , division : Engineering , department : Intigration , manager :{ managerId : 111000 , displayName : Prabath }}} -- header Content-Type:application/json https : //localhost:9443/wso2/scim/Users curl - v - k -- user admin : admin -- data { schemas :[], userName : mysql / uresh67 , password : Wso2@123 } -- header Content-Type:application/json https : //localhost:9443/wso2/scim/Users Note that the user name is preceded by the domain and is within single quotes 'mysql/uresh67'. Also note that 'mysql' here is a reference to a domain name. The above command provides the following result: Primary Userstore Output Secondary Userstore Output { id : db4f9c15-8426-4381-a669-270975d50421 , wso2Extension :{ organization : WSO2Org , manager :{ managerId : 111000 , displayName : Prabath }, division : Engineering , department : Intigration , costCenter : 111111 , employeeNumber : 73 }, schemas :[ urn:scim:schemas:core:1.0 , urn:scim:schemas:extension:wso2:1.0 ], userName : SureshAtt , meta :{ lastModified : 2013-07-09T13:27:58 , location : https://localhost:9443/wso2/scim/Users/db4f9c15-8426-4381-a669-270975d50421 , created : 2013-07-09T13:27:58 }} { id : 2e89cac0-17f3-40e7-8a07-ff1047a70cf1 , schemas :[ urn:scim:schemas:core:1.0 ], userName : mysql/uresh67 , meta :{ lastModified : 2013-12-17T14:31:30 , location : https://localhost:9443/wso2/scim/Users/2e89cac0-17f3-40e7-8a07-ff1047a70cf1 , created : 2013-12-17T14:31:30 }}* Closing connection # 0 The created SCIM user object can be viewed in the following screen:","title":"Extensible SCIM User Schemas With WSO2 Identity Server"},{"location":"Develop/provision/Extensible_SCIM_User_Schemas_With_WSO2_Identity_Server/#extensible-scim-user-schemas-with-wso2-identity-server","text":"The SCIM (System for Cross-Domain Identity Management) specification defines a fixed set of default attributes for the user object. This set is defined to ensure the interoperability and it can cater to most of the industry's identity management requirements. Given below is a sample user object with the default attributes set. However the SCIM specification itself introduces the Enterprise User Extension to support extra attributes for the SCIM user object. However the reality in the industry is that organizations have their own attributes defined for the users. These attributes are already there in their LDAP schemas. Therefore SCIM should be extensible enough to cope with these custom attributes of the users. WSO2 Identity Server allows users to define their own user schema in a configuration file ( [IS-HOME]/repository/conf/scim-schema-extension.config ). Then these configured schema are used while creating, validating user objects. With this the users can pass their custom attributes of users over SCIM for Identity Management requirements. The implementation is adhering to the Schema Extension Model . Given below is a sample extended user object with the default schema configuration.","title":"Extensible SCIM User Schemas With WSO2 Identity Server"},{"location":"Develop/provision/Extensible_SCIM_User_Schemas_With_WSO2_Identity_Server/#enable-extension","text":"Locate the provisioning-config.xml file in the path [IS-HOME]/repository/conf/identity/provisioning-config.xml . Open the file and locate the \" user-schema-extension-enabled \" property and set it to true. Save the file and restart the server.","title":"Enable Extension"},{"location":"Develop/provision/Extensible_SCIM_User_Schemas_With_WSO2_Identity_Server/#claims-mapping","text":"Log into the Identity Server and do the claim mapping for the following claim URIs (see here for more information on how to do claim mappings). urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . costCenter urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . department urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . division urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . employeeNumber urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . organization urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . manager . displayName urn : scim : schemas : extension : wso2 : 1.0 : wso2Extension . manager . managerId Now the server is up and running with the new extended user schema. The claim mappings can map the SCIM user attributes to the LDAP user attributes. Create a new user with the new schema. The following screen depicts the user to be added with the wso2Extension attributes.","title":"Claims Mapping"},{"location":"Develop/provision/Extensible_SCIM_User_Schemas_With_WSO2_Identity_Server/#curl-commands","text":"The following is the cURL command to add a user: Primary Userstore Command Secondary Userstore Command curl - v - k -- user admin : admin -- data { schemas :[], userName : SureshAtt , password : Wso2@123 , wso2Extension :{ employeeNumber : 000111 , costCenter : 111111 , organization : WSO2Org , division : Engineering , department : Intigration , manager :{ managerId : 111000 , displayName : Prabath }}} -- header Content-Type:application/json https : //localhost:9443/wso2/scim/Users curl - v - k -- user admin : admin -- data { schemas :[], userName : mysql / uresh67 , password : Wso2@123 } -- header Content-Type:application/json https : //localhost:9443/wso2/scim/Users Note that the user name is preceded by the domain and is within single quotes 'mysql/uresh67'. Also note that 'mysql' here is a reference to a domain name. The above command provides the following result: Primary Userstore Output Secondary Userstore Output { id : db4f9c15-8426-4381-a669-270975d50421 , wso2Extension :{ organization : WSO2Org , manager :{ managerId : 111000 , displayName : Prabath }, division : Engineering , department : Intigration , costCenter : 111111 , employeeNumber : 73 }, schemas :[ urn:scim:schemas:core:1.0 , urn:scim:schemas:extension:wso2:1.0 ], userName : SureshAtt , meta :{ lastModified : 2013-07-09T13:27:58 , location : https://localhost:9443/wso2/scim/Users/db4f9c15-8426-4381-a669-270975d50421 , created : 2013-07-09T13:27:58 }} { id : 2e89cac0-17f3-40e7-8a07-ff1047a70cf1 , schemas :[ urn:scim:schemas:core:1.0 ], userName : mysql/uresh67 , meta :{ lastModified : 2013-12-17T14:31:30 , location : https://localhost:9443/wso2/scim/Users/2e89cac0-17f3-40e7-8a07-ff1047a70cf1 , created : 2013-12-17T14:31:30 }}* Closing connection # 0 The created SCIM user object can be viewed in the following screen:","title":"CURL Commands"},{"location":"Develop/provision/Writing_an_Outbound_Provisioning_Connector/","text":"Writing an Outbound Provisioning Connector In addition to Google, Salesforce, SCIM and SPML, it is possible to create custom connectors. Follow the steps given below to write an outbound provisioning connector. The following API is used to configure a custom connector. The connector API can be obtained here . {.expand-control-image}Click here to view the API source code. /* * Copyright (c) 2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License ); you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.provisioning ; import org.apache.commons.collections.CollectionUtils ; import org.apache.commons.lang.StringUtils ; import org.wso2.carbon.CarbonConstants ; import org.wso2.carbon.context.PrivilegedCarbonContext ; import org.wso2.carbon.identity.application.common.model.ClaimMapping ; import org.wso2.carbon.identity.application.common.model.Property ; import java.io.Serializable ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import java.util.UUID ; public abstract class AbstractOutboundProvisioningConnector implements Serializable { private static final long serialVersionUID = 8619915839101228583 L ; private static final String PROVISIONING_IDP = IDP ; private static final String PROVISIONING_TENANT = TD ; private static final String PROVISIONING_DOMAIN = UD ; private static final String PROVISIONING_USER = UN ; protected boolean jitProvisioningEnabled ; /** * @param provisioningProperties * @throws IdentityProvisioningException */ public abstract void init ( Property [] provisioningProperties ) throws IdentityProvisioningException ; /** * @param provisioningEntity * @throws IdentityProvisioningException */ public abstract ProvisionedIdentifier provision ( ProvisioningEntity provisioningEntity ) throws IdentityProvisioningException ; /** * override only if needed - if claims are controlled by the identity provider, this will return * null. If it is connector specific this must return the corresponding claim dialect. * * @return * @throws IdentityProvisioningException */ public String getClaimDialectUri () throws IdentityProvisioningException { return null ; } /** * @return * @throws IdentityProvisioningException */ protected boolean isJitProvisioningEnabled () throws IdentityProvisioningException { return jitProvisioningEnabled ; } /** * @param attributeMap * @return */ protected List String getUserNames ( Map ClaimMapping , List String attributeMap ) { return ProvisioningUtil . getClaimValues ( attributeMap , IdentityProvisioningConstants . USERNAME_CLAIM_URI , getUserStoreDomainName ()); } /** * @param attributeMap * @return */ protected List String getGroupNames ( Map ClaimMapping , List String attributeMap ) { return ProvisioningUtil . getClaimValues ( attributeMap , IdentityProvisioningConstants . GROUP_CLAIM_URI , getUserStoreDomainName ()); } /** * @param attributeMap * @return */ protected String getPassword ( Map ClaimMapping , List String attributeMap ) { List String claimValue = ProvisioningUtil . getClaimValues ( attributeMap , IdentityProvisioningConstants . PASSWORD_CLAIM_URI , null ); if ( CollectionUtils . isNotEmpty ( claimValue ) claimValue . get ( 0 ) != null ) { return claimValue . get ( 0 ); } return UUID . randomUUID (). toString (); } /** * @param attributeMap * @return claimValues */ protected Map String , String getSingleValuedClaims ( Map ClaimMapping , List String attributeMap ) { Map String , String claimValues = new HashMap (); for ( Map . Entry ClaimMapping , List String entry : attributeMap . entrySet ()) { ClaimMapping mapping = entry . getKey (); if ( mapping . getRemoteClaim () != null mapping . getRemoteClaim (). getClaimUri () != null ) { String claimUri = mapping . getRemoteClaim (). getClaimUri (); if (!( IdentityProvisioningConstants . GROUP_CLAIM_URI . equals ( claimUri ) || IdentityProvisioningConstants . PASSWORD_CLAIM_URI . equals ( claimUri ) || IdentityProvisioningConstants . USERNAME_CLAIM_URI . equals ( claimUri ))) { if ( entry . getValue () != null entry . getValue (). get ( 0 ) != null ) { claimValues . put ( claimUri , entry . getValue (). get ( 0 )); } else { claimValues . put ( claimUri , mapping . getDefaultValue ()); } } } } return claimValues ; } /** * @return */ protected String getUserStoreDomainName () { // return null by default. concrete implementations can override this value whenever // required. return null ; } protected String buildUserId ( ProvisioningEntity provisioningEntity , String provisioningPattern , String separator , String idpName ) throws IdentityProvisioningException { Map String , String provValues = new HashMap (); String tenantDomain = PrivilegedCarbonContext . getThreadLocalCarbonContext (). getTenantDomain (); String username = provisioningEntity . getEntityName (); String userStoreDomain = getDomainFromUserName ( username ); if ( separator == null ) { separator = ; } String provIdentifier = ; provValues . put ( PROVISIONING_TENANT , tenantDomain . replaceAll ( separator , )); if ( username != null ) { provValues . put ( PROVISIONING_USER , removeDomainFromUserName ( username )); } provValues . put ( PROVISIONING_IDP , idpName . replaceAll ( separator , )); if ( userStoreDomain != null ) { provValues . put ( PROVISIONING_DOMAIN , userStoreDomain . replaceAll ( separator , )); } String [] provisioningEntries = buildProvisioningEntries ( provisioningPattern ); for ( int i = 0 ; i provisioningEntries . length ; i ++) { if ( StringUtils . isNotBlank ( provisioningEntries [ i ])) { if ( StringUtils . isBlank ( provIdentifier )) { provIdentifier = provValues . get ( provisioningEntries [ i ]. trim ()); } else { provIdentifier = provIdentifier . concat ( separator ). concat ( provValues . get ( provisioningEntries [ i ]. trim ())); } } } return provIdentifier . toLowerCase (); } private String [] buildProvisioningEntries ( String provisioningPattern ) throws IdentityProvisioningException { if (! provisioningPattern . contains ( { ) || ! provisioningPattern . contains ( } )) { throw new IdentityProvisioningException ( Invalid Provisioning Pattern ); } String provisioningPatternWithoutCurlBrace = provisioningPattern . replaceAll ( \\\\{ , ). replaceAll ( \\\\} , ); return provisioningPatternWithoutCurlBrace . split ( , ); } private String getDomainFromUserName ( String username ) { int index ; if (( index = username . indexOf ( / )) 0 ) { String domain = username . substring ( 0 , index ); return domain ; } return PRIMARY ; } private String removeDomainFromUserName ( String username ) { int index ; if (( index = username . indexOf ( CarbonConstants . DOMAIN_SEPARATOR )) = 0 ) { // remove domain name if exist username = username . substring ( index + 1 ); } return username ; } } The Google provisioning connector that uses the API given above can be found here . Using this as an example, you can customize this code according to your requirements. To ensure that the connector works, check whether the following configurations are added in the pom.xml file (found in the above connector API link) inside the project tags. dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.identity.provisioning /artifactId version 5.8.113 /version /dependency repositories repository id wso2-nexus /id name WSO2 internal Repository /name url http://maven.wso2.org/nexus/content/groups/wso2-public/ /url releases enabled true /enabled updatePolicy daily /updatePolicy checksumPolicy ignore /checksumPolicy /releases /repository repository id wso2.releases /id name WSO2 internal Repository /name url http://maven.wso2.org/nexus/content/repositories/releases/ /url releases enabled true /enabled updatePolicy daily /updatePolicy checksumPolicy ignore /checksumPolicy /releases /repository /repositories","title":"Writing an Outbound Provisioning Connector"},{"location":"Develop/provision/Writing_an_Outbound_Provisioning_Connector/#writing-an-outbound-provisioning-connector","text":"In addition to Google, Salesforce, SCIM and SPML, it is possible to create custom connectors. Follow the steps given below to write an outbound provisioning connector. The following API is used to configure a custom connector. The connector API can be obtained here . {.expand-control-image}Click here to view the API source code. /* * Copyright (c) 2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved. * * WSO2 Inc. licenses this file to you under the Apache License, * Version 2.0 (the License ); you may not use this file except * in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.wso2.carbon.identity.provisioning ; import org.apache.commons.collections.CollectionUtils ; import org.apache.commons.lang.StringUtils ; import org.wso2.carbon.CarbonConstants ; import org.wso2.carbon.context.PrivilegedCarbonContext ; import org.wso2.carbon.identity.application.common.model.ClaimMapping ; import org.wso2.carbon.identity.application.common.model.Property ; import java.io.Serializable ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import java.util.UUID ; public abstract class AbstractOutboundProvisioningConnector implements Serializable { private static final long serialVersionUID = 8619915839101228583 L ; private static final String PROVISIONING_IDP = IDP ; private static final String PROVISIONING_TENANT = TD ; private static final String PROVISIONING_DOMAIN = UD ; private static final String PROVISIONING_USER = UN ; protected boolean jitProvisioningEnabled ; /** * @param provisioningProperties * @throws IdentityProvisioningException */ public abstract void init ( Property [] provisioningProperties ) throws IdentityProvisioningException ; /** * @param provisioningEntity * @throws IdentityProvisioningException */ public abstract ProvisionedIdentifier provision ( ProvisioningEntity provisioningEntity ) throws IdentityProvisioningException ; /** * override only if needed - if claims are controlled by the identity provider, this will return * null. If it is connector specific this must return the corresponding claim dialect. * * @return * @throws IdentityProvisioningException */ public String getClaimDialectUri () throws IdentityProvisioningException { return null ; } /** * @return * @throws IdentityProvisioningException */ protected boolean isJitProvisioningEnabled () throws IdentityProvisioningException { return jitProvisioningEnabled ; } /** * @param attributeMap * @return */ protected List String getUserNames ( Map ClaimMapping , List String attributeMap ) { return ProvisioningUtil . getClaimValues ( attributeMap , IdentityProvisioningConstants . USERNAME_CLAIM_URI , getUserStoreDomainName ()); } /** * @param attributeMap * @return */ protected List String getGroupNames ( Map ClaimMapping , List String attributeMap ) { return ProvisioningUtil . getClaimValues ( attributeMap , IdentityProvisioningConstants . GROUP_CLAIM_URI , getUserStoreDomainName ()); } /** * @param attributeMap * @return */ protected String getPassword ( Map ClaimMapping , List String attributeMap ) { List String claimValue = ProvisioningUtil . getClaimValues ( attributeMap , IdentityProvisioningConstants . PASSWORD_CLAIM_URI , null ); if ( CollectionUtils . isNotEmpty ( claimValue ) claimValue . get ( 0 ) != null ) { return claimValue . get ( 0 ); } return UUID . randomUUID (). toString (); } /** * @param attributeMap * @return claimValues */ protected Map String , String getSingleValuedClaims ( Map ClaimMapping , List String attributeMap ) { Map String , String claimValues = new HashMap (); for ( Map . Entry ClaimMapping , List String entry : attributeMap . entrySet ()) { ClaimMapping mapping = entry . getKey (); if ( mapping . getRemoteClaim () != null mapping . getRemoteClaim (). getClaimUri () != null ) { String claimUri = mapping . getRemoteClaim (). getClaimUri (); if (!( IdentityProvisioningConstants . GROUP_CLAIM_URI . equals ( claimUri ) || IdentityProvisioningConstants . PASSWORD_CLAIM_URI . equals ( claimUri ) || IdentityProvisioningConstants . USERNAME_CLAIM_URI . equals ( claimUri ))) { if ( entry . getValue () != null entry . getValue (). get ( 0 ) != null ) { claimValues . put ( claimUri , entry . getValue (). get ( 0 )); } else { claimValues . put ( claimUri , mapping . getDefaultValue ()); } } } } return claimValues ; } /** * @return */ protected String getUserStoreDomainName () { // return null by default. concrete implementations can override this value whenever // required. return null ; } protected String buildUserId ( ProvisioningEntity provisioningEntity , String provisioningPattern , String separator , String idpName ) throws IdentityProvisioningException { Map String , String provValues = new HashMap (); String tenantDomain = PrivilegedCarbonContext . getThreadLocalCarbonContext (). getTenantDomain (); String username = provisioningEntity . getEntityName (); String userStoreDomain = getDomainFromUserName ( username ); if ( separator == null ) { separator = ; } String provIdentifier = ; provValues . put ( PROVISIONING_TENANT , tenantDomain . replaceAll ( separator , )); if ( username != null ) { provValues . put ( PROVISIONING_USER , removeDomainFromUserName ( username )); } provValues . put ( PROVISIONING_IDP , idpName . replaceAll ( separator , )); if ( userStoreDomain != null ) { provValues . put ( PROVISIONING_DOMAIN , userStoreDomain . replaceAll ( separator , )); } String [] provisioningEntries = buildProvisioningEntries ( provisioningPattern ); for ( int i = 0 ; i provisioningEntries . length ; i ++) { if ( StringUtils . isNotBlank ( provisioningEntries [ i ])) { if ( StringUtils . isBlank ( provIdentifier )) { provIdentifier = provValues . get ( provisioningEntries [ i ]. trim ()); } else { provIdentifier = provIdentifier . concat ( separator ). concat ( provValues . get ( provisioningEntries [ i ]. trim ())); } } } return provIdentifier . toLowerCase (); } private String [] buildProvisioningEntries ( String provisioningPattern ) throws IdentityProvisioningException { if (! provisioningPattern . contains ( { ) || ! provisioningPattern . contains ( } )) { throw new IdentityProvisioningException ( Invalid Provisioning Pattern ); } String provisioningPatternWithoutCurlBrace = provisioningPattern . replaceAll ( \\\\{ , ). replaceAll ( \\\\} , ); return provisioningPatternWithoutCurlBrace . split ( , ); } private String getDomainFromUserName ( String username ) { int index ; if (( index = username . indexOf ( / )) 0 ) { String domain = username . substring ( 0 , index ); return domain ; } return PRIMARY ; } private String removeDomainFromUserName ( String username ) { int index ; if (( index = username . indexOf ( CarbonConstants . DOMAIN_SEPARATOR )) = 0 ) { // remove domain name if exist username = username . substring ( index + 1 ); } return username ; } } The Google provisioning connector that uses the API given above can be found here . Using this as an example, you can customize this code according to your requirements. To ensure that the connector works, check whether the following configurations are added in the pom.xml file (found in the above connector API link) inside the project tags. dependency groupId org.wso2.carbon /groupId artifactId org.wso2.carbon.identity.provisioning /artifactId version 5.8.113 /version /dependency repositories repository id wso2-nexus /id name WSO2 internal Repository /name url http://maven.wso2.org/nexus/content/groups/wso2-public/ /url releases enabled true /enabled updatePolicy daily /updatePolicy checksumPolicy ignore /checksumPolicy /releases /repository repository id wso2.releases /id name WSO2 internal Repository /name url http://maven.wso2.org/nexus/content/repositories/releases/ /url releases enabled true /enabled updatePolicy daily /updatePolicy checksumPolicy ignore /checksumPolicy /releases /repository /repositories","title":"Writing an Outbound Provisioning Connector"},{"location":"Develop/user_mgt/Carbon_Remote_User_Store_Manager/","text":"Carbon Remote User Store Manager Carbon Remote User Store Manager is a way of using a user store that is already configured in a WSO2 Carbon product. Consider a scenario where two instances of the WSO2 Identity Server are configured. The first instance (IS1) has a ReadOnlyLDAPUserStoreManager (configured on OpenLDAP) and the second instance (IS2) has JDBCUserStoreManager configured on OracleDB. To expose the users in IS2 to IS1 through the UserStoreManager API, you can call the UserStoreManager admin service operations. WSO2 IS has a standard implementation which uses the admin services. The diagram below illustrates this scenario. Configuring a carbon remote user store manager** ** To configure a carbon remote user store manager, you can follow the following steps. Log in to the management console of the the local server (IS1) and click User Stores Add in the Main menu. Fill in the following values in the form as seen below. The image below shows a sample configuration. **User Store Manager Class: **org.wso2.carbon.identity.user.store.remote.CarbonRemoteUserstoreManger Domain Name: desired_secondary_userstore_name Remote Server Username: remote_admin_login Remote Server Password: remote_admin_password Remote Server URL(s): https://:/services Make sure that you insert the same credentials used to invoke the admin services in the remote server and the same remote services URL. {width=\"519\"} Update other fields as required (description is give for each property) and click Add. Attachments: {width=\"8\" height=\"8\"} image2017-3-8 12:21:17.png (image/png) {width=\"8\" height=\"8\"} IS_CarbonRemoteUserStoreManager.png (image/png) {width=\"8\" height=\"8\"} Screenshot from 2016-01-14 18:15:37.png (image/png) {width=\"8\" height=\"8\"} Screenshot from 2016-01-14 18:13:00.png (image/png) {width=\"8\" height=\"8\"} add.png (image/png) {width=\"8\" height=\"8\"} Untitled drawing (2).png (image/png)","title":"Carbon Remote User Store Manager"},{"location":"Develop/user_mgt/Carbon_Remote_User_Store_Manager/#carbon-remote-user-store-manager","text":"Carbon Remote User Store Manager is a way of using a user store that is already configured in a WSO2 Carbon product. Consider a scenario where two instances of the WSO2 Identity Server are configured. The first instance (IS1) has a ReadOnlyLDAPUserStoreManager (configured on OpenLDAP) and the second instance (IS2) has JDBCUserStoreManager configured on OracleDB. To expose the users in IS2 to IS1 through the UserStoreManager API, you can call the UserStoreManager admin service operations. WSO2 IS has a standard implementation which uses the admin services. The diagram below illustrates this scenario.","title":"Carbon Remote User Store Manager"},{"location":"Develop/user_mgt/Carbon_Remote_User_Store_Manager/#configuring-a-carbon-remote-user-store-manager","text":"To configure a carbon remote user store manager, you can follow the following steps. Log in to the management console of the the local server (IS1) and click User Stores Add in the Main menu. Fill in the following values in the form as seen below. The image below shows a sample configuration. **User Store Manager Class: **org.wso2.carbon.identity.user.store.remote.CarbonRemoteUserstoreManger Domain Name: desired_secondary_userstore_name Remote Server Username: remote_admin_login Remote Server Password: remote_admin_password Remote Server URL(s): https://:/services Make sure that you insert the same credentials used to invoke the admin services in the remote server and the same remote services URL. {width=\"519\"} Update other fields as required (description is give for each property) and click Add.","title":"Configuring a carbon remote user store manager**\u00a0**"},{"location":"Develop/user_mgt/Carbon_Remote_User_Store_Manager/#attachments","text":"{width=\"8\" height=\"8\"} image2017-3-8 12:21:17.png (image/png) {width=\"8\" height=\"8\"} IS_CarbonRemoteUserStoreManager.png (image/png) {width=\"8\" height=\"8\"} Screenshot from 2016-01-14 18:15:37.png (image/png) {width=\"8\" height=\"8\"} Screenshot from 2016-01-14 18:13:00.png (image/png) {width=\"8\" height=\"8\"} add.png (image/png) {width=\"8\" height=\"8\"} Untitled drawing (2).png (image/png)","title":"Attachments:"},{"location":"Develop/user_mgt/User_Store_Listeners/","text":"User Store Listeners WSO2 Carbon User Stores provide the ability to customize user store operations by registering an event listener for these operations. The listeners are executed at a fixed point in the user store operation, and the users are free to create a listener which implements their desired logic to be executed at these fixed points. Listener is an extension to extend the user core functions. Any number of listeners can be plugged with the user core and they would be called one by one. By using a listener, you are not overriding the user store implementation, which is good since you are not customizing the existing implementations. The following diagram demonstrates a typical flow of execution of the user store operation, along with the listener's methods. The 'operation' method (here, representative of any user store operation) first calls the listener.doPreOperation which is implemented in the listener, then calls the doOperation , which is implemented in the subclass extending the org.wso2.carbon.user.core.common.AbstractUserStoreManager (the abstract class which implements the UserStoreManager interface). After this, the listener.doPostOperation method is called. However, this flow will change depending on the implementation (for instance in the carbon authorization flow, there is only one listener method that is being called). How listeners work Every time when the user core method is called, all the listeners that are registered with that method are called. Listeners can be registered before or after the actual method is called. Consider this example; in the user core there is a method called addUser() . When a user is created in WSO2 Identity Server, the addUser() method is called. You can register a listener before the actual execution of addUser() method and also, you can register a listener after the actual execution of addUser() method. The addUser() method can be seen as follows. addUser () { preAddUser (); // you can implement this using listener actualAddUser (); postAddUser (); // you can implement this using listener } Both preAddUser() and postAddUser() method can be customized as you want. This means you can do some customizations before the user is added or after the user is added. **All the methods in the user core **have been implemented as above. You can customize them both before and after. Consider the following simple scenario: When a user is authenticated with an LDAP, there is a requirement to add the authenticated time as an attribute of the user. For this requirement, you need to write some custom code after successful user authentication happened. The following is the custom listener implementation for this. The doPostAuthenticate() method would be called after actual user authentication is done. package org.soasecurity.user.mgt.custom.extension ; import org.apache.commons.logging.Log ; import org.apache.commons.logging.LogFactory ; import org.wso2.carbon.user.core.UserStoreException ; import org.wso2.carbon.user.core.UserStoreManager ; import org.wso2.carbon.user.core.common.AbstractUserOperationEventListener ; /** * */ public class MyUserMgtCustomExtension extends AbstractUserOperationEventListener { private static Log log = LogFactory . getLog ( MyUserMgtCustomExtension . class ); @Override public int getExecutionOrderId () { return 9883 ; } @Override public boolean doPreAuthenticate ( String userName , Object credential , UserStoreManager userStoreManager ) throws UserStoreException { // just log log . info ( doPreAuthenticate method is called before authenticating with user store ); return true ; } @Override public boolean doPostAuthenticate ( String userName , boolean authenticated , UserStoreManager userStoreManager ) throws UserStoreException { // just log log . info ( doPreAuthenticate method is called after authenticating with user store ); // custom logic // check whether user is authenticated if ( authenticated ){ // persist user attribute in to user store // http://wso2.org/claims/lastlogontime is the claim uri which represent the LDAP attribute // more detail about claim management from here http://soasecurity.org/2012/05/02/claim-management-with-wso2-identity-server/ userStoreManager . setUserClaimValue ( userName , http://wso2.org/claims/lastlogontime , Long . toString ( System . currentTimeMillis ()), null ); } return true ; } } Likewise, you can add custom extensions to any method of the user core. Tip : Make note of the following. The getExecutionOrderId() method can return any random value. This is important when there is more than one listener in the Identity Server and you need to consider the execution order of them All the methods return a boolean value. This value is mentioned regardless of whether you want to execute the next listener or not. The following are the steps to configure the custom implementation. Listeners are registered as OSGI components. Therefore you need to register this class in an OSGI framework. You can go through ** this , **which is the complete sample project. Copy the OSGI bundle file in to the IS_HOME /repository/components/dropins directory. Restart the server. Interfaces In WSO2 Carbon products that use the standard user manager kernel, there are multiple interfaces with which you can implement User Store Listeners. Listener Interface Operation Type Caller Class Remarks org.wso2.carbon.user.core.listener.AuthorizationManagerListener doPreOperation org.wso2.carbon.user.core.authorization.JDBCAuthorizationManager Only one listener method which gets called before each implemented operation logic org.wso2.carbon.user.core.listener.ClaimManagerListener doPreOperation org.wso2.carbon.user.core.claim.DefaultClaimManager Only one listener method which gets called before each implemented operation logic org.wso2.carbon.user.core.listener.UserOperationEventListener doPreOperation and doPostOperation org.wso2.carbon.user.core.common.AbstractUserStoreManager pre and post operations that get called before and after (respectively) implemented operation logic org.wso2.carbon.user.core.listener.UserStoreManagerConfigurationListener doPreOperation org.wso2.carbon.user.core.common.AbstractUserStoreManager One listener method which is executed before the implemented logic org.wso2.carbon.user.core.listener.UserStoreManagerListener doPreOperation org.wso2.carbon.user.core.common.AbstractUserStoreManager One listener method which is executed before the implemented logic It is recommended to extend the existing abstract implementation of these interfaces rather than implementing from scratch. For example, org.wso2.carbon.user.core.listener.UserOperationEventListener is implemented in the org.wso2.carbon.user.core.common.AbstractUserOperationEventListener abstract class. Attachments: {width=\"8\" height=\"8\"} image2017-3-8 12:51:43.png (image/png) {width=\"8\" height=\"8\"} Untitled drawing (1).png (image/png) {width=\"8\" height=\"8\"} Untitled drawing.png (image/png)","title":"User Store Listeners"},{"location":"Develop/user_mgt/User_Store_Listeners/#user-store-listeners","text":"WSO2 Carbon User Stores provide the ability to customize user store operations by registering an event listener for these operations. The listeners are executed at a fixed point in the user store operation, and the users are free to create a listener which implements their desired logic to be executed at these fixed points. Listener is an extension to extend the user core functions. Any number of listeners can be plugged with the user core and they would be called one by one. By using a listener, you are not overriding the user store implementation, which is good since you are not customizing the existing implementations. The following diagram demonstrates a typical flow of execution of the user store operation, along with the listener's methods. The 'operation' method (here, representative of any user store operation) first calls the listener.doPreOperation which is implemented in the listener, then calls the doOperation , which is implemented in the subclass extending the org.wso2.carbon.user.core.common.AbstractUserStoreManager (the abstract class which implements the UserStoreManager interface). After this, the listener.doPostOperation method is called. However, this flow will change depending on the implementation (for instance in the carbon authorization flow, there is only one listener method that is being called).","title":"User Store Listeners"},{"location":"Develop/user_mgt/User_Store_Listeners/#how-listeners-work","text":"Every time when the user core method is called, all the listeners that are registered with that method are called. Listeners can be registered before or after the actual method is called. Consider this example; in the user core there is a method called addUser() . When a user is created in WSO2 Identity Server, the addUser() method is called. You can register a listener before the actual execution of addUser() method and also, you can register a listener after the actual execution of addUser() method. The addUser() method can be seen as follows. addUser () { preAddUser (); // you can implement this using listener actualAddUser (); postAddUser (); // you can implement this using listener } Both preAddUser() and postAddUser() method can be customized as you want. This means you can do some customizations before the user is added or after the user is added. **All the methods in the user core **have been implemented as above. You can customize them both before and after. Consider the following simple scenario: When a user is authenticated with an LDAP, there is a requirement to add the authenticated time as an attribute of the user. For this requirement, you need to write some custom code after successful user authentication happened. The following is the custom listener implementation for this. The doPostAuthenticate() method would be called after actual user authentication is done. package org.soasecurity.user.mgt.custom.extension ; import org.apache.commons.logging.Log ; import org.apache.commons.logging.LogFactory ; import org.wso2.carbon.user.core.UserStoreException ; import org.wso2.carbon.user.core.UserStoreManager ; import org.wso2.carbon.user.core.common.AbstractUserOperationEventListener ; /** * */ public class MyUserMgtCustomExtension extends AbstractUserOperationEventListener { private static Log log = LogFactory . getLog ( MyUserMgtCustomExtension . class ); @Override public int getExecutionOrderId () { return 9883 ; } @Override public boolean doPreAuthenticate ( String userName , Object credential , UserStoreManager userStoreManager ) throws UserStoreException { // just log log . info ( doPreAuthenticate method is called before authenticating with user store ); return true ; } @Override public boolean doPostAuthenticate ( String userName , boolean authenticated , UserStoreManager userStoreManager ) throws UserStoreException { // just log log . info ( doPreAuthenticate method is called after authenticating with user store ); // custom logic // check whether user is authenticated if ( authenticated ){ // persist user attribute in to user store // http://wso2.org/claims/lastlogontime is the claim uri which represent the LDAP attribute // more detail about claim management from here http://soasecurity.org/2012/05/02/claim-management-with-wso2-identity-server/ userStoreManager . setUserClaimValue ( userName , http://wso2.org/claims/lastlogontime , Long . toString ( System . currentTimeMillis ()), null ); } return true ; } } Likewise, you can add custom extensions to any method of the user core. Tip : Make note of the following. The getExecutionOrderId() method can return any random value. This is important when there is more than one listener in the Identity Server and you need to consider the execution order of them All the methods return a boolean value. This value is mentioned regardless of whether you want to execute the next listener or not. The following are the steps to configure the custom implementation. Listeners are registered as OSGI components. Therefore you need to register this class in an OSGI framework. You can go through ** this , **which is the complete sample project. Copy the OSGI bundle file in to the IS_HOME /repository/components/dropins directory. Restart the server.","title":"How listeners work"},{"location":"Develop/user_mgt/User_Store_Listeners/#interfaces","text":"In WSO2 Carbon products that use the standard user manager kernel, there are multiple interfaces with which you can implement User Store Listeners. Listener Interface Operation Type Caller Class Remarks org.wso2.carbon.user.core.listener.AuthorizationManagerListener doPreOperation org.wso2.carbon.user.core.authorization.JDBCAuthorizationManager Only one listener method which gets called before each implemented operation logic org.wso2.carbon.user.core.listener.ClaimManagerListener doPreOperation org.wso2.carbon.user.core.claim.DefaultClaimManager Only one listener method which gets called before each implemented operation logic org.wso2.carbon.user.core.listener.UserOperationEventListener doPreOperation and doPostOperation org.wso2.carbon.user.core.common.AbstractUserStoreManager pre and post operations that get called before and after (respectively) implemented operation logic org.wso2.carbon.user.core.listener.UserStoreManagerConfigurationListener doPreOperation org.wso2.carbon.user.core.common.AbstractUserStoreManager One listener method which is executed before the implemented logic org.wso2.carbon.user.core.listener.UserStoreManagerListener doPreOperation org.wso2.carbon.user.core.common.AbstractUserStoreManager One listener method which is executed before the implemented logic It is recommended to extend the existing abstract implementation of these interfaces rather than implementing from scratch. For example, org.wso2.carbon.user.core.listener.UserOperationEventListener is implemented in the org.wso2.carbon.user.core.common.AbstractUserOperationEventListener abstract class.","title":"Interfaces"},{"location":"Develop/user_mgt/User_Store_Listeners/#attachments","text":"{width=\"8\" height=\"8\"} image2017-3-8 12:51:43.png (image/png) {width=\"8\" height=\"8\"} Untitled drawing (1).png (image/png) {width=\"8\" height=\"8\"} Untitled drawing.png (image/png)","title":"Attachments:"},{"location":"Develop/user_mgt/Using_the_User_Management_Errors_Event_Listener/","text":"Using the User Management Errors Event Listener The UserManagementErrorEventListener (i.e. org.wso2.carbon.user.core.listener.UserManagementErrorEventListener ) is a new type of event listener that facilitates additional activities in the event of failures when executing user management scenarios or operations. The relevant caller class for this listener is org.wso2.carbon.user.core.common.AbstractUserManagementErrorListener . This type of event listener is similar to the UserOperation Listeners . The registered event listeners of this type are called when there is a failure while doing user management related tasks. Operations The getExecutionOrderId method returns the order ID of the relevant listener. Additionally, the following methods are exposed by this interface in order to support additional activities in an event of failure. onAuthenticateFailure onAddUserFailure onUpdateCredentialFailure onUpdateCredentialByAdminFailure onDeleteUserFailure onSetUserClaimValueFailure onSetUserClaimValuesFailure onDeleteUserClaimValuesFailure onDeleteUserClaimValueFailure onAddRoleFailure onDeleteRoleFailure onUpdateRoleNameFailure onUpdateUserListOfRoleFailure onUpdateRoleListOfUserFailure onGetUserClaimValueFailure onGetUserClaimValuesFailure onUpdatePermissionsOfRoleFailure onGetUserListFailure `` Note: In order to return the order ID of a custom listener, you must override the getExecutionOrderId method. Specify a value greater than 0 for the custom listener as the order ID '0' is reserved for the default listener of WSO2 Identity Server. For more information about the purpose of each method, see the java docs.","title":"Using the User Management Errors Event Listener"},{"location":"Develop/user_mgt/Using_the_User_Management_Errors_Event_Listener/#using-the-user-management-errors-event-listener","text":"The UserManagementErrorEventListener (i.e. org.wso2.carbon.user.core.listener.UserManagementErrorEventListener ) is a new type of event listener that facilitates additional activities in the event of failures when executing user management scenarios or operations. The relevant caller class for this listener is org.wso2.carbon.user.core.common.AbstractUserManagementErrorListener . This type of event listener is similar to the UserOperation Listeners . The registered event listeners of this type are called when there is a failure while doing user management related tasks.","title":"Using the User Management Errors Event Listener"},{"location":"Develop/user_mgt/Using_the_User_Management_Errors_Event_Listener/#operations","text":"The getExecutionOrderId method returns the order ID of the relevant listener. Additionally, the following methods are exposed by this interface in order to support additional activities in an event of failure. onAuthenticateFailure onAddUserFailure onUpdateCredentialFailure onUpdateCredentialByAdminFailure onDeleteUserFailure onSetUserClaimValueFailure onSetUserClaimValuesFailure onDeleteUserClaimValuesFailure onDeleteUserClaimValueFailure onAddRoleFailure onDeleteRoleFailure onUpdateRoleNameFailure onUpdateUserListOfRoleFailure onUpdateRoleListOfUserFailure onGetUserClaimValueFailure onGetUserClaimValuesFailure onUpdatePermissionsOfRoleFailure onGetUserListFailure `` Note: In order to return the order ID of a custom listener, you must override the getExecutionOrderId method. Specify a value greater than 0 for the custom listener as the order ID '0' is reserved for the default listener of WSO2 Identity Server. For more information about the purpose of each method, see the java docs.","title":"Operations"},{"location":"Develop/user_mgt/Writing_a_Custom_Claim_Handler/","text":"Writing a Custom Claim Handler WSO2 Identity Server (WSO2 IS) supports SAML authentication and single sign-on capabilities where WSO2 IS can act as the identity provider for a relying party application (i.e., service provider). When SAML single sign-on is used in an enterprise system, it is through the SAML response that the relying party gets to know whether a user is authenticated or not. At this point the relying party application is not aware of the attributes of an authenticated user, which would be required for certain business and authorization purposes. You can use WSO2 IS to provide these attribute details to the relying party application, by configuring WSO2 IS to send user claims in a SAML response using the service provider claim configuration. For information on how to configure WSO2 IS to send user claims in a SAML response, see Configuring Claims for a Service Provider . The claims that you can send using the service provider claim configuration are default user claims, which can be read from the underlying user store. However, there can be scenarios where you want to send claims that need to be read from an external data source (i.e., custom claims) based on certain user attributes requested by a relying party application. If you want to add such custom claims to a SAML response, you need to write a custom claim handler to extend WSO2 IS. Let\u2019s look at how to add custom claims to a SAML response using a sample scenario where you need to provide several local attributes of a user, which are stored in user store, together with a few additional attributes that should be read from an external data source. Introduction Writing the custom claim handler Deploying the custom claim handler Introduction The SAML response that should be sent from WSO2 IS to the relying party application is as follows: ? xml version = 1.0 ? saml2p : Response xmlns : saml2p = urn:oasis:names:tc:SAML:2.0:protocol xmlns : xs = http://www.w3.org/2001/XMLSchema Destination = https://localhost:9444/acs ID = faibaccbcepemkackalbbjkihlegenhhigcdjbjk InResponseTo = kbedjkocfjdaaadgmjeipbegnclbelfffbpbophe IssueInstant = 2014-07-17T13:15:05.032Z Version = 2.0 saml2 : Issuer xmlns : saml2 = urn:oasis:names:tc:SAML:2.0:assertion Format = urn:oasis:names:tc:SAML:2.0:nameid-format:entity localhost / saml2 : Issuer ds : Signature xmlns : ds = http://www.w3.org/2000/09/xmldsig# .......... / ds : Signature saml2p : Status saml2p : StatusCode Value = urn:oasis:names:tc:SAML:2.0:status:Success / / saml2p : Status saml2 : Assertion xmlns : saml2 = urn:oasis:names:tc:SAML:2.0:assertion xmlns : xs = http://www.w3.org/2001/XMLSchema ID = phmbbieedpcfdhcignelnepkemobepgaaipbjjdk IssueInstant = 2014-07-17T13:15:05.032Z Version = 2.0 saml2 : Issuer Format = urn:oasis:names:tc:SAML:2.0:nameid-format:entity localhost / saml2 : Issuer ds : Signature xmlns : ds = http://www.w3.org/2000/09/xmldsig# ......... / ds : Signature saml2 : Subject saml2 : NameID Format = urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress Administrator / saml2 : NameID saml2 : SubjectConfirmation Method = urn:oasis:names:tc:SAML:2.0:cm:bearer saml2 : SubjectConfirmationData InResponseTo = kbedjkocfjdaaadgmjeipbegnclbelfffbpbophe NotOnOrAfter = 2014-07-17T13:20:05.032Z Recipient = https://localhost:9444/acs / / saml2 : SubjectConfirmation / saml2 : Subject saml2 : Conditions NotBefore = 2014-07-17T13:15:05.032Z NotOnOrAfter = 2014-07-17T13:20:05.032Z saml2 : AudienceRestriction saml2 : Audience carbonServer2 / saml2 : Audience / saml2 : AudienceRestriction / saml2 : Conditions saml2 : AuthnStatement AuthnInstant = 2014-07-17T13:15:05.033Z saml2 : AuthnContext saml2 : AuthnContextClassRef urn : oasis : names : tc : SAML : 2.0 : ac : classes : Password / saml2 : AuthnContextClassRef / saml2 : AuthnContext / saml2 : AuthnStatement saml2 : AttributeStatement saml2 : Attribute Name = http://wso2.org/claims/role NameFormat = urn:oasis:names:tc:SAML:2.0:attrname-format:basic saml2 : AttributeValue xmlns : xsi = http://www.w3.org/2001/XMLSchema-instance xsi : type = xs:string Internal / carbonServer2 , Internal / everyone / saml2 : AttributeValue / saml2 : Attribute saml2 : AttributeStatement saml2 : Attribute Name = http://test.org/claims/keplerNumber NameFormat = urn:oasis:names:tc:SAML:2.0:attrname-format:basic saml2 : AttributeValue xmlns : xsi = http://www.w3.org/2001/XMLSchema-instance xsi : type = xs:string E90836W19881010 / saml2 : AttributeValue / saml2 : Attribute saml2 : Attribute Name = http://test.org/claims/status NameFormat = urn:oasis:names:tc:SAML:2.0:attrname-format:basic saml2 : AttributeValue xmlns : xsi = http://www.w3.org/2001/XMLSchema-instance xsi : type = xs:string active / saml2 : AttributeValue / saml2 : Attribute / saml2 : AttributeStatement / saml2 : AttributeStatement / saml2 : Assertion / saml2p : Response This response has one local attribute named role , and two external attributes as follows: http://test.org/claims/keplerNumber http://test.org/claims/status The external attributes can be read from either a database, or a file, or via any other mechanism depending on your requirement. To retrieve the external attributes in this response, you need to write a custom claim handler. Writing the custom claim handler Follow the steps below: Implement the custom logic to retrieve external claims. When you implement the custom logic, keep the following in mind: The custom implementation should either implement the org.wso2.carbon.identity.application.authentication.framework.handler.claims.ClaimHandler interface, or should extend the default implementation of the org.wso2.carbon.identity.application.authentication.framework.handler.claims.impl.DefaultClaimHandler interface. The map that returns at the public Map String, String handleClaimMappings method should contain all the attributes that you want to add to the SAML response. Following is a sample custom claim handler that implements the org.wso2.carbon.identity.application.authentication.framework.handler.claims.ClaimHandler interface: public class CustomClaimHandler implements ClaimHandler { private static Log log = LogFactory . getLog ( CustomClaimHandler . class ); private static volatile CustomClaimHandler instance ; private String connectionURL = null ; private String userName = null ; private String password = null ; private String jdbcDriver = null ; private String sql = null ; public static CustomClaimHandler getInstance () { if ( instance == null ) { synchronized ( CustomClaimHandler . class ) { if ( instance == null ) { instance = new CustomClaimHandler (); } } } return instance ; } public Map String , String handleClaimMappings ( StepConfig stepConfig , AuthenticationContext context , Map String , String remoteAttributes , boolean isFederatedClaims ) throws FrameworkException { String authenticatedUser = null ; if ( stepConfig != null ) { //calling from StepBasedSequenceHandler authenticatedUser = stepConfig . getAuthenticatedUser (); } else { //calling from RequestPathBasedSequenceHandler authenticatedUser = context . getSequenceConfig (). getAuthenticatedUser (); } Map String , String claims = handleLocalClaims ( authenticatedUser , context ); claims . putAll ( handleExternalClaims ( authenticatedUser )); return claims ; } /** * @param context * @return * @throws FrameworkException */ protected Map String , String handleLocalClaims ( String authenticatedUser , AuthenticationContext context ) throws FrameworkException { .... } private Map String , String getFilteredAttributes ( Map String , String allAttributes , Map String , String requestedClaimMappings , boolean isStandardDialect ) { .... } protected String getDialectUri ( String clientType , boolean claimMappingDefined ) { .... } /** * Added method to retrieve claims from external sources. The results will be merged to the local claims when * returning the final claim list to be added to the SAML response that is sent back to the SP. * * @param authenticatedUser : The user for whom we require claim values * @return */ private Map String , String handleExternalClaims ( String authenticatedUser ) throws FrameworkException { Map String , String externalClaims = new HashMap String , String (); externalClaims . put ( http://test.org/claims/keplerNumber , E90836W19881010 ); externalClaims . put ( http://test.org/claims/status , active ); return externalClaims ; } } After you write the custom claim handler, and register the class as an OSGI bundle, you can deploy the OSGi bundle in WSO2 IS. Deploying the custom claim handler Follow the steps below to deploy the custom claim handler that you implemented: Add the compiled OSGi bundle to the IS_HOME/repository/components/dropins directory. Edit the IS_HOME /repository/conf/identity/application-authentication.xml file, and add the following under the Extensions element. ClaimHandler com . wso2 . sample . claim . handler . CustomClaimHandler / ClaimHandler This allows you to use the new custom claim implementation with WSO2 IS.","title":"Writing a Custom Claim Handler"},{"location":"Develop/user_mgt/Writing_a_Custom_Claim_Handler/#writing-a-custom-claim-handler","text":"WSO2 Identity Server (WSO2 IS) supports SAML authentication and single sign-on capabilities where WSO2 IS can act as the identity provider for a relying party application (i.e., service provider). When SAML single sign-on is used in an enterprise system, it is through the SAML response that the relying party gets to know whether a user is authenticated or not. At this point the relying party application is not aware of the attributes of an authenticated user, which would be required for certain business and authorization purposes. You can use WSO2 IS to provide these attribute details to the relying party application, by configuring WSO2 IS to send user claims in a SAML response using the service provider claim configuration. For information on how to configure WSO2 IS to send user claims in a SAML response, see Configuring Claims for a Service Provider . The claims that you can send using the service provider claim configuration are default user claims, which can be read from the underlying user store. However, there can be scenarios where you want to send claims that need to be read from an external data source (i.e., custom claims) based on certain user attributes requested by a relying party application. If you want to add such custom claims to a SAML response, you need to write a custom claim handler to extend WSO2 IS. Let\u2019s look at how to add custom claims to a SAML response using a sample scenario where you need to provide several local attributes of a user, which are stored in user store, together with a few additional attributes that should be read from an external data source. Introduction Writing the custom claim handler Deploying the custom claim handler","title":"Writing a Custom Claim Handler"},{"location":"Develop/user_mgt/Writing_a_Custom_Claim_Handler/#introduction","text":"The SAML response that should be sent from WSO2 IS to the relying party application is as follows: ? xml version = 1.0 ? saml2p : Response xmlns : saml2p = urn:oasis:names:tc:SAML:2.0:protocol xmlns : xs = http://www.w3.org/2001/XMLSchema Destination = https://localhost:9444/acs ID = faibaccbcepemkackalbbjkihlegenhhigcdjbjk InResponseTo = kbedjkocfjdaaadgmjeipbegnclbelfffbpbophe IssueInstant = 2014-07-17T13:15:05.032Z Version = 2.0 saml2 : Issuer xmlns : saml2 = urn:oasis:names:tc:SAML:2.0:assertion Format = urn:oasis:names:tc:SAML:2.0:nameid-format:entity localhost / saml2 : Issuer ds : Signature xmlns : ds = http://www.w3.org/2000/09/xmldsig# .......... / ds : Signature saml2p : Status saml2p : StatusCode Value = urn:oasis:names:tc:SAML:2.0:status:Success / / saml2p : Status saml2 : Assertion xmlns : saml2 = urn:oasis:names:tc:SAML:2.0:assertion xmlns : xs = http://www.w3.org/2001/XMLSchema ID = phmbbieedpcfdhcignelnepkemobepgaaipbjjdk IssueInstant = 2014-07-17T13:15:05.032Z Version = 2.0 saml2 : Issuer Format = urn:oasis:names:tc:SAML:2.0:nameid-format:entity localhost / saml2 : Issuer ds : Signature xmlns : ds = http://www.w3.org/2000/09/xmldsig# ......... / ds : Signature saml2 : Subject saml2 : NameID Format = urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress Administrator / saml2 : NameID saml2 : SubjectConfirmation Method = urn:oasis:names:tc:SAML:2.0:cm:bearer saml2 : SubjectConfirmationData InResponseTo = kbedjkocfjdaaadgmjeipbegnclbelfffbpbophe NotOnOrAfter = 2014-07-17T13:20:05.032Z Recipient = https://localhost:9444/acs / / saml2 : SubjectConfirmation / saml2 : Subject saml2 : Conditions NotBefore = 2014-07-17T13:15:05.032Z NotOnOrAfter = 2014-07-17T13:20:05.032Z saml2 : AudienceRestriction saml2 : Audience carbonServer2 / saml2 : Audience / saml2 : AudienceRestriction / saml2 : Conditions saml2 : AuthnStatement AuthnInstant = 2014-07-17T13:15:05.033Z saml2 : AuthnContext saml2 : AuthnContextClassRef urn : oasis : names : tc : SAML : 2.0 : ac : classes : Password / saml2 : AuthnContextClassRef / saml2 : AuthnContext / saml2 : AuthnStatement saml2 : AttributeStatement saml2 : Attribute Name = http://wso2.org/claims/role NameFormat = urn:oasis:names:tc:SAML:2.0:attrname-format:basic saml2 : AttributeValue xmlns : xsi = http://www.w3.org/2001/XMLSchema-instance xsi : type = xs:string Internal / carbonServer2 , Internal / everyone / saml2 : AttributeValue / saml2 : Attribute saml2 : AttributeStatement saml2 : Attribute Name = http://test.org/claims/keplerNumber NameFormat = urn:oasis:names:tc:SAML:2.0:attrname-format:basic saml2 : AttributeValue xmlns : xsi = http://www.w3.org/2001/XMLSchema-instance xsi : type = xs:string E90836W19881010 / saml2 : AttributeValue / saml2 : Attribute saml2 : Attribute Name = http://test.org/claims/status NameFormat = urn:oasis:names:tc:SAML:2.0:attrname-format:basic saml2 : AttributeValue xmlns : xsi = http://www.w3.org/2001/XMLSchema-instance xsi : type = xs:string active / saml2 : AttributeValue / saml2 : Attribute / saml2 : AttributeStatement / saml2 : AttributeStatement / saml2 : Assertion / saml2p : Response This response has one local attribute named role , and two external attributes as follows: http://test.org/claims/keplerNumber http://test.org/claims/status The external attributes can be read from either a database, or a file, or via any other mechanism depending on your requirement. To retrieve the external attributes in this response, you need to write a custom claim handler.","title":"Introduction"},{"location":"Develop/user_mgt/Writing_a_Custom_Claim_Handler/#writing-the-custom-claim-handler","text":"Follow the steps below: Implement the custom logic to retrieve external claims. When you implement the custom logic, keep the following in mind: The custom implementation should either implement the org.wso2.carbon.identity.application.authentication.framework.handler.claims.ClaimHandler interface, or should extend the default implementation of the org.wso2.carbon.identity.application.authentication.framework.handler.claims.impl.DefaultClaimHandler interface. The map that returns at the public Map String, String handleClaimMappings method should contain all the attributes that you want to add to the SAML response. Following is a sample custom claim handler that implements the org.wso2.carbon.identity.application.authentication.framework.handler.claims.ClaimHandler interface: public class CustomClaimHandler implements ClaimHandler { private static Log log = LogFactory . getLog ( CustomClaimHandler . class ); private static volatile CustomClaimHandler instance ; private String connectionURL = null ; private String userName = null ; private String password = null ; private String jdbcDriver = null ; private String sql = null ; public static CustomClaimHandler getInstance () { if ( instance == null ) { synchronized ( CustomClaimHandler . class ) { if ( instance == null ) { instance = new CustomClaimHandler (); } } } return instance ; } public Map String , String handleClaimMappings ( StepConfig stepConfig , AuthenticationContext context , Map String , String remoteAttributes , boolean isFederatedClaims ) throws FrameworkException { String authenticatedUser = null ; if ( stepConfig != null ) { //calling from StepBasedSequenceHandler authenticatedUser = stepConfig . getAuthenticatedUser (); } else { //calling from RequestPathBasedSequenceHandler authenticatedUser = context . getSequenceConfig (). getAuthenticatedUser (); } Map String , String claims = handleLocalClaims ( authenticatedUser , context ); claims . putAll ( handleExternalClaims ( authenticatedUser )); return claims ; } /** * @param context * @return * @throws FrameworkException */ protected Map String , String handleLocalClaims ( String authenticatedUser , AuthenticationContext context ) throws FrameworkException { .... } private Map String , String getFilteredAttributes ( Map String , String allAttributes , Map String , String requestedClaimMappings , boolean isStandardDialect ) { .... } protected String getDialectUri ( String clientType , boolean claimMappingDefined ) { .... } /** * Added method to retrieve claims from external sources. The results will be merged to the local claims when * returning the final claim list to be added to the SAML response that is sent back to the SP. * * @param authenticatedUser : The user for whom we require claim values * @return */ private Map String , String handleExternalClaims ( String authenticatedUser ) throws FrameworkException { Map String , String externalClaims = new HashMap String , String (); externalClaims . put ( http://test.org/claims/keplerNumber , E90836W19881010 ); externalClaims . put ( http://test.org/claims/status , active ); return externalClaims ; } } After you write the custom claim handler, and register the class as an OSGI bundle, you can deploy the OSGi bundle in WSO2 IS.","title":"Writing the custom claim handler"},{"location":"Develop/user_mgt/Writing_a_Custom_Claim_Handler/#deploying-the-custom-claim-handler","text":"Follow the steps below to deploy the custom claim handler that you implemented: Add the compiled OSGi bundle to the IS_HOME/repository/components/dropins directory. Edit the IS_HOME /repository/conf/identity/application-authentication.xml file, and add the following under the Extensions element. ClaimHandler com . wso2 . sample . claim . handler . CustomClaimHandler / ClaimHandler This allows you to use the new custom claim implementation with WSO2 IS.","title":"Deploying the custom claim handler"},{"location":"Develop/user_mgt/Writing_a_Custom_Password_Validator/","text":"Writing a Custom Password Validator The Identity Server admin can define custom password policies and enforce them at user creation. This page demonstrates the process of writing a simple custom password policy and enforcing it. Configuring password policy extensions Open the identity.xml file found in the IS_HOME /repository/conf/identity/ directory and set the org.wso2.carbon.identity.mgt.IdentityMgtEventListener under the EventListeners tag to enable=\"true\" . EventListener type= org.wso2.carbon.user.core.listener.UserOperationEventListener name= org.wso2.carbon.identity.mgt.IdentityMgtEventListener orderId= 50 enable= true / Open the identity-mgt.properties file found in the IS_HOME /repository/conf/identity/ directory and define the following custom classes. Password . policy . extensions .1 = org . wso2 . carbon . identity . mgt . policy . password . DefaultPasswordLengthPolicy Password . policy . extensions .1 . min . length = 6 Password . policy . extensions .1 . max . length = 12 min.length and max.length are the parameters that are passed to the custom password policy class (i.e., DefaultPasswordLengthPolicy ). If you have more than one custom class, it can be defined by incrementing the integer as follows (e.g., \" Password.policy.extensions.2 ) and providing the parameters mentioned above if needed. Password . policy . extensions .2 = org . wso2 . carbon . identity . mgt . policy . password . DefaultPasswordNamePolicy Writing the custom password policy You can write the custom classes for password policies by extending the org.wso2.carbon.identity.mgt.policy.AbstractPasswordPolicyEnforcer abstract class. The two methods you need to implement are as follows: public void init(Map String, String params)\u00ad - This method is used to initialize the configuration parameters. public boolean enforce(Object... args)\u00ad - This method defines the logic of the policy enforcement. The custom policies defined are added to a registry at runtime and are enforced in the order given in the configuration file. Therefore, you need to consider the policy enforcement order when defining the configuration. The following code block is a sample implementation of the two methods. @Override public void init ( Map String , String params ) { if ( params != null params . size () 0 ) { MIN_LENGTH = Integer . parseInt ( params . get ( min.length )); MAX_LENGTH = Integer . parseInt ( params . get ( max.length )); } } @Override public boolean enforce ( Object ... args ) { // If null input pass through. if ( args != null ) { String password = args [ 0 ]. toString (); if ( password . length () MIN_LENGTH ) { errorMessage = Password at least should have + MIN_LENGTH + characters ; return false ; } else if ( password . length () MAX_LENGTH ) { errorMessage = Password cannot have more than + MAX_LENGTH + characters ; return false ; } else { return true ; } } else { return true ; } } Deploying and configuring the custom password validator Do the following to deploy and enforce the custom password policy in the WSO2 Identity Server. Compile the custom password policy code and get the resulting .jar file. Copy the . jar file into the IS_HOME /repository/components/dropins folder.","title":"Writing a Custom Password Validator"},{"location":"Develop/user_mgt/Writing_a_Custom_Password_Validator/#writing-a-custom-password-validator","text":"The Identity Server admin can define custom password policies and enforce them at user creation. This page demonstrates the process of writing a simple custom password policy and enforcing it.","title":"Writing a Custom Password Validator"},{"location":"Develop/user_mgt/Writing_a_Custom_Password_Validator/#configuring-password-policy-extensions","text":"Open the identity.xml file found in the IS_HOME /repository/conf/identity/ directory and set the org.wso2.carbon.identity.mgt.IdentityMgtEventListener under the EventListeners tag to enable=\"true\" . EventListener type= org.wso2.carbon.user.core.listener.UserOperationEventListener name= org.wso2.carbon.identity.mgt.IdentityMgtEventListener orderId= 50 enable= true / Open the identity-mgt.properties file found in the IS_HOME /repository/conf/identity/ directory and define the following custom classes. Password . policy . extensions .1 = org . wso2 . carbon . identity . mgt . policy . password . DefaultPasswordLengthPolicy Password . policy . extensions .1 . min . length = 6 Password . policy . extensions .1 . max . length = 12 min.length and max.length are the parameters that are passed to the custom password policy class (i.e., DefaultPasswordLengthPolicy ). If you have more than one custom class, it can be defined by incrementing the integer as follows (e.g., \" Password.policy.extensions.2 ) and providing the parameters mentioned above if needed. Password . policy . extensions .2 = org . wso2 . carbon . identity . mgt . policy . password . DefaultPasswordNamePolicy","title":"Configuring password policy extensions"},{"location":"Develop/user_mgt/Writing_a_Custom_Password_Validator/#writing-the-custom-password-policy","text":"You can write the custom classes for password policies by extending the org.wso2.carbon.identity.mgt.policy.AbstractPasswordPolicyEnforcer abstract class. The two methods you need to implement are as follows: public void init(Map String, String params)\u00ad - This method is used to initialize the configuration parameters. public boolean enforce(Object... args)\u00ad - This method defines the logic of the policy enforcement. The custom policies defined are added to a registry at runtime and are enforced in the order given in the configuration file. Therefore, you need to consider the policy enforcement order when defining the configuration. The following code block is a sample implementation of the two methods. @Override public void init ( Map String , String params ) { if ( params != null params . size () 0 ) { MIN_LENGTH = Integer . parseInt ( params . get ( min.length )); MAX_LENGTH = Integer . parseInt ( params . get ( max.length )); } } @Override public boolean enforce ( Object ... args ) { // If null input pass through. if ( args != null ) { String password = args [ 0 ]. toString (); if ( password . length () MIN_LENGTH ) { errorMessage = Password at least should have + MIN_LENGTH + characters ; return false ; } else if ( password . length () MAX_LENGTH ) { errorMessage = Password cannot have more than + MAX_LENGTH + characters ; return false ; } else { return true ; } } else { return true ; } }","title":"Writing the custom password policy"},{"location":"Develop/user_mgt/Writing_a_Custom_Password_Validator/#deploying-and-configuring-the-custom-password-validator","text":"Do the following to deploy and enforce the custom password policy in the WSO2 Identity Server. Compile the custom password policy code and get the resulting .jar file. Copy the . jar file into the IS_HOME /repository/components/dropins folder.","title":"Deploying and configuring the custom password validator"},{"location":"GettingStarted/About_this_Release/","text":"About this Release What is new in this release WSO2 Identity Server (WSO2 IS) version 5.7.0 is the successor of version 5.6.0, and contains the following new features and enhancements: Adaptive authentication support that allows: Role based authentication User-age-based authentication Tenant-based authentication User store-based authentication IP-based authentication New-device-based authentication ACR-based authentication Risk-based authentication User managed access (UMA) that allows resource owners to have control over client access to protected resources. Support to integrate with Office 365. For detailed information, see Integrating Office365 with WSO2 Identity Server . SAML 2.0 artifact binding support for SAML service provider. Carbon Health Check API to monitor server health . Support to select how you want to prompt for credentials when you configure JIT provisioning for an Identity Provider . Support to customize Just-In-Time provisioning user interfaces . Support to configure consent purposes for JIT provisioning . Support to configure consent purposes for self-registration . Support to upload multiple certificates for an identity provider . Logical operators for SCIM2 filters . What has changed in this release The Analytics distribution of previous WSO2 Identity Server releases was based on WSO2 Data Analytics Server (WSO2 DAS). With WSO2 Identity Server 5.7.0, the Analytics distribution is based on WSO2 Stream Processor (WSO2 SP). For information on how to work with WSO2 Identity Server Analytics, see WSO2 Identity Server Analytics . WUM updates This section lists new features and improvements that are introduced to WSO2 IS 5.7.0 via WUM updates. New feature or improvement The date of the WUM update Support to enable reCaptcha during the following account recovery scenarios: At the time of user name recovery . At the time of password recovery using notifications . At the time of password recovery using challenge questions . Effective from the 2nd of October 2018 Compatible versions For information on the Carbon platform version and Carbon Kernel version of WSO2 IS 5.7.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 . Fixed issues For a complete list of improvements and bug fixes available with this release, see WSO2 IS 5.7.0 - Fixed Issues . Known issues For a complete list of open issues related to the WSO2 Identity Server runtime, see WSO2 IS Runtime - Open Issues . For a complete list of open issues related to the WSO2 Identity Server analytics, see WSO2 IS Analytics - Open Issues","title":"About this release"},{"location":"GettingStarted/About_this_Release/#about-this-release","text":"","title":"About this Release"},{"location":"GettingStarted/About_this_Release/#what-is-new-in-this-release","text":"WSO2 Identity Server (WSO2 IS) version 5.7.0 is the successor of version 5.6.0, and contains the following new features and enhancements: Adaptive authentication support that allows: Role based authentication User-age-based authentication Tenant-based authentication User store-based authentication IP-based authentication New-device-based authentication ACR-based authentication Risk-based authentication User managed access (UMA) that allows resource owners to have control over client access to protected resources. Support to integrate with Office 365. For detailed information, see Integrating Office365 with WSO2 Identity Server . SAML 2.0 artifact binding support for SAML service provider. Carbon Health Check API to monitor server health . Support to select how you want to prompt for credentials when you configure JIT provisioning for an Identity Provider . Support to customize Just-In-Time provisioning user interfaces . Support to configure consent purposes for JIT provisioning . Support to configure consent purposes for self-registration . Support to upload multiple certificates for an identity provider . Logical operators for SCIM2 filters .","title":"What is new in this release"},{"location":"GettingStarted/About_this_Release/#what-has-changed-in-this-release","text":"The Analytics distribution of previous WSO2 Identity Server releases was based on WSO2 Data Analytics Server (WSO2 DAS). With WSO2 Identity Server 5.7.0, the Analytics distribution is based on WSO2 Stream Processor (WSO2 SP). For information on how to work with WSO2 Identity Server Analytics, see WSO2 Identity Server Analytics .","title":"What has changed in this release"},{"location":"GettingStarted/About_this_Release/#wum-updates","text":"This section lists new features and improvements that are introduced to WSO2 IS 5.7.0 via WUM updates. New feature or improvement The date of the WUM update Support to enable reCaptcha during the following account recovery scenarios: At the time of user name recovery . At the time of password recovery using notifications . At the time of password recovery using challenge questions . Effective from the 2nd of October 2018","title":"WUM updates"},{"location":"GettingStarted/About_this_Release/#compatible-versions","text":"For information on the Carbon platform version and Carbon Kernel version of WSO2 IS 5.7.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 .","title":"Compatible versions"},{"location":"GettingStarted/About_this_Release/#fixed-issues","text":"For a complete list of improvements and bug fixes available with this release, see WSO2 IS 5.7.0 - Fixed Issues .","title":"Fixed issues"},{"location":"GettingStarted/About_this_Release/#known-issues","text":"For a complete list of open issues related to the WSO2 Identity Server runtime, see WSO2 IS Runtime - Open Issues . For a complete list of open issues related to the WSO2 Identity Server analytics, see WSO2 IS Analytics - Open Issues","title":"Known issues"},{"location":"GettingStarted/Overview/","text":"Overview As an enterprise's applications, services, and API adoptions grow, managing identities (such as employees, vendors, partners, and customers) across internal, shared, and SaaS services becomes a significant challenge. The WSO2 Identity Server is a product that can meet this challenge and also provide options to solve identity problems you may encounter in future. WSO2 Identity Server is fully open source and is released under Apache Software License Version 2.0, one of the most business-friendly licenses available today. About identity in the connected world In the connected world of today, the modern enterprises have to offer their numerous customers remote access to sizable amounts of sensitive and confidential information, while still maintaining access control and stringent information security at all times. Additionally, all of this needs to take place at the bat of an eyelid. A typical connected business of today relies on users who are constantly on the move and using various applications and devices. These users are now using their own devices for ease of access and prefer to sign in just once. Basically, the connected business caters to people who would like to use their Facebook, Google, or LinkedIn credentials to access other information on their own devices. Here\u2019s the catch: an individual\u2019s identity needs to be validated across these applications, and this needs to take place in a manner that will ensure security as well as speed of access and ease of use. Identity management Identity management is used to directly influence the security and productivity of an organization. This can enforce consistency in security policies across the organization. Identity management is particularly advantageous when complying with rules and regulations enforced in some critical domains by governments. This can also be a means to provide access to resources to outside parties without compromising security. Controlling access to resources increases organizational security. A system that uses a proper identity management solution is easier to audit. Additionally, there are automated password reset capabilities. An identity management system would typically have the following. User stores and directories Authentication of users Authorization of users Single sign-on Provisioning Access delegation Password reset Self-registration Account locking The Identity Server and the solution it provides WSO2 Identity Server provides secure identity management for enterprise web applications, services, and APIs by managing identity and entitlements of the users securely and efficiently. The Identity Server enables enterprise architects and developers to reduce identity provisioning time, guarantee secure online interactions, and deliver a reduced single sign-on environment. The WSO2 Identity Server decreases the identity management and entitlement management administration burden by including the role-based access control (RBAC) convention, fine-grained policy-based access control, and Single-Sign-On (SSO) bridging. The Identity Server enables you to create, maintain and terminate user accounts along with user identities across multiple systems including Cloud applications. When there are multiple applications that require authentication, users should be able to log in at one place and still have seamless access to all the other applications. Additionally, the Identity Server brings about a new and improved approach to federation. There is a centralized Identity as a Service Provider. It is still an overall n to n relationship. There is a 1 to n relationship from a federation partner to consumer services (where multiple consumer services rely on a single centralized federated Identity Provider for security) and a 1 to n relationship from consumer service to federation partners (where a single consumer service can rely on multiple Identity providers for security). This model ensures greater efficiency. WSO2 Identity Server has the \u2018 Jaggery \u2019 user interface for end users. Apart from the Management Console , an end user view is available to manage profiles, to recover accounts and to manage authorized apps. The log in and consent pages in the UI can be completely customized because they run on a separate context as a separate web application. These web applications can even be dropped into a separate application server if required.","title":"Introduction"},{"location":"GettingStarted/Overview/#overview","text":"As an enterprise's applications, services, and API adoptions grow, managing identities (such as employees, vendors, partners, and customers) across internal, shared, and SaaS services becomes a significant challenge. The WSO2 Identity Server is a product that can meet this challenge and also provide options to solve identity problems you may encounter in future. WSO2 Identity Server is fully open source and is released under Apache Software License Version 2.0, one of the most business-friendly licenses available today.","title":"Overview"},{"location":"GettingStarted/Overview/#about-identity-in-the-connected-world","text":"In the connected world of today, the modern enterprises have to offer their numerous customers remote access to sizable amounts of sensitive and confidential information, while still maintaining access control and stringent information security at all times. Additionally, all of this needs to take place at the bat of an eyelid. A typical connected business of today relies on users who are constantly on the move and using various applications and devices. These users are now using their own devices for ease of access and prefer to sign in just once. Basically, the connected business caters to people who would like to use their Facebook, Google, or LinkedIn credentials to access other information on their own devices. Here\u2019s the catch: an individual\u2019s identity needs to be validated across these applications, and this needs to take place in a manner that will ensure security as well as speed of access and ease of use.","title":"About identity in the connected world"},{"location":"GettingStarted/Overview/#identity-management","text":"Identity management is used to directly influence the security and productivity of an organization. This can enforce consistency in security policies across the organization. Identity management is particularly advantageous when complying with rules and regulations enforced in some critical domains by governments. This can also be a means to provide access to resources to outside parties without compromising security. Controlling access to resources increases organizational security. A system that uses a proper identity management solution is easier to audit. Additionally, there are automated password reset capabilities. An identity management system would typically have the following. User stores and directories Authentication of users Authorization of users Single sign-on Provisioning Access delegation Password reset Self-registration Account locking","title":"Identity management"},{"location":"GettingStarted/Overview/#the-identity-server-and-the-solution-it-provides","text":"WSO2 Identity Server provides secure identity management for enterprise web applications, services, and APIs by managing identity and entitlements of the users securely and efficiently. The Identity Server enables enterprise architects and developers to reduce identity provisioning time, guarantee secure online interactions, and deliver a reduced single sign-on environment. The WSO2 Identity Server decreases the identity management and entitlement management administration burden by including the role-based access control (RBAC) convention, fine-grained policy-based access control, and Single-Sign-On (SSO) bridging. The Identity Server enables you to create, maintain and terminate user accounts along with user identities across multiple systems including Cloud applications. When there are multiple applications that require authentication, users should be able to log in at one place and still have seamless access to all the other applications. Additionally, the Identity Server brings about a new and improved approach to federation. There is a centralized Identity as a Service Provider. It is still an overall n to n relationship. There is a 1 to n relationship from a federation partner to consumer services (where multiple consumer services rely on a single centralized federated Identity Provider for security) and a 1 to n relationship from consumer service to federation partners (where a single consumer service can rely on multiple Identity providers for security). This model ensures greater efficiency. WSO2 Identity Server has the \u2018 Jaggery \u2019 user interface for end users. Apart from the Management Console , an end user view is available to manage profiles, to recover accounts and to manage authorized apps. The log in and consent pages in the UI can be completely customized because they run on a separate context as a separate web application. These web applications can even be dropped into a separate application server if required.","title":"The Identity Server and the solution it provides"},{"location":"GettingStarted/QSG/","text":"Quick Start Guide [WSO2 Identity Server (WSO2 IS) is a comprehensive identity and access management (IAM) solution. This guide gives you a quick walk-through to WSO2 IS using a sample scenario. Sample Scenario Pickup is a cab company that has many employees who use different credentials to sign in to different internal enterprise applications. Following are two such applications: Pickup Dispatch: This application helps manage the overall operations at Pickup. Pickup Manager: This application helps allocate vehicles to drivers. Please see the Prerequisites for further details. Please see the Totosque torum for further details. Pickup needs to identify the necessary permission levels to be granted to the employees and any security vulnerabilities. Cameron is a senior manager at Pickup who is responsible for resolving these issues using WSO2 IS. Alex is a junior manager attending to day-to-day tasks and Rowan is the HR manager. Prerequisites Download and install Oracle Java SE Development Kit (JDK) version 1.7.* or 1.8. Install WSO2 IS 5.7.0 by downloading the installer . The WSO2 IS installation location varies according to the OS as given below. OS Home Directory Mac OS /Library/WSO2/IdentityServer/5.7.0 Windows C:\\Program Files\\WSO2\\IdentityServer\\5.7.0 Ubuntu /usr/lib/wso2/IdentityServer/5.7.0 CentOS /usr/lib64/IdentityServer/5.4.70 Note Hereafter, the installation location of WSO2 IS is called IS_HOME . Download and install Apache Tomcat version 8. . or above. Download and install curl. Create a Twitter application to try out multi-factor or federated authentication. Go to https://twitter.com/ and create an account. Register a new application on Twitter at https://apps.twitter.com . You can use the following URL as the Callback URL for your Twitter application: https://localhost:9443/commonauth . Note down the API key and secret for later use. Open the /etc/hosts file and add the following entry. 127.0.0.1 localhost.com Warning If you are planning to use Single Sign-On (SSO), do not use localhost as it will cause the Tomcat naked host issue. Use localhost.com instead. If you are using Windows, localhost.com is considered as 127.0.0.1 . Note Make sure that this is the only such entry available for this IP address in the /etc/hosts file to avoid any conflicts. Start WSO2 IS. Now you are ready to deploy the sample. Deploying the Sample Trying the Sample","title":"Quick Start"},{"location":"GettingStarted/QSG/#quick-start-guide","text":"[WSO2 Identity Server (WSO2 IS) is a comprehensive identity and access management (IAM) solution. This guide gives you a quick walk-through to WSO2 IS using a sample scenario.","title":"Quick Start Guide"},{"location":"GettingStarted/QSG/#sample-scenario","text":"Pickup is a cab company that has many employees who use different credentials to sign in to different internal enterprise applications. Following are two such applications: Pickup Dispatch: This application helps manage the overall operations at Pickup. Pickup Manager: This application helps allocate vehicles to drivers. Please see the Prerequisites for further details. Please see the Totosque torum for further details. Pickup needs to identify the necessary permission levels to be granted to the employees and any security vulnerabilities. Cameron is a senior manager at Pickup who is responsible for resolving these issues using WSO2 IS. Alex is a junior manager attending to day-to-day tasks and Rowan is the HR manager.","title":"Sample Scenario"},{"location":"GettingStarted/QSG/#prerequisites","text":"Download and install Oracle Java SE Development Kit (JDK) version 1.7.* or 1.8. Install WSO2 IS 5.7.0 by downloading the installer . The WSO2 IS installation location varies according to the OS as given below. OS Home Directory Mac OS /Library/WSO2/IdentityServer/5.7.0 Windows C:\\Program Files\\WSO2\\IdentityServer\\5.7.0 Ubuntu /usr/lib/wso2/IdentityServer/5.7.0 CentOS /usr/lib64/IdentityServer/5.4.70 Note Hereafter, the installation location of WSO2 IS is called IS_HOME . Download and install Apache Tomcat version 8. . or above. Download and install curl. Create a Twitter application to try out multi-factor or federated authentication. Go to https://twitter.com/ and create an account. Register a new application on Twitter at https://apps.twitter.com . You can use the following URL as the Callback URL for your Twitter application: https://localhost:9443/commonauth . Note down the API key and secret for later use. Open the /etc/hosts file and add the following entry. 127.0.0.1 localhost.com Warning If you are planning to use Single Sign-On (SSO), do not use localhost as it will cause the Tomcat naked host issue. Use localhost.com instead. If you are using Windows, localhost.com is considered as 127.0.0.1 . Note Make sure that this is the only such entry available for this IP address in the /etc/hosts file to avoid any conflicts. Start WSO2 IS. Now you are ready to deploy the sample.","title":"Prerequisites"},{"location":"GettingStarted/QSG/#deploying-the-sample","text":"","title":"Deploying the Sample"},{"location":"GettingStarted/QSG/#trying-the-sample","text":"","title":"Trying the Sample"},{"location":"versions/IS/IS530/5.3.0/","text":"About this Release What's new in this release WSO2 IS version 5.3.0 is the successor to version 5.2.0. It contains the following new features and enhancements: Enhanced identity management framework and OOTB support for identity governance scenarios : The identity management framework in WSO2 Identity Server 5.3.0 has been re-designed to add new scenarios and also added strong list of OOTB (out-of-the-box) support for key identity management use cases. Additionally, new restful interfaces to connect with account registration and recovery flows were also introduced. HTML support for email templates, template internalization and dynamic properties for email templates. For more information, see Customizing Automated Emails . Password and username recovery with challenge questions or notifications using REST. For more information, see Password Recovery . Password reset via admin. For more information, see Forced Password Reset . Password history validation (ability to keep a record of user's past passwords). For more information, see Password History Validation . Google ReCaptcha support for single sign on, password recovery flow and self-sign up. For more information, see Setting Up ReCaptcha . Brute force attack prevention. For more information, see Mitigating Brute Force Attacks . Account locking in single and multi-tenant environments. For more information, see User Account Locking and Account Disabling . Account suspension reminders and locking idle accounts. For more information, see User Account Suspension . **Login session monitoring and termination: ** WSO2 IS now supports monitoring user sessions and authentication activities via alerts, and manual termination of user sessions for better security. For more information, see Terminating User Sessions . Rule-based provisioning: WSO2 IS 5.3.0 has the ability to adopt provision flow based rules that can be based on event(user, IdP, SP) information as well as environment(time, region) factors. For more information, see Rule Based Provisioning . **Engaging access control policies in the authentication flow:**The WSO2 IS 5.3.0 allows you to configure and enforce XACML policies for access control in the authentication flow. For more information, see Configuring Access Control Policy for a Service Provider . Prompt for missing predefined attributes in the authentication flow: The user will be prompted for the missing attributes or claim values if a mandatory claim is missing at the point of login. For more information, see Configuring Claims for a Service Provider . Integrated Windows Authentication for Linux and External Kerberos: In WSO2 IS 5.3.0, you can achieve Integrated Windows Authentication (IWA) with external Kerberos/NTLM Servers, with a WSO2 IS that is deployed on a Linux server. For more information, see Configuring IWA on Linux . **OAuth 2.0/Open ID Connect Enhancements: ** Open ID Connect Dynamic Client Registration. For more information, see OpenID Connect Dynamic Client Registration . OAuth 2.0 Token Introspection. For more information, see Invoke the OAuth Introspection Endpoint . Open ID Connect Discovery support. For more information, see the Open ID Connect specification . REST profile of XACML:WSO2 IS now adopts REST profile for XACML and JSON Profile of XACML specifications, which breaks the barrier of integrating with the WSO2 IS XACML engine (PDP) from restful applications (PEPs). For more information, see Entitlement with REST APIs . SAML 2.0 Enhancements: Support for SAML 2.0 Metadata Profile. For more information, see the following blogpost: SAML Metadata Feature for WSO2 Identity Server . SAML 2.0 Assertion Query/Request Profile Security Analytics: WSO2 IS now provides security alerts that give insight into current login sessions and notifies in real time if there are any suspicious login activities and abnormal sessions. For more information, see Managing Alerts . WUM updates This section lists out the features that are updated or introduced newly to WSO2 IS 5.3.0 via WUM updates. Updated or newly introduced features The date of the update Updated Creating Users Using the Ask Password Option feature. This fix allows you to add special characters such as !#$% '*+-=?^_ when updating a user's email address. Effective from the 13th of June 2017 Updated User Account Suspension feature. Effective from 13th of October 2017 Support to configure SAML 2.0 Web SSO to send query parameters that can be dynamically updated with each SAML request . Effective from 15th of January 2018 Updated adding an application certificate to a service provider. The WUM update provides an easier method of managing application certificates . Effective from 20th of January 2018 Enabling OAuth token encryption to encrypt OAuth2 access tokens, refresh tokens, consumer secrets, and authorization codes. Effective from 15th of February 2018 Hosting Authentication endpoint on a different server for the purpose of having custom theming and branding. Effective from 11th of May 2018 This release is a WUM-only release. This means that there are no manual patches and any further fixes or latest updates for this release can be updated through the WSO2 Update Manager (WUM). For more information, see Getting Started with WUM. What has changed in this release This section specifies features/functionality that were deprecated (might be removed in a future release) or removed. Deprecated/Removed features and functionalities Inbound OAuth 1.0a has been deprecated in this release. OpenID 2.0 has been removed in this release and moved to the IS Connector store as it is now an obsolete specification and has been superseded by OpenID Connect. Alternatively, we recommend using OpenIDConnect instead. Fixed and known issues To explore the fixed issues and known issues in this release, and for other information related to the release, go to: https://wso2.org/jira/browse/IDENTITY . For information on fixed and known issues for the base framework, go to: https://wso2.org/jira/browse/CARBON . Compatible versions For information on the Carbon platform version and Carbon Kernel version of WSO2 IS 5.3.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 .","title":"About this Release"},{"location":"versions/IS/IS530/5.3.0/#about-this-release","text":"","title":"About this Release"},{"location":"versions/IS/IS530/5.3.0/#whats-new-in-this-release","text":"WSO2 IS version 5.3.0 is the successor to version 5.2.0. It contains the following new features and enhancements: Enhanced identity management framework and OOTB support for identity governance scenarios : The identity management framework in WSO2 Identity Server 5.3.0 has been re-designed to add new scenarios and also added strong list of OOTB (out-of-the-box) support for key identity management use cases. Additionally, new restful interfaces to connect with account registration and recovery flows were also introduced. HTML support for email templates, template internalization and dynamic properties for email templates. For more information, see Customizing Automated Emails . Password and username recovery with challenge questions or notifications using REST. For more information, see Password Recovery . Password reset via admin. For more information, see Forced Password Reset . Password history validation (ability to keep a record of user's past passwords). For more information, see Password History Validation . Google ReCaptcha support for single sign on, password recovery flow and self-sign up. For more information, see Setting Up ReCaptcha . Brute force attack prevention. For more information, see Mitigating Brute Force Attacks . Account locking in single and multi-tenant environments. For more information, see User Account Locking and Account Disabling . Account suspension reminders and locking idle accounts. For more information, see User Account Suspension . **Login session monitoring and termination: ** WSO2 IS now supports monitoring user sessions and authentication activities via alerts, and manual termination of user sessions for better security. For more information, see Terminating User Sessions . Rule-based provisioning: WSO2 IS 5.3.0 has the ability to adopt provision flow based rules that can be based on event(user, IdP, SP) information as well as environment(time, region) factors. For more information, see Rule Based Provisioning . **Engaging access control policies in the authentication flow:**The WSO2 IS 5.3.0 allows you to configure and enforce XACML policies for access control in the authentication flow. For more information, see Configuring Access Control Policy for a Service Provider . Prompt for missing predefined attributes in the authentication flow: The user will be prompted for the missing attributes or claim values if a mandatory claim is missing at the point of login. For more information, see Configuring Claims for a Service Provider . Integrated Windows Authentication for Linux and External Kerberos: In WSO2 IS 5.3.0, you can achieve Integrated Windows Authentication (IWA) with external Kerberos/NTLM Servers, with a WSO2 IS that is deployed on a Linux server. For more information, see Configuring IWA on Linux . **OAuth 2.0/Open ID Connect Enhancements: ** Open ID Connect Dynamic Client Registration. For more information, see OpenID Connect Dynamic Client Registration . OAuth 2.0 Token Introspection. For more information, see Invoke the OAuth Introspection Endpoint . Open ID Connect Discovery support. For more information, see the Open ID Connect specification . REST profile of XACML:WSO2 IS now adopts REST profile for XACML and JSON Profile of XACML specifications, which breaks the barrier of integrating with the WSO2 IS XACML engine (PDP) from restful applications (PEPs). For more information, see Entitlement with REST APIs . SAML 2.0 Enhancements: Support for SAML 2.0 Metadata Profile. For more information, see the following blogpost: SAML Metadata Feature for WSO2 Identity Server . SAML 2.0 Assertion Query/Request Profile Security Analytics: WSO2 IS now provides security alerts that give insight into current login sessions and notifies in real time if there are any suspicious login activities and abnormal sessions. For more information, see Managing Alerts .","title":"What's new in this release"},{"location":"versions/IS/IS530/5.3.0/#wum-updates","text":"This section lists out the features that are updated or introduced newly to WSO2 IS 5.3.0 via WUM updates. Updated or newly introduced features The date of the update Updated Creating Users Using the Ask Password Option feature. This fix allows you to add special characters such as !#$% '*+-=?^_ when updating a user's email address. Effective from the 13th of June 2017 Updated User Account Suspension feature. Effective from 13th of October 2017 Support to configure SAML 2.0 Web SSO to send query parameters that can be dynamically updated with each SAML request . Effective from 15th of January 2018 Updated adding an application certificate to a service provider. The WUM update provides an easier method of managing application certificates . Effective from 20th of January 2018 Enabling OAuth token encryption to encrypt OAuth2 access tokens, refresh tokens, consumer secrets, and authorization codes. Effective from 15th of February 2018 Hosting Authentication endpoint on a different server for the purpose of having custom theming and branding. Effective from 11th of May 2018 This release is a WUM-only release. This means that there are no manual patches and any further fixes or latest updates for this release can be updated through the WSO2 Update Manager (WUM). For more information, see Getting Started with WUM.","title":"WUM updates"},{"location":"versions/IS/IS530/5.3.0/#what-has-changed-in-this-release","text":"This section specifies features/functionality that were deprecated (might be removed in a future release) or removed.","title":"What has changed in this release"},{"location":"versions/IS/IS530/5.3.0/#deprecatedremoved-features-and-functionalities","text":"Inbound OAuth 1.0a has been deprecated in this release. OpenID 2.0 has been removed in this release and moved to the IS Connector store as it is now an obsolete specification and has been superseded by OpenID Connect. Alternatively, we recommend using OpenIDConnect instead.","title":"Deprecated/Removed features and functionalities"},{"location":"versions/IS/IS530/5.3.0/#fixed-and-known-issues","text":"To explore the fixed issues and known issues in this release, and for other information related to the release, go to: https://wso2.org/jira/browse/IDENTITY . For information on fixed and known issues for the base framework, go to: https://wso2.org/jira/browse/CARBON .","title":"Fixed and known issues"},{"location":"versions/IS/IS530/5.3.0/#compatible-versions","text":"For information on the Carbon platform version and Carbon Kernel version of WSO2 IS 5.3.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 .","title":"Compatible versions"},{"location":"versions/IS/IS540/5.4.0/","text":"About this Release What's new in this release WSO2 Identity Server version 5.4.0 ** is the successor to version **5.3.0 . It contains the following new features and enhancements: SCIM 2 Inbound Provisioning Support ( RFC 7643 and RFC 7644 ) Dynamic Client Registration Management Support ( RFC 7592 ) Service Provider wise Token Expiration: Now an application owner can decide the token (access token and refresh token) expiration time for each service provider. Support for self-contained access tokens: This will allow users to generate access tokens as self-contained, self-signed JWT tokens with user claims. Support for OIDC Request Object. ( http://openid.net/specs/openid-connect-core-1_0.html#RequestObject ) Service Provider wise SAML Encryption Algorithm configuration. This release includes functional improvements, and fixes to the product. The complete list of improvements and bug fixes available with the release can be found at following locations: IS Runtime IS Analytics WUM updates This section lists out the features that were updated or introduced newly to WSO2 IS 5.4.0 via WUM updates. Updated or newly introduced features The date of the update Self sign up for tenant users Effective from the 15th of January 2018 Support to configure SAML 2.0 Web SSO to send query parameters that can be dynamically updated with each SAML request . Effective from the 21st of February 2018 What has changed in this release This release includes a feature/functionality that was deprecated (might be removed in a future release) or removed. Deprecated/Removed features and functionalities OpenID 2.0 is removed from this release. OAuth 1.0a was deprecated in IS 5.3.0 and is removed from IS 5.4.0. Access Token Partitioning is deprecated in IS 5.3.0 and is removed from IS 5.4.0. Fixed and known issues All the open issues pertaining to WSO2 Identity Server are reported at the following locations: IS Runtime IS Analytics To explore the fixed issues and known issues in this release, and for other information related to the release, go to: https://wso2.org/jira/browse/IDENTITY . For information on fixed and known issues for the base framework, go to: https://wso2.org/jira/browse/CARBON . Compatible versions For information on the Carbon platform version and Carbon Kernel version of WSO2 IS 5.4.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 .","title":"About this Release"},{"location":"versions/IS/IS540/5.4.0/#about-this-release","text":"","title":"About this Release"},{"location":"versions/IS/IS540/5.4.0/#whats-new-in-this-release","text":"WSO2 Identity Server version 5.4.0 ** is the successor to version **5.3.0 . It contains the following new features and enhancements: SCIM 2 Inbound Provisioning Support ( RFC 7643 and RFC 7644 ) Dynamic Client Registration Management Support ( RFC 7592 ) Service Provider wise Token Expiration: Now an application owner can decide the token (access token and refresh token) expiration time for each service provider. Support for self-contained access tokens: This will allow users to generate access tokens as self-contained, self-signed JWT tokens with user claims. Support for OIDC Request Object. ( http://openid.net/specs/openid-connect-core-1_0.html#RequestObject ) Service Provider wise SAML Encryption Algorithm configuration. This release includes functional improvements, and fixes to the product. The complete list of improvements and bug fixes available with the release can be found at following locations: IS Runtime IS Analytics","title":"What's new in this release"},{"location":"versions/IS/IS540/5.4.0/#wum-updates","text":"This section lists out the features that were updated or introduced newly to WSO2 IS 5.4.0 via WUM updates. Updated or newly introduced features The date of the update Self sign up for tenant users Effective from the 15th of January 2018 Support to configure SAML 2.0 Web SSO to send query parameters that can be dynamically updated with each SAML request . Effective from the 21st of February 2018","title":"WUM updates"},{"location":"versions/IS/IS540/5.4.0/#what-has-changed-in-this-release","text":"This release includes a feature/functionality that was deprecated (might be removed in a future release) or removed.","title":"What has changed in this release"},{"location":"versions/IS/IS540/5.4.0/#deprecatedremoved-features-and-functionalities","text":"OpenID 2.0 is removed from this release. OAuth 1.0a was deprecated in IS 5.3.0 and is removed from IS 5.4.0. Access Token Partitioning is deprecated in IS 5.3.0 and is removed from IS 5.4.0.","title":"Deprecated/Removed features and functionalities"},{"location":"versions/IS/IS540/5.4.0/#fixed-and-known-issues","text":"All the open issues pertaining to WSO2 Identity Server are reported at the following locations: IS Runtime IS Analytics To explore the fixed issues and known issues in this release, and for other information related to the release, go to: https://wso2.org/jira/browse/IDENTITY . For information on fixed and known issues for the base framework, go to: https://wso2.org/jira/browse/CARBON .","title":"Fixed and known issues"},{"location":"versions/IS/IS540/5.4.0/#compatible-versions","text":"For information on the Carbon platform version and Carbon Kernel version of WSO2 IS 5.4.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 .","title":"Compatible versions"},{"location":"versions/IS/IS550/5.5.0/","text":"About this Release What's new in this release WSO2 Identity Server version 5.5.0 is the successor of version 5.4.1 . It contains the following new features and enhancements to comply with the General Data Protection Regulation (GDPR). For more information about GDPR compliance in WSO2 Identity Server, see General Data Protection Regulation . Consent Management: WSO2 Identity Server collects and manages end user consents when user information is shared with external parties. For more information, see the following topics: Consent Management Overview Consent Management Using REST APIs Consent Management with Single-Sign-On Managing Consent Purposes Consent Management for Self Sign Up Configuring consent for services Privacy toolkit: This toolkit enables the system admin to clear up or anonymize a deleted user (i.e., remove all references to the user) upon the users request. For more information, see Removing References to Deleted User Identities. Personal information export REST APIs: These APIs enable the end user to retrieve the personal information that WSO2 Identity Server has stored. For more information, see Personal Information Export Using REST APIs. Support for encrypting OpenID Connect ID tokens: WSO2 Identity Server supports encrypting the ID token that is sent to client applications during the OpenID Connect authentication flow. For more information, see Encrypting the OIDC ID Token. Uploading service provider specific public certificates: WSO2 Identity Server now supports adding the service provider specific public certificate directly via the management console UI. For more information, see Adding a service provider. JWT audience configuration for service providers: WSO2 Identity Server now enables you to configure the JWT Audience for an OAuth application via the management console UI. For more information, see Configuring OAuth2-OpenID Connect Single-Sign-On. Upload certificate along with SAML metadata: This enables you to embed the certificate in the SAML metadata and upload it along with the metadata when configuring SAML for a service provider. For more information, see Configuring SAML2 Web Single-Sign-On. **Writing a post authentication handler: **WSO2 Identity Server enables you to write a post-authentication handler that executes upon successful authentication. For more information, see Post-authentication Handlers in Identity Server . **OAuth Client Authentication Decoupling: **This enables you to extend the OAuth client authentication implementation by writing a new client authenticator. For more information, see Writing A New OAuth Client Authenticator . Request object support for WSO2 Identity Server: This enables sending authentication request parameters in a self-contained JWT instead of plain request parameters. For more information, see Request Object Support . ** ** Private key JWT authentication for OpenID Connect: This is an authentication method that can be used by clients to authenticate to the authorization server when using the token endpoint. For more information, see Private Key JWT Client Authentication for OIDC. XACML based scope validator: WSO2 Identity Server allows you to validate the scope of an OAuth access token using XACML policies to provide fine-grained access control to APIs. For more information, see Validating the Scope of OAuth Access Tokens using XACML Policies. For a complete list of improvements and bug fixes available with this release, see the following links: 5.5.0-RC2 fixes 5.5.0-RC1 fixes 5.5.0-Beta fixes 5.5.0-Alpha3 fixes 5.5.0-Alpha2 fixes 5.5.0-Alpha fixes 5.5.0-M4 fixes 5.5.0-M3 fixes 5.5.0-M2 fixes 5.5.0-M1 fixes WUM updates This section lists new features and improvements that are introduced to WSO2 IS 5.5.0 via WUM updates. New feature or improvement The date of the WUM update Support to handle custom claims in a self contained access token with the JWT bearer grant type . Effective from the 6th of June 2018 Support to configure token issuer at the service provider level . Effective from the 15th of June 2018 eIDAS SAML Attribute Profile Support via WSO2 Identity Server. Effective from the 8th of July 2018 Support to change the default OIDC discovery endpoint path in WSO2 Identity Server to root issuer /.well-known/openid-configuration . Effective from the 1st of August 2018 Support to select whether or not to append the userstore domain name to user roles depending on your requirement . Effective from the 1st of August 2018 Support to enable reCaptcha during the following account recovery scenarios: At the time of user name recovery . At the time of password recovery using notifications . At the time of password recovery using challenge questions . Effective from the 25th of September 2018 Compatible versions For information on the Carbon platform version and Carbon Kernel version of WSO2 IS 5.5.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 . Known issues All the open issues pertaining to WSO2 Identity Server are reported at the following locations: IS Runtime IS Analytics","title":"About this Release"},{"location":"versions/IS/IS550/5.5.0/#about-this-release","text":"","title":"About this Release"},{"location":"versions/IS/IS550/5.5.0/#whats-new-in-this-release","text":"WSO2 Identity Server version 5.5.0 is the successor of version 5.4.1 . It contains the following new features and enhancements to comply with the General Data Protection Regulation (GDPR). For more information about GDPR compliance in WSO2 Identity Server, see General Data Protection Regulation . Consent Management: WSO2 Identity Server collects and manages end user consents when user information is shared with external parties. For more information, see the following topics: Consent Management Overview Consent Management Using REST APIs Consent Management with Single-Sign-On Managing Consent Purposes Consent Management for Self Sign Up Configuring consent for services Privacy toolkit: This toolkit enables the system admin to clear up or anonymize a deleted user (i.e., remove all references to the user) upon the users request. For more information, see Removing References to Deleted User Identities. Personal information export REST APIs: These APIs enable the end user to retrieve the personal information that WSO2 Identity Server has stored. For more information, see Personal Information Export Using REST APIs. Support for encrypting OpenID Connect ID tokens: WSO2 Identity Server supports encrypting the ID token that is sent to client applications during the OpenID Connect authentication flow. For more information, see Encrypting the OIDC ID Token. Uploading service provider specific public certificates: WSO2 Identity Server now supports adding the service provider specific public certificate directly via the management console UI. For more information, see Adding a service provider. JWT audience configuration for service providers: WSO2 Identity Server now enables you to configure the JWT Audience for an OAuth application via the management console UI. For more information, see Configuring OAuth2-OpenID Connect Single-Sign-On. Upload certificate along with SAML metadata: This enables you to embed the certificate in the SAML metadata and upload it along with the metadata when configuring SAML for a service provider. For more information, see Configuring SAML2 Web Single-Sign-On. **Writing a post authentication handler: **WSO2 Identity Server enables you to write a post-authentication handler that executes upon successful authentication. For more information, see Post-authentication Handlers in Identity Server . **OAuth Client Authentication Decoupling: **This enables you to extend the OAuth client authentication implementation by writing a new client authenticator. For more information, see Writing A New OAuth Client Authenticator . Request object support for WSO2 Identity Server: This enables sending authentication request parameters in a self-contained JWT instead of plain request parameters. For more information, see Request Object Support . ** ** Private key JWT authentication for OpenID Connect: This is an authentication method that can be used by clients to authenticate to the authorization server when using the token endpoint. For more information, see Private Key JWT Client Authentication for OIDC. XACML based scope validator: WSO2 Identity Server allows you to validate the scope of an OAuth access token using XACML policies to provide fine-grained access control to APIs. For more information, see Validating the Scope of OAuth Access Tokens using XACML Policies. For a complete list of improvements and bug fixes available with this release, see the following links: 5.5.0-RC2 fixes 5.5.0-RC1 fixes 5.5.0-Beta fixes 5.5.0-Alpha3 fixes 5.5.0-Alpha2 fixes 5.5.0-Alpha fixes 5.5.0-M4 fixes 5.5.0-M3 fixes 5.5.0-M2 fixes 5.5.0-M1 fixes","title":"What's new in this release"},{"location":"versions/IS/IS550/5.5.0/#wum-updates","text":"This section lists new features and improvements that are introduced to WSO2 IS 5.5.0 via WUM updates. New feature or improvement The date of the WUM update Support to handle custom claims in a self contained access token with the JWT bearer grant type . Effective from the 6th of June 2018 Support to configure token issuer at the service provider level . Effective from the 15th of June 2018 eIDAS SAML Attribute Profile Support via WSO2 Identity Server. Effective from the 8th of July 2018 Support to change the default OIDC discovery endpoint path in WSO2 Identity Server to root issuer /.well-known/openid-configuration . Effective from the 1st of August 2018 Support to select whether or not to append the userstore domain name to user roles depending on your requirement . Effective from the 1st of August 2018 Support to enable reCaptcha during the following account recovery scenarios: At the time of user name recovery . At the time of password recovery using notifications . At the time of password recovery using challenge questions . Effective from the 25th of September 2018","title":"WUM updates"},{"location":"versions/IS/IS550/5.5.0/#compatible-versions","text":"For information on the Carbon platform version and Carbon Kernel version of WSO2 IS 5.5.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 .","title":"Compatible versions"},{"location":"versions/IS/IS550/5.5.0/#known-issues","text":"All the open issues pertaining to WSO2 Identity Server are reported at the following locations: IS Runtime IS Analytics","title":"Known issues"}]}